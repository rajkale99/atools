// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: update_metadata.proto

package chromeos_update_engine;

public final class UpdateMetadata {
  private UpdateMetadata() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  public interface ExtentOrBuilder extends
      // @@protoc_insertion_point(interface_extends:chromeos_update_engine.Extent)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>optional uint64 start_block = 1;</code>
     * @return Whether the startBlock field is set.
     */
    boolean hasStartBlock();
    /**
     * <code>optional uint64 start_block = 1;</code>
     * @return The startBlock.
     */
    long getStartBlock();

    /**
     * <code>optional uint64 num_blocks = 2;</code>
     * @return Whether the numBlocks field is set.
     */
    boolean hasNumBlocks();
    /**
     * <code>optional uint64 num_blocks = 2;</code>
     * @return The numBlocks.
     */
    long getNumBlocks();
  }
  /**
   * Protobuf type {@code chromeos_update_engine.Extent}
   */
  public static final class Extent extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:chromeos_update_engine.Extent)
      ExtentOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use Extent.newBuilder() to construct.
    private Extent(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private Extent() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new Extent();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private Extent(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 8: {
              bitField0_ |= 0x00000001;
              startBlock_ = input.readUInt64();
              break;
            }
            case 16: {
              bitField0_ |= 0x00000002;
              numBlocks_ = input.readUInt64();
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_Extent_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_Extent_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              chromeos_update_engine.UpdateMetadata.Extent.class, chromeos_update_engine.UpdateMetadata.Extent.Builder.class);
    }

    private int bitField0_;
    public static final int START_BLOCK_FIELD_NUMBER = 1;
    private long startBlock_;
    /**
     * <code>optional uint64 start_block = 1;</code>
     * @return Whether the startBlock field is set.
     */
    @java.lang.Override
    public boolean hasStartBlock() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>optional uint64 start_block = 1;</code>
     * @return The startBlock.
     */
    @java.lang.Override
    public long getStartBlock() {
      return startBlock_;
    }

    public static final int NUM_BLOCKS_FIELD_NUMBER = 2;
    private long numBlocks_;
    /**
     * <code>optional uint64 num_blocks = 2;</code>
     * @return Whether the numBlocks field is set.
     */
    @java.lang.Override
    public boolean hasNumBlocks() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>optional uint64 num_blocks = 2;</code>
     * @return The numBlocks.
     */
    @java.lang.Override
    public long getNumBlocks() {
      return numBlocks_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeUInt64(1, startBlock_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeUInt64(2, numBlocks_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(1, startBlock_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(2, numBlocks_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof chromeos_update_engine.UpdateMetadata.Extent)) {
        return super.equals(obj);
      }
      chromeos_update_engine.UpdateMetadata.Extent other = (chromeos_update_engine.UpdateMetadata.Extent) obj;

      if (hasStartBlock() != other.hasStartBlock()) return false;
      if (hasStartBlock()) {
        if (getStartBlock()
            != other.getStartBlock()) return false;
      }
      if (hasNumBlocks() != other.hasNumBlocks()) return false;
      if (hasNumBlocks()) {
        if (getNumBlocks()
            != other.getNumBlocks()) return false;
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasStartBlock()) {
        hash = (37 * hash) + START_BLOCK_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getStartBlock());
      }
      if (hasNumBlocks()) {
        hash = (37 * hash) + NUM_BLOCKS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getNumBlocks());
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static chromeos_update_engine.UpdateMetadata.Extent parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.Extent parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.Extent parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.Extent parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.Extent parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.Extent parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.Extent parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.Extent parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.Extent parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.Extent parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.Extent parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.Extent parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(chromeos_update_engine.UpdateMetadata.Extent prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code chromeos_update_engine.Extent}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:chromeos_update_engine.Extent)
        chromeos_update_engine.UpdateMetadata.ExtentOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_Extent_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_Extent_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                chromeos_update_engine.UpdateMetadata.Extent.class, chromeos_update_engine.UpdateMetadata.Extent.Builder.class);
      }

      // Construct using chromeos_update_engine.UpdateMetadata.Extent.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        startBlock_ = 0L;
        bitField0_ = (bitField0_ & ~0x00000001);
        numBlocks_ = 0L;
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_Extent_descriptor;
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.Extent getDefaultInstanceForType() {
        return chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance();
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.Extent build() {
        chromeos_update_engine.UpdateMetadata.Extent result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.Extent buildPartial() {
        chromeos_update_engine.UpdateMetadata.Extent result = new chromeos_update_engine.UpdateMetadata.Extent(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.startBlock_ = startBlock_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.numBlocks_ = numBlocks_;
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof chromeos_update_engine.UpdateMetadata.Extent) {
          return mergeFrom((chromeos_update_engine.UpdateMetadata.Extent)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(chromeos_update_engine.UpdateMetadata.Extent other) {
        if (other == chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance()) return this;
        if (other.hasStartBlock()) {
          setStartBlock(other.getStartBlock());
        }
        if (other.hasNumBlocks()) {
          setNumBlocks(other.getNumBlocks());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        chromeos_update_engine.UpdateMetadata.Extent parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (chromeos_update_engine.UpdateMetadata.Extent) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private long startBlock_ ;
      /**
       * <code>optional uint64 start_block = 1;</code>
       * @return Whether the startBlock field is set.
       */
      @java.lang.Override
      public boolean hasStartBlock() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>optional uint64 start_block = 1;</code>
       * @return The startBlock.
       */
      @java.lang.Override
      public long getStartBlock() {
        return startBlock_;
      }
      /**
       * <code>optional uint64 start_block = 1;</code>
       * @param value The startBlock to set.
       * @return This builder for chaining.
       */
      public Builder setStartBlock(long value) {
        bitField0_ |= 0x00000001;
        startBlock_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional uint64 start_block = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearStartBlock() {
        bitField0_ = (bitField0_ & ~0x00000001);
        startBlock_ = 0L;
        onChanged();
        return this;
      }

      private long numBlocks_ ;
      /**
       * <code>optional uint64 num_blocks = 2;</code>
       * @return Whether the numBlocks field is set.
       */
      @java.lang.Override
      public boolean hasNumBlocks() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <code>optional uint64 num_blocks = 2;</code>
       * @return The numBlocks.
       */
      @java.lang.Override
      public long getNumBlocks() {
        return numBlocks_;
      }
      /**
       * <code>optional uint64 num_blocks = 2;</code>
       * @param value The numBlocks to set.
       * @return This builder for chaining.
       */
      public Builder setNumBlocks(long value) {
        bitField0_ |= 0x00000002;
        numBlocks_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional uint64 num_blocks = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearNumBlocks() {
        bitField0_ = (bitField0_ & ~0x00000002);
        numBlocks_ = 0L;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:chromeos_update_engine.Extent)
    }

    // @@protoc_insertion_point(class_scope:chromeos_update_engine.Extent)
    private static final chromeos_update_engine.UpdateMetadata.Extent DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new chromeos_update_engine.UpdateMetadata.Extent();
    }

    public static chromeos_update_engine.UpdateMetadata.Extent getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<Extent>
        PARSER = new com.google.protobuf.AbstractParser<Extent>() {
      @java.lang.Override
      public Extent parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new Extent(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<Extent> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Extent> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.Extent getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface SignaturesOrBuilder extends
      // @@protoc_insertion_point(interface_extends:chromeos_update_engine.Signatures)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>repeated .chromeos_update_engine.Signatures.Signature signatures = 1;</code>
     */
    java.util.List<chromeos_update_engine.UpdateMetadata.Signatures.Signature>
        getSignaturesList();
    /**
     * <code>repeated .chromeos_update_engine.Signatures.Signature signatures = 1;</code>
     */
    chromeos_update_engine.UpdateMetadata.Signatures.Signature getSignatures(int index);
    /**
     * <code>repeated .chromeos_update_engine.Signatures.Signature signatures = 1;</code>
     */
    int getSignaturesCount();
    /**
     * <code>repeated .chromeos_update_engine.Signatures.Signature signatures = 1;</code>
     */
    java.util.List<? extends chromeos_update_engine.UpdateMetadata.Signatures.SignatureOrBuilder>
        getSignaturesOrBuilderList();
    /**
     * <code>repeated .chromeos_update_engine.Signatures.Signature signatures = 1;</code>
     */
    chromeos_update_engine.UpdateMetadata.Signatures.SignatureOrBuilder getSignaturesOrBuilder(
        int index);
  }
  /**
   * Protobuf type {@code chromeos_update_engine.Signatures}
   */
  public static final class Signatures extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:chromeos_update_engine.Signatures)
      SignaturesOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use Signatures.newBuilder() to construct.
    private Signatures(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private Signatures() {
      signatures_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new Signatures();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private Signatures(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              if (!((mutable_bitField0_ & 0x00000001) != 0)) {
                signatures_ = new java.util.ArrayList<chromeos_update_engine.UpdateMetadata.Signatures.Signature>();
                mutable_bitField0_ |= 0x00000001;
              }
              signatures_.add(
                  input.readMessage(chromeos_update_engine.UpdateMetadata.Signatures.Signature.PARSER, extensionRegistry));
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) != 0)) {
          signatures_ = java.util.Collections.unmodifiableList(signatures_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_Signatures_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_Signatures_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              chromeos_update_engine.UpdateMetadata.Signatures.class, chromeos_update_engine.UpdateMetadata.Signatures.Builder.class);
    }

    public interface SignatureOrBuilder extends
        // @@protoc_insertion_point(interface_extends:chromeos_update_engine.Signatures.Signature)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <code>optional uint32 version = 1 [deprecated = true];</code>
       * @return Whether the version field is set.
       */
      @java.lang.Deprecated boolean hasVersion();
      /**
       * <code>optional uint32 version = 1 [deprecated = true];</code>
       * @return The version.
       */
      @java.lang.Deprecated int getVersion();

      /**
       * <code>optional bytes data = 2;</code>
       * @return Whether the data field is set.
       */
      boolean hasData();
      /**
       * <code>optional bytes data = 2;</code>
       * @return The data.
       */
      com.google.protobuf.ByteString getData();

      /**
       * <pre>
       * The DER encoded signature size of EC keys is nondeterministic for
       * different input of sha256 hash. However, we need the size of the
       * serialized signatures protobuf string to be fixed before signing;
       * because this size is part of the content to be signed. Therefore, we
       * always pad the signature data to the maximum possible signature size of
       * a given key. And the payload verifier will truncate the signature to
       * its correct size based on the value of |unpadded_signature_size|.
       * </pre>
       *
       * <code>optional fixed32 unpadded_signature_size = 3;</code>
       * @return Whether the unpaddedSignatureSize field is set.
       */
      boolean hasUnpaddedSignatureSize();
      /**
       * <pre>
       * The DER encoded signature size of EC keys is nondeterministic for
       * different input of sha256 hash. However, we need the size of the
       * serialized signatures protobuf string to be fixed before signing;
       * because this size is part of the content to be signed. Therefore, we
       * always pad the signature data to the maximum possible signature size of
       * a given key. And the payload verifier will truncate the signature to
       * its correct size based on the value of |unpadded_signature_size|.
       * </pre>
       *
       * <code>optional fixed32 unpadded_signature_size = 3;</code>
       * @return The unpaddedSignatureSize.
       */
      int getUnpaddedSignatureSize();
    }
    /**
     * Protobuf type {@code chromeos_update_engine.Signatures.Signature}
     */
    public static final class Signature extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:chromeos_update_engine.Signatures.Signature)
        SignatureOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use Signature.newBuilder() to construct.
      private Signature(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private Signature() {
        data_ = com.google.protobuf.ByteString.EMPTY;
      }

      @java.lang.Override
      @SuppressWarnings({"unused"})
      protected java.lang.Object newInstance(
          UnusedPrivateParameter unused) {
        return new Signature();
      }

      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      private Signature(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        this();
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        int mutable_bitField0_ = 0;
        com.google.protobuf.UnknownFieldSet.Builder unknownFields =
            com.google.protobuf.UnknownFieldSet.newBuilder();
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                bitField0_ |= 0x00000001;
                version_ = input.readUInt32();
                break;
              }
              case 18: {
                bitField0_ |= 0x00000002;
                data_ = input.readBytes();
                break;
              }
              case 29: {
                bitField0_ |= 0x00000004;
                unpaddedSignatureSize_ = input.readFixed32();
                break;
              }
              default: {
                if (!parseUnknownField(
                    input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(this);
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(
              e).setUnfinishedMessage(this);
        } finally {
          this.unknownFields = unknownFields.build();
          makeExtensionsImmutable();
        }
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_Signatures_Signature_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_Signatures_Signature_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                chromeos_update_engine.UpdateMetadata.Signatures.Signature.class, chromeos_update_engine.UpdateMetadata.Signatures.Signature.Builder.class);
      }

      private int bitField0_;
      public static final int VERSION_FIELD_NUMBER = 1;
      private int version_;
      /**
       * <code>optional uint32 version = 1 [deprecated = true];</code>
       * @return Whether the version field is set.
       */
      @java.lang.Override
      @java.lang.Deprecated public boolean hasVersion() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>optional uint32 version = 1 [deprecated = true];</code>
       * @return The version.
       */
      @java.lang.Override
      @java.lang.Deprecated public int getVersion() {
        return version_;
      }

      public static final int DATA_FIELD_NUMBER = 2;
      private com.google.protobuf.ByteString data_;
      /**
       * <code>optional bytes data = 2;</code>
       * @return Whether the data field is set.
       */
      @java.lang.Override
      public boolean hasData() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <code>optional bytes data = 2;</code>
       * @return The data.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getData() {
        return data_;
      }

      public static final int UNPADDED_SIGNATURE_SIZE_FIELD_NUMBER = 3;
      private int unpaddedSignatureSize_;
      /**
       * <pre>
       * The DER encoded signature size of EC keys is nondeterministic for
       * different input of sha256 hash. However, we need the size of the
       * serialized signatures protobuf string to be fixed before signing;
       * because this size is part of the content to be signed. Therefore, we
       * always pad the signature data to the maximum possible signature size of
       * a given key. And the payload verifier will truncate the signature to
       * its correct size based on the value of |unpadded_signature_size|.
       * </pre>
       *
       * <code>optional fixed32 unpadded_signature_size = 3;</code>
       * @return Whether the unpaddedSignatureSize field is set.
       */
      @java.lang.Override
      public boolean hasUnpaddedSignatureSize() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * The DER encoded signature size of EC keys is nondeterministic for
       * different input of sha256 hash. However, we need the size of the
       * serialized signatures protobuf string to be fixed before signing;
       * because this size is part of the content to be signed. Therefore, we
       * always pad the signature data to the maximum possible signature size of
       * a given key. And the payload verifier will truncate the signature to
       * its correct size based on the value of |unpadded_signature_size|.
       * </pre>
       *
       * <code>optional fixed32 unpadded_signature_size = 3;</code>
       * @return The unpaddedSignatureSize.
       */
      @java.lang.Override
      public int getUnpaddedSignatureSize() {
        return unpaddedSignatureSize_;
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (((bitField0_ & 0x00000001) != 0)) {
          output.writeUInt32(1, version_);
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          output.writeBytes(2, data_);
        }
        if (((bitField0_ & 0x00000004) != 0)) {
          output.writeFixed32(3, unpaddedSignatureSize_);
        }
        unknownFields.writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (((bitField0_ & 0x00000001) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(1, version_);
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeBytesSize(2, data_);
        }
        if (((bitField0_ & 0x00000004) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeFixed32Size(3, unpaddedSignatureSize_);
        }
        size += unknownFields.getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof chromeos_update_engine.UpdateMetadata.Signatures.Signature)) {
          return super.equals(obj);
        }
        chromeos_update_engine.UpdateMetadata.Signatures.Signature other = (chromeos_update_engine.UpdateMetadata.Signatures.Signature) obj;

        if (hasVersion() != other.hasVersion()) return false;
        if (hasVersion()) {
          if (getVersion()
              != other.getVersion()) return false;
        }
        if (hasData() != other.hasData()) return false;
        if (hasData()) {
          if (!getData()
              .equals(other.getData())) return false;
        }
        if (hasUnpaddedSignatureSize() != other.hasUnpaddedSignatureSize()) return false;
        if (hasUnpaddedSignatureSize()) {
          if (getUnpaddedSignatureSize()
              != other.getUnpaddedSignatureSize()) return false;
        }
        if (!unknownFields.equals(other.unknownFields)) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        if (hasVersion()) {
          hash = (37 * hash) + VERSION_FIELD_NUMBER;
          hash = (53 * hash) + getVersion();
        }
        if (hasData()) {
          hash = (37 * hash) + DATA_FIELD_NUMBER;
          hash = (53 * hash) + getData().hashCode();
        }
        if (hasUnpaddedSignatureSize()) {
          hash = (37 * hash) + UNPADDED_SIGNATURE_SIZE_FIELD_NUMBER;
          hash = (53 * hash) + getUnpaddedSignatureSize();
        }
        hash = (29 * hash) + unknownFields.hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static chromeos_update_engine.UpdateMetadata.Signatures.Signature parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static chromeos_update_engine.UpdateMetadata.Signatures.Signature parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static chromeos_update_engine.UpdateMetadata.Signatures.Signature parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static chromeos_update_engine.UpdateMetadata.Signatures.Signature parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static chromeos_update_engine.UpdateMetadata.Signatures.Signature parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static chromeos_update_engine.UpdateMetadata.Signatures.Signature parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static chromeos_update_engine.UpdateMetadata.Signatures.Signature parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static chromeos_update_engine.UpdateMetadata.Signatures.Signature parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static chromeos_update_engine.UpdateMetadata.Signatures.Signature parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static chromeos_update_engine.UpdateMetadata.Signatures.Signature parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static chromeos_update_engine.UpdateMetadata.Signatures.Signature parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static chromeos_update_engine.UpdateMetadata.Signatures.Signature parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(chromeos_update_engine.UpdateMetadata.Signatures.Signature prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * Protobuf type {@code chromeos_update_engine.Signatures.Signature}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:chromeos_update_engine.Signatures.Signature)
          chromeos_update_engine.UpdateMetadata.Signatures.SignatureOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_Signatures_Signature_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_Signatures_Signature_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  chromeos_update_engine.UpdateMetadata.Signatures.Signature.class, chromeos_update_engine.UpdateMetadata.Signatures.Signature.Builder.class);
        }

        // Construct using chromeos_update_engine.UpdateMetadata.Signatures.Signature.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (com.google.protobuf.GeneratedMessageV3
                  .alwaysUseFieldBuilders) {
          }
        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          version_ = 0;
          bitField0_ = (bitField0_ & ~0x00000001);
          data_ = com.google.protobuf.ByteString.EMPTY;
          bitField0_ = (bitField0_ & ~0x00000002);
          unpaddedSignatureSize_ = 0;
          bitField0_ = (bitField0_ & ~0x00000004);
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_Signatures_Signature_descriptor;
        }

        @java.lang.Override
        public chromeos_update_engine.UpdateMetadata.Signatures.Signature getDefaultInstanceForType() {
          return chromeos_update_engine.UpdateMetadata.Signatures.Signature.getDefaultInstance();
        }

        @java.lang.Override
        public chromeos_update_engine.UpdateMetadata.Signatures.Signature build() {
          chromeos_update_engine.UpdateMetadata.Signatures.Signature result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public chromeos_update_engine.UpdateMetadata.Signatures.Signature buildPartial() {
          chromeos_update_engine.UpdateMetadata.Signatures.Signature result = new chromeos_update_engine.UpdateMetadata.Signatures.Signature(this);
          int from_bitField0_ = bitField0_;
          int to_bitField0_ = 0;
          if (((from_bitField0_ & 0x00000001) != 0)) {
            result.version_ = version_;
            to_bitField0_ |= 0x00000001;
          }
          if (((from_bitField0_ & 0x00000002) != 0)) {
            to_bitField0_ |= 0x00000002;
          }
          result.data_ = data_;
          if (((from_bitField0_ & 0x00000004) != 0)) {
            result.unpaddedSignatureSize_ = unpaddedSignatureSize_;
            to_bitField0_ |= 0x00000004;
          }
          result.bitField0_ = to_bitField0_;
          onBuilt();
          return result;
        }

        @java.lang.Override
        public Builder clone() {
          return super.clone();
        }
        @java.lang.Override
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.setField(field, value);
        }
        @java.lang.Override
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return super.clearField(field);
        }
        @java.lang.Override
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return super.clearOneof(oneof);
        }
        @java.lang.Override
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return super.setRepeatedField(field, index, value);
        }
        @java.lang.Override
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.addRepeatedField(field, value);
        }
        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof chromeos_update_engine.UpdateMetadata.Signatures.Signature) {
            return mergeFrom((chromeos_update_engine.UpdateMetadata.Signatures.Signature)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(chromeos_update_engine.UpdateMetadata.Signatures.Signature other) {
          if (other == chromeos_update_engine.UpdateMetadata.Signatures.Signature.getDefaultInstance()) return this;
          if (other.hasVersion()) {
            setVersion(other.getVersion());
          }
          if (other.hasData()) {
            setData(other.getData());
          }
          if (other.hasUnpaddedSignatureSize()) {
            setUnpaddedSignatureSize(other.getUnpaddedSignatureSize());
          }
          this.mergeUnknownFields(other.unknownFields);
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          chromeos_update_engine.UpdateMetadata.Signatures.Signature parsedMessage = null;
          try {
            parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            parsedMessage = (chromeos_update_engine.UpdateMetadata.Signatures.Signature) e.getUnfinishedMessage();
            throw e.unwrapIOException();
          } finally {
            if (parsedMessage != null) {
              mergeFrom(parsedMessage);
            }
          }
          return this;
        }
        private int bitField0_;

        private int version_ ;
        /**
         * <code>optional uint32 version = 1 [deprecated = true];</code>
         * @return Whether the version field is set.
         */
        @java.lang.Override
        @java.lang.Deprecated public boolean hasVersion() {
          return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <code>optional uint32 version = 1 [deprecated = true];</code>
         * @return The version.
         */
        @java.lang.Override
        @java.lang.Deprecated public int getVersion() {
          return version_;
        }
        /**
         * <code>optional uint32 version = 1 [deprecated = true];</code>
         * @param value The version to set.
         * @return This builder for chaining.
         */
        @java.lang.Deprecated public Builder setVersion(int value) {
          bitField0_ |= 0x00000001;
          version_ = value;
          onChanged();
          return this;
        }
        /**
         * <code>optional uint32 version = 1 [deprecated = true];</code>
         * @return This builder for chaining.
         */
        @java.lang.Deprecated public Builder clearVersion() {
          bitField0_ = (bitField0_ & ~0x00000001);
          version_ = 0;
          onChanged();
          return this;
        }

        private com.google.protobuf.ByteString data_ = com.google.protobuf.ByteString.EMPTY;
        /**
         * <code>optional bytes data = 2;</code>
         * @return Whether the data field is set.
         */
        @java.lang.Override
        public boolean hasData() {
          return ((bitField0_ & 0x00000002) != 0);
        }
        /**
         * <code>optional bytes data = 2;</code>
         * @return The data.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString getData() {
          return data_;
        }
        /**
         * <code>optional bytes data = 2;</code>
         * @param value The data to set.
         * @return This builder for chaining.
         */
        public Builder setData(com.google.protobuf.ByteString value) {
          if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
          data_ = value;
          onChanged();
          return this;
        }
        /**
         * <code>optional bytes data = 2;</code>
         * @return This builder for chaining.
         */
        public Builder clearData() {
          bitField0_ = (bitField0_ & ~0x00000002);
          data_ = getDefaultInstance().getData();
          onChanged();
          return this;
        }

        private int unpaddedSignatureSize_ ;
        /**
         * <pre>
         * The DER encoded signature size of EC keys is nondeterministic for
         * different input of sha256 hash. However, we need the size of the
         * serialized signatures protobuf string to be fixed before signing;
         * because this size is part of the content to be signed. Therefore, we
         * always pad the signature data to the maximum possible signature size of
         * a given key. And the payload verifier will truncate the signature to
         * its correct size based on the value of |unpadded_signature_size|.
         * </pre>
         *
         * <code>optional fixed32 unpadded_signature_size = 3;</code>
         * @return Whether the unpaddedSignatureSize field is set.
         */
        @java.lang.Override
        public boolean hasUnpaddedSignatureSize() {
          return ((bitField0_ & 0x00000004) != 0);
        }
        /**
         * <pre>
         * The DER encoded signature size of EC keys is nondeterministic for
         * different input of sha256 hash. However, we need the size of the
         * serialized signatures protobuf string to be fixed before signing;
         * because this size is part of the content to be signed. Therefore, we
         * always pad the signature data to the maximum possible signature size of
         * a given key. And the payload verifier will truncate the signature to
         * its correct size based on the value of |unpadded_signature_size|.
         * </pre>
         *
         * <code>optional fixed32 unpadded_signature_size = 3;</code>
         * @return The unpaddedSignatureSize.
         */
        @java.lang.Override
        public int getUnpaddedSignatureSize() {
          return unpaddedSignatureSize_;
        }
        /**
         * <pre>
         * The DER encoded signature size of EC keys is nondeterministic for
         * different input of sha256 hash. However, we need the size of the
         * serialized signatures protobuf string to be fixed before signing;
         * because this size is part of the content to be signed. Therefore, we
         * always pad the signature data to the maximum possible signature size of
         * a given key. And the payload verifier will truncate the signature to
         * its correct size based on the value of |unpadded_signature_size|.
         * </pre>
         *
         * <code>optional fixed32 unpadded_signature_size = 3;</code>
         * @param value The unpaddedSignatureSize to set.
         * @return This builder for chaining.
         */
        public Builder setUnpaddedSignatureSize(int value) {
          bitField0_ |= 0x00000004;
          unpaddedSignatureSize_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The DER encoded signature size of EC keys is nondeterministic for
         * different input of sha256 hash. However, we need the size of the
         * serialized signatures protobuf string to be fixed before signing;
         * because this size is part of the content to be signed. Therefore, we
         * always pad the signature data to the maximum possible signature size of
         * a given key. And the payload verifier will truncate the signature to
         * its correct size based on the value of |unpadded_signature_size|.
         * </pre>
         *
         * <code>optional fixed32 unpadded_signature_size = 3;</code>
         * @return This builder for chaining.
         */
        public Builder clearUnpaddedSignatureSize() {
          bitField0_ = (bitField0_ & ~0x00000004);
          unpaddedSignatureSize_ = 0;
          onChanged();
          return this;
        }
        @java.lang.Override
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFields(unknownFields);
        }

        @java.lang.Override
        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:chromeos_update_engine.Signatures.Signature)
      }

      // @@protoc_insertion_point(class_scope:chromeos_update_engine.Signatures.Signature)
      private static final chromeos_update_engine.UpdateMetadata.Signatures.Signature DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new chromeos_update_engine.UpdateMetadata.Signatures.Signature();
      }

      public static chromeos_update_engine.UpdateMetadata.Signatures.Signature getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      @java.lang.Deprecated public static final com.google.protobuf.Parser<Signature>
          PARSER = new com.google.protobuf.AbstractParser<Signature>() {
        @java.lang.Override
        public Signature parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return new Signature(input, extensionRegistry);
        }
      };

      public static com.google.protobuf.Parser<Signature> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<Signature> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.Signatures.Signature getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    public static final int SIGNATURES_FIELD_NUMBER = 1;
    private java.util.List<chromeos_update_engine.UpdateMetadata.Signatures.Signature> signatures_;
    /**
     * <code>repeated .chromeos_update_engine.Signatures.Signature signatures = 1;</code>
     */
    @java.lang.Override
    public java.util.List<chromeos_update_engine.UpdateMetadata.Signatures.Signature> getSignaturesList() {
      return signatures_;
    }
    /**
     * <code>repeated .chromeos_update_engine.Signatures.Signature signatures = 1;</code>
     */
    @java.lang.Override
    public java.util.List<? extends chromeos_update_engine.UpdateMetadata.Signatures.SignatureOrBuilder>
        getSignaturesOrBuilderList() {
      return signatures_;
    }
    /**
     * <code>repeated .chromeos_update_engine.Signatures.Signature signatures = 1;</code>
     */
    @java.lang.Override
    public int getSignaturesCount() {
      return signatures_.size();
    }
    /**
     * <code>repeated .chromeos_update_engine.Signatures.Signature signatures = 1;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.Signatures.Signature getSignatures(int index) {
      return signatures_.get(index);
    }
    /**
     * <code>repeated .chromeos_update_engine.Signatures.Signature signatures = 1;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.Signatures.SignatureOrBuilder getSignaturesOrBuilder(
        int index) {
      return signatures_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < signatures_.size(); i++) {
        output.writeMessage(1, signatures_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < signatures_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, signatures_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof chromeos_update_engine.UpdateMetadata.Signatures)) {
        return super.equals(obj);
      }
      chromeos_update_engine.UpdateMetadata.Signatures other = (chromeos_update_engine.UpdateMetadata.Signatures) obj;

      if (!getSignaturesList()
          .equals(other.getSignaturesList())) return false;
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getSignaturesCount() > 0) {
        hash = (37 * hash) + SIGNATURES_FIELD_NUMBER;
        hash = (53 * hash) + getSignaturesList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static chromeos_update_engine.UpdateMetadata.Signatures parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.Signatures parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.Signatures parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.Signatures parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.Signatures parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.Signatures parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.Signatures parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.Signatures parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.Signatures parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.Signatures parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.Signatures parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.Signatures parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(chromeos_update_engine.UpdateMetadata.Signatures prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code chromeos_update_engine.Signatures}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:chromeos_update_engine.Signatures)
        chromeos_update_engine.UpdateMetadata.SignaturesOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_Signatures_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_Signatures_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                chromeos_update_engine.UpdateMetadata.Signatures.class, chromeos_update_engine.UpdateMetadata.Signatures.Builder.class);
      }

      // Construct using chromeos_update_engine.UpdateMetadata.Signatures.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getSignaturesFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (signaturesBuilder_ == null) {
          signatures_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
        } else {
          signaturesBuilder_.clear();
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_Signatures_descriptor;
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.Signatures getDefaultInstanceForType() {
        return chromeos_update_engine.UpdateMetadata.Signatures.getDefaultInstance();
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.Signatures build() {
        chromeos_update_engine.UpdateMetadata.Signatures result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.Signatures buildPartial() {
        chromeos_update_engine.UpdateMetadata.Signatures result = new chromeos_update_engine.UpdateMetadata.Signatures(this);
        int from_bitField0_ = bitField0_;
        if (signaturesBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0)) {
            signatures_ = java.util.Collections.unmodifiableList(signatures_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.signatures_ = signatures_;
        } else {
          result.signatures_ = signaturesBuilder_.build();
        }
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof chromeos_update_engine.UpdateMetadata.Signatures) {
          return mergeFrom((chromeos_update_engine.UpdateMetadata.Signatures)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(chromeos_update_engine.UpdateMetadata.Signatures other) {
        if (other == chromeos_update_engine.UpdateMetadata.Signatures.getDefaultInstance()) return this;
        if (signaturesBuilder_ == null) {
          if (!other.signatures_.isEmpty()) {
            if (signatures_.isEmpty()) {
              signatures_ = other.signatures_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureSignaturesIsMutable();
              signatures_.addAll(other.signatures_);
            }
            onChanged();
          }
        } else {
          if (!other.signatures_.isEmpty()) {
            if (signaturesBuilder_.isEmpty()) {
              signaturesBuilder_.dispose();
              signaturesBuilder_ = null;
              signatures_ = other.signatures_;
              bitField0_ = (bitField0_ & ~0x00000001);
              signaturesBuilder_ =
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getSignaturesFieldBuilder() : null;
            } else {
              signaturesBuilder_.addAllMessages(other.signatures_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        chromeos_update_engine.UpdateMetadata.Signatures parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (chromeos_update_engine.UpdateMetadata.Signatures) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.util.List<chromeos_update_engine.UpdateMetadata.Signatures.Signature> signatures_ =
        java.util.Collections.emptyList();
      private void ensureSignaturesIsMutable() {
        if (!((bitField0_ & 0x00000001) != 0)) {
          signatures_ = new java.util.ArrayList<chromeos_update_engine.UpdateMetadata.Signatures.Signature>(signatures_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.Signatures.Signature, chromeos_update_engine.UpdateMetadata.Signatures.Signature.Builder, chromeos_update_engine.UpdateMetadata.Signatures.SignatureOrBuilder> signaturesBuilder_;

      /**
       * <code>repeated .chromeos_update_engine.Signatures.Signature signatures = 1;</code>
       */
      public java.util.List<chromeos_update_engine.UpdateMetadata.Signatures.Signature> getSignaturesList() {
        if (signaturesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(signatures_);
        } else {
          return signaturesBuilder_.getMessageList();
        }
      }
      /**
       * <code>repeated .chromeos_update_engine.Signatures.Signature signatures = 1;</code>
       */
      public int getSignaturesCount() {
        if (signaturesBuilder_ == null) {
          return signatures_.size();
        } else {
          return signaturesBuilder_.getCount();
        }
      }
      /**
       * <code>repeated .chromeos_update_engine.Signatures.Signature signatures = 1;</code>
       */
      public chromeos_update_engine.UpdateMetadata.Signatures.Signature getSignatures(int index) {
        if (signaturesBuilder_ == null) {
          return signatures_.get(index);
        } else {
          return signaturesBuilder_.getMessage(index);
        }
      }
      /**
       * <code>repeated .chromeos_update_engine.Signatures.Signature signatures = 1;</code>
       */
      public Builder setSignatures(
          int index, chromeos_update_engine.UpdateMetadata.Signatures.Signature value) {
        if (signaturesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSignaturesIsMutable();
          signatures_.set(index, value);
          onChanged();
        } else {
          signaturesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .chromeos_update_engine.Signatures.Signature signatures = 1;</code>
       */
      public Builder setSignatures(
          int index, chromeos_update_engine.UpdateMetadata.Signatures.Signature.Builder builderForValue) {
        if (signaturesBuilder_ == null) {
          ensureSignaturesIsMutable();
          signatures_.set(index, builderForValue.build());
          onChanged();
        } else {
          signaturesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .chromeos_update_engine.Signatures.Signature signatures = 1;</code>
       */
      public Builder addSignatures(chromeos_update_engine.UpdateMetadata.Signatures.Signature value) {
        if (signaturesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSignaturesIsMutable();
          signatures_.add(value);
          onChanged();
        } else {
          signaturesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <code>repeated .chromeos_update_engine.Signatures.Signature signatures = 1;</code>
       */
      public Builder addSignatures(
          int index, chromeos_update_engine.UpdateMetadata.Signatures.Signature value) {
        if (signaturesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSignaturesIsMutable();
          signatures_.add(index, value);
          onChanged();
        } else {
          signaturesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .chromeos_update_engine.Signatures.Signature signatures = 1;</code>
       */
      public Builder addSignatures(
          chromeos_update_engine.UpdateMetadata.Signatures.Signature.Builder builderForValue) {
        if (signaturesBuilder_ == null) {
          ensureSignaturesIsMutable();
          signatures_.add(builderForValue.build());
          onChanged();
        } else {
          signaturesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .chromeos_update_engine.Signatures.Signature signatures = 1;</code>
       */
      public Builder addSignatures(
          int index, chromeos_update_engine.UpdateMetadata.Signatures.Signature.Builder builderForValue) {
        if (signaturesBuilder_ == null) {
          ensureSignaturesIsMutable();
          signatures_.add(index, builderForValue.build());
          onChanged();
        } else {
          signaturesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .chromeos_update_engine.Signatures.Signature signatures = 1;</code>
       */
      public Builder addAllSignatures(
          java.lang.Iterable<? extends chromeos_update_engine.UpdateMetadata.Signatures.Signature> values) {
        if (signaturesBuilder_ == null) {
          ensureSignaturesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, signatures_);
          onChanged();
        } else {
          signaturesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <code>repeated .chromeos_update_engine.Signatures.Signature signatures = 1;</code>
       */
      public Builder clearSignatures() {
        if (signaturesBuilder_ == null) {
          signatures_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          signaturesBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>repeated .chromeos_update_engine.Signatures.Signature signatures = 1;</code>
       */
      public Builder removeSignatures(int index) {
        if (signaturesBuilder_ == null) {
          ensureSignaturesIsMutable();
          signatures_.remove(index);
          onChanged();
        } else {
          signaturesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <code>repeated .chromeos_update_engine.Signatures.Signature signatures = 1;</code>
       */
      public chromeos_update_engine.UpdateMetadata.Signatures.Signature.Builder getSignaturesBuilder(
          int index) {
        return getSignaturesFieldBuilder().getBuilder(index);
      }
      /**
       * <code>repeated .chromeos_update_engine.Signatures.Signature signatures = 1;</code>
       */
      public chromeos_update_engine.UpdateMetadata.Signatures.SignatureOrBuilder getSignaturesOrBuilder(
          int index) {
        if (signaturesBuilder_ == null) {
          return signatures_.get(index);  } else {
          return signaturesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <code>repeated .chromeos_update_engine.Signatures.Signature signatures = 1;</code>
       */
      public java.util.List<? extends chromeos_update_engine.UpdateMetadata.Signatures.SignatureOrBuilder>
           getSignaturesOrBuilderList() {
        if (signaturesBuilder_ != null) {
          return signaturesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(signatures_);
        }
      }
      /**
       * <code>repeated .chromeos_update_engine.Signatures.Signature signatures = 1;</code>
       */
      public chromeos_update_engine.UpdateMetadata.Signatures.Signature.Builder addSignaturesBuilder() {
        return getSignaturesFieldBuilder().addBuilder(
            chromeos_update_engine.UpdateMetadata.Signatures.Signature.getDefaultInstance());
      }
      /**
       * <code>repeated .chromeos_update_engine.Signatures.Signature signatures = 1;</code>
       */
      public chromeos_update_engine.UpdateMetadata.Signatures.Signature.Builder addSignaturesBuilder(
          int index) {
        return getSignaturesFieldBuilder().addBuilder(
            index, chromeos_update_engine.UpdateMetadata.Signatures.Signature.getDefaultInstance());
      }
      /**
       * <code>repeated .chromeos_update_engine.Signatures.Signature signatures = 1;</code>
       */
      public java.util.List<chromeos_update_engine.UpdateMetadata.Signatures.Signature.Builder>
           getSignaturesBuilderList() {
        return getSignaturesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.Signatures.Signature, chromeos_update_engine.UpdateMetadata.Signatures.Signature.Builder, chromeos_update_engine.UpdateMetadata.Signatures.SignatureOrBuilder>
          getSignaturesFieldBuilder() {
        if (signaturesBuilder_ == null) {
          signaturesBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              chromeos_update_engine.UpdateMetadata.Signatures.Signature, chromeos_update_engine.UpdateMetadata.Signatures.Signature.Builder, chromeos_update_engine.UpdateMetadata.Signatures.SignatureOrBuilder>(
                  signatures_,
                  ((bitField0_ & 0x00000001) != 0),
                  getParentForChildren(),
                  isClean());
          signatures_ = null;
        }
        return signaturesBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:chromeos_update_engine.Signatures)
    }

    // @@protoc_insertion_point(class_scope:chromeos_update_engine.Signatures)
    private static final chromeos_update_engine.UpdateMetadata.Signatures DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new chromeos_update_engine.UpdateMetadata.Signatures();
    }

    public static chromeos_update_engine.UpdateMetadata.Signatures getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<Signatures>
        PARSER = new com.google.protobuf.AbstractParser<Signatures>() {
      @java.lang.Override
      public Signatures parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new Signatures(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<Signatures> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Signatures> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.Signatures getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface PartitionInfoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:chromeos_update_engine.PartitionInfo)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>optional uint64 size = 1;</code>
     * @return Whether the size field is set.
     */
    boolean hasSize();
    /**
     * <code>optional uint64 size = 1;</code>
     * @return The size.
     */
    long getSize();

    /**
     * <code>optional bytes hash = 2;</code>
     * @return Whether the hash field is set.
     */
    boolean hasHash();
    /**
     * <code>optional bytes hash = 2;</code>
     * @return The hash.
     */
    com.google.protobuf.ByteString getHash();
  }
  /**
   * Protobuf type {@code chromeos_update_engine.PartitionInfo}
   */
  public static final class PartitionInfo extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:chromeos_update_engine.PartitionInfo)
      PartitionInfoOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use PartitionInfo.newBuilder() to construct.
    private PartitionInfo(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private PartitionInfo() {
      hash_ = com.google.protobuf.ByteString.EMPTY;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new PartitionInfo();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private PartitionInfo(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 8: {
              bitField0_ |= 0x00000001;
              size_ = input.readUInt64();
              break;
            }
            case 18: {
              bitField0_ |= 0x00000002;
              hash_ = input.readBytes();
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_PartitionInfo_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_PartitionInfo_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              chromeos_update_engine.UpdateMetadata.PartitionInfo.class, chromeos_update_engine.UpdateMetadata.PartitionInfo.Builder.class);
    }

    private int bitField0_;
    public static final int SIZE_FIELD_NUMBER = 1;
    private long size_;
    /**
     * <code>optional uint64 size = 1;</code>
     * @return Whether the size field is set.
     */
    @java.lang.Override
    public boolean hasSize() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>optional uint64 size = 1;</code>
     * @return The size.
     */
    @java.lang.Override
    public long getSize() {
      return size_;
    }

    public static final int HASH_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString hash_;
    /**
     * <code>optional bytes hash = 2;</code>
     * @return Whether the hash field is set.
     */
    @java.lang.Override
    public boolean hasHash() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>optional bytes hash = 2;</code>
     * @return The hash.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getHash() {
      return hash_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeUInt64(1, size_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeBytes(2, hash_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(1, size_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(2, hash_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof chromeos_update_engine.UpdateMetadata.PartitionInfo)) {
        return super.equals(obj);
      }
      chromeos_update_engine.UpdateMetadata.PartitionInfo other = (chromeos_update_engine.UpdateMetadata.PartitionInfo) obj;

      if (hasSize() != other.hasSize()) return false;
      if (hasSize()) {
        if (getSize()
            != other.getSize()) return false;
      }
      if (hasHash() != other.hasHash()) return false;
      if (hasHash()) {
        if (!getHash()
            .equals(other.getHash())) return false;
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasSize()) {
        hash = (37 * hash) + SIZE_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getSize());
      }
      if (hasHash()) {
        hash = (37 * hash) + HASH_FIELD_NUMBER;
        hash = (53 * hash) + getHash().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static chromeos_update_engine.UpdateMetadata.PartitionInfo parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.PartitionInfo parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.PartitionInfo parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.PartitionInfo parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.PartitionInfo parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.PartitionInfo parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.PartitionInfo parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.PartitionInfo parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.PartitionInfo parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.PartitionInfo parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.PartitionInfo parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.PartitionInfo parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(chromeos_update_engine.UpdateMetadata.PartitionInfo prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code chromeos_update_engine.PartitionInfo}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:chromeos_update_engine.PartitionInfo)
        chromeos_update_engine.UpdateMetadata.PartitionInfoOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_PartitionInfo_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_PartitionInfo_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                chromeos_update_engine.UpdateMetadata.PartitionInfo.class, chromeos_update_engine.UpdateMetadata.PartitionInfo.Builder.class);
      }

      // Construct using chromeos_update_engine.UpdateMetadata.PartitionInfo.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        size_ = 0L;
        bitField0_ = (bitField0_ & ~0x00000001);
        hash_ = com.google.protobuf.ByteString.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_PartitionInfo_descriptor;
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.PartitionInfo getDefaultInstanceForType() {
        return chromeos_update_engine.UpdateMetadata.PartitionInfo.getDefaultInstance();
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.PartitionInfo build() {
        chromeos_update_engine.UpdateMetadata.PartitionInfo result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.PartitionInfo buildPartial() {
        chromeos_update_engine.UpdateMetadata.PartitionInfo result = new chromeos_update_engine.UpdateMetadata.PartitionInfo(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.size_ = size_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          to_bitField0_ |= 0x00000002;
        }
        result.hash_ = hash_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof chromeos_update_engine.UpdateMetadata.PartitionInfo) {
          return mergeFrom((chromeos_update_engine.UpdateMetadata.PartitionInfo)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(chromeos_update_engine.UpdateMetadata.PartitionInfo other) {
        if (other == chromeos_update_engine.UpdateMetadata.PartitionInfo.getDefaultInstance()) return this;
        if (other.hasSize()) {
          setSize(other.getSize());
        }
        if (other.hasHash()) {
          setHash(other.getHash());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        chromeos_update_engine.UpdateMetadata.PartitionInfo parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (chromeos_update_engine.UpdateMetadata.PartitionInfo) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private long size_ ;
      /**
       * <code>optional uint64 size = 1;</code>
       * @return Whether the size field is set.
       */
      @java.lang.Override
      public boolean hasSize() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>optional uint64 size = 1;</code>
       * @return The size.
       */
      @java.lang.Override
      public long getSize() {
        return size_;
      }
      /**
       * <code>optional uint64 size = 1;</code>
       * @param value The size to set.
       * @return This builder for chaining.
       */
      public Builder setSize(long value) {
        bitField0_ |= 0x00000001;
        size_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional uint64 size = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearSize() {
        bitField0_ = (bitField0_ & ~0x00000001);
        size_ = 0L;
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString hash_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <code>optional bytes hash = 2;</code>
       * @return Whether the hash field is set.
       */
      @java.lang.Override
      public boolean hasHash() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <code>optional bytes hash = 2;</code>
       * @return The hash.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getHash() {
        return hash_;
      }
      /**
       * <code>optional bytes hash = 2;</code>
       * @param value The hash to set.
       * @return This builder for chaining.
       */
      public Builder setHash(com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        hash_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bytes hash = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearHash() {
        bitField0_ = (bitField0_ & ~0x00000002);
        hash_ = getDefaultInstance().getHash();
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:chromeos_update_engine.PartitionInfo)
    }

    // @@protoc_insertion_point(class_scope:chromeos_update_engine.PartitionInfo)
    private static final chromeos_update_engine.UpdateMetadata.PartitionInfo DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new chromeos_update_engine.UpdateMetadata.PartitionInfo();
    }

    public static chromeos_update_engine.UpdateMetadata.PartitionInfo getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<PartitionInfo>
        PARSER = new com.google.protobuf.AbstractParser<PartitionInfo>() {
      @java.lang.Override
      public PartitionInfo parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new PartitionInfo(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<PartitionInfo> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<PartitionInfo> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.PartitionInfo getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ImageInfoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:chromeos_update_engine.ImageInfo)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>optional string board = 1;</code>
     * @return Whether the board field is set.
     */
    boolean hasBoard();
    /**
     * <code>optional string board = 1;</code>
     * @return The board.
     */
    java.lang.String getBoard();
    /**
     * <code>optional string board = 1;</code>
     * @return The bytes for board.
     */
    com.google.protobuf.ByteString
        getBoardBytes();

    /**
     * <code>optional string key = 2;</code>
     * @return Whether the key field is set.
     */
    boolean hasKey();
    /**
     * <code>optional string key = 2;</code>
     * @return The key.
     */
    java.lang.String getKey();
    /**
     * <code>optional string key = 2;</code>
     * @return The bytes for key.
     */
    com.google.protobuf.ByteString
        getKeyBytes();

    /**
     * <code>optional string channel = 3;</code>
     * @return Whether the channel field is set.
     */
    boolean hasChannel();
    /**
     * <code>optional string channel = 3;</code>
     * @return The channel.
     */
    java.lang.String getChannel();
    /**
     * <code>optional string channel = 3;</code>
     * @return The bytes for channel.
     */
    com.google.protobuf.ByteString
        getChannelBytes();

    /**
     * <code>optional string version = 4;</code>
     * @return Whether the version field is set.
     */
    boolean hasVersion();
    /**
     * <code>optional string version = 4;</code>
     * @return The version.
     */
    java.lang.String getVersion();
    /**
     * <code>optional string version = 4;</code>
     * @return The bytes for version.
     */
    com.google.protobuf.ByteString
        getVersionBytes();

    /**
     * <pre>
     * If these values aren't present, they should be assumed to match
     * the equivalent value above. They are normally only different for
     * special image types such as nplusone images.
     * </pre>
     *
     * <code>optional string build_channel = 5;</code>
     * @return Whether the buildChannel field is set.
     */
    boolean hasBuildChannel();
    /**
     * <pre>
     * If these values aren't present, they should be assumed to match
     * the equivalent value above. They are normally only different for
     * special image types such as nplusone images.
     * </pre>
     *
     * <code>optional string build_channel = 5;</code>
     * @return The buildChannel.
     */
    java.lang.String getBuildChannel();
    /**
     * <pre>
     * If these values aren't present, they should be assumed to match
     * the equivalent value above. They are normally only different for
     * special image types such as nplusone images.
     * </pre>
     *
     * <code>optional string build_channel = 5;</code>
     * @return The bytes for buildChannel.
     */
    com.google.protobuf.ByteString
        getBuildChannelBytes();

    /**
     * <code>optional string build_version = 6;</code>
     * @return Whether the buildVersion field is set.
     */
    boolean hasBuildVersion();
    /**
     * <code>optional string build_version = 6;</code>
     * @return The buildVersion.
     */
    java.lang.String getBuildVersion();
    /**
     * <code>optional string build_version = 6;</code>
     * @return The bytes for buildVersion.
     */
    com.google.protobuf.ByteString
        getBuildVersionBytes();
  }
  /**
   * <pre>
   * Describe an image we are based on in a human friendly way.
   * Examples:
   *   dev-channel, x86-alex, 1.2.3, mp-v3
   *   nplusone-channel, x86-alex, 1.2.4, mp-v3, dev-channel, 1.2.3
   * All fields will be set, if this message is present.
   * </pre>
   *
   * Protobuf type {@code chromeos_update_engine.ImageInfo}
   */
  public static final class ImageInfo extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:chromeos_update_engine.ImageInfo)
      ImageInfoOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ImageInfo.newBuilder() to construct.
    private ImageInfo(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ImageInfo() {
      board_ = "";
      key_ = "";
      channel_ = "";
      version_ = "";
      buildChannel_ = "";
      buildVersion_ = "";
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new ImageInfo();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ImageInfo(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              board_ = bs;
              break;
            }
            case 18: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000002;
              key_ = bs;
              break;
            }
            case 26: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000004;
              channel_ = bs;
              break;
            }
            case 34: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000008;
              version_ = bs;
              break;
            }
            case 42: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000010;
              buildChannel_ = bs;
              break;
            }
            case 50: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000020;
              buildVersion_ = bs;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_ImageInfo_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_ImageInfo_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              chromeos_update_engine.UpdateMetadata.ImageInfo.class, chromeos_update_engine.UpdateMetadata.ImageInfo.Builder.class);
    }

    private int bitField0_;
    public static final int BOARD_FIELD_NUMBER = 1;
    private volatile java.lang.Object board_;
    /**
     * <code>optional string board = 1;</code>
     * @return Whether the board field is set.
     */
    @java.lang.Override
    public boolean hasBoard() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>optional string board = 1;</code>
     * @return The board.
     */
    @java.lang.Override
    public java.lang.String getBoard() {
      java.lang.Object ref = board_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          board_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string board = 1;</code>
     * @return The bytes for board.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getBoardBytes() {
      java.lang.Object ref = board_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        board_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int KEY_FIELD_NUMBER = 2;
    private volatile java.lang.Object key_;
    /**
     * <code>optional string key = 2;</code>
     * @return Whether the key field is set.
     */
    @java.lang.Override
    public boolean hasKey() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>optional string key = 2;</code>
     * @return The key.
     */
    @java.lang.Override
    public java.lang.String getKey() {
      java.lang.Object ref = key_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          key_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string key = 2;</code>
     * @return The bytes for key.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getKeyBytes() {
      java.lang.Object ref = key_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        key_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int CHANNEL_FIELD_NUMBER = 3;
    private volatile java.lang.Object channel_;
    /**
     * <code>optional string channel = 3;</code>
     * @return Whether the channel field is set.
     */
    @java.lang.Override
    public boolean hasChannel() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <code>optional string channel = 3;</code>
     * @return The channel.
     */
    @java.lang.Override
    public java.lang.String getChannel() {
      java.lang.Object ref = channel_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          channel_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string channel = 3;</code>
     * @return The bytes for channel.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getChannelBytes() {
      java.lang.Object ref = channel_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        channel_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int VERSION_FIELD_NUMBER = 4;
    private volatile java.lang.Object version_;
    /**
     * <code>optional string version = 4;</code>
     * @return Whether the version field is set.
     */
    @java.lang.Override
    public boolean hasVersion() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <code>optional string version = 4;</code>
     * @return The version.
     */
    @java.lang.Override
    public java.lang.String getVersion() {
      java.lang.Object ref = version_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          version_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string version = 4;</code>
     * @return The bytes for version.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getVersionBytes() {
      java.lang.Object ref = version_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        version_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int BUILD_CHANNEL_FIELD_NUMBER = 5;
    private volatile java.lang.Object buildChannel_;
    /**
     * <pre>
     * If these values aren't present, they should be assumed to match
     * the equivalent value above. They are normally only different for
     * special image types such as nplusone images.
     * </pre>
     *
     * <code>optional string build_channel = 5;</code>
     * @return Whether the buildChannel field is set.
     */
    @java.lang.Override
    public boolean hasBuildChannel() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * If these values aren't present, they should be assumed to match
     * the equivalent value above. They are normally only different for
     * special image types such as nplusone images.
     * </pre>
     *
     * <code>optional string build_channel = 5;</code>
     * @return The buildChannel.
     */
    @java.lang.Override
    public java.lang.String getBuildChannel() {
      java.lang.Object ref = buildChannel_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          buildChannel_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * If these values aren't present, they should be assumed to match
     * the equivalent value above. They are normally only different for
     * special image types such as nplusone images.
     * </pre>
     *
     * <code>optional string build_channel = 5;</code>
     * @return The bytes for buildChannel.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getBuildChannelBytes() {
      java.lang.Object ref = buildChannel_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        buildChannel_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int BUILD_VERSION_FIELD_NUMBER = 6;
    private volatile java.lang.Object buildVersion_;
    /**
     * <code>optional string build_version = 6;</code>
     * @return Whether the buildVersion field is set.
     */
    @java.lang.Override
    public boolean hasBuildVersion() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <code>optional string build_version = 6;</code>
     * @return The buildVersion.
     */
    @java.lang.Override
    public java.lang.String getBuildVersion() {
      java.lang.Object ref = buildVersion_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          buildVersion_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string build_version = 6;</code>
     * @return The bytes for buildVersion.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getBuildVersionBytes() {
      java.lang.Object ref = buildVersion_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        buildVersion_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, board_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, key_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, channel_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 4, version_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 5, buildChannel_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 6, buildVersion_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, board_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, key_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, channel_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, version_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(5, buildChannel_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(6, buildVersion_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof chromeos_update_engine.UpdateMetadata.ImageInfo)) {
        return super.equals(obj);
      }
      chromeos_update_engine.UpdateMetadata.ImageInfo other = (chromeos_update_engine.UpdateMetadata.ImageInfo) obj;

      if (hasBoard() != other.hasBoard()) return false;
      if (hasBoard()) {
        if (!getBoard()
            .equals(other.getBoard())) return false;
      }
      if (hasKey() != other.hasKey()) return false;
      if (hasKey()) {
        if (!getKey()
            .equals(other.getKey())) return false;
      }
      if (hasChannel() != other.hasChannel()) return false;
      if (hasChannel()) {
        if (!getChannel()
            .equals(other.getChannel())) return false;
      }
      if (hasVersion() != other.hasVersion()) return false;
      if (hasVersion()) {
        if (!getVersion()
            .equals(other.getVersion())) return false;
      }
      if (hasBuildChannel() != other.hasBuildChannel()) return false;
      if (hasBuildChannel()) {
        if (!getBuildChannel()
            .equals(other.getBuildChannel())) return false;
      }
      if (hasBuildVersion() != other.hasBuildVersion()) return false;
      if (hasBuildVersion()) {
        if (!getBuildVersion()
            .equals(other.getBuildVersion())) return false;
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasBoard()) {
        hash = (37 * hash) + BOARD_FIELD_NUMBER;
        hash = (53 * hash) + getBoard().hashCode();
      }
      if (hasKey()) {
        hash = (37 * hash) + KEY_FIELD_NUMBER;
        hash = (53 * hash) + getKey().hashCode();
      }
      if (hasChannel()) {
        hash = (37 * hash) + CHANNEL_FIELD_NUMBER;
        hash = (53 * hash) + getChannel().hashCode();
      }
      if (hasVersion()) {
        hash = (37 * hash) + VERSION_FIELD_NUMBER;
        hash = (53 * hash) + getVersion().hashCode();
      }
      if (hasBuildChannel()) {
        hash = (37 * hash) + BUILD_CHANNEL_FIELD_NUMBER;
        hash = (53 * hash) + getBuildChannel().hashCode();
      }
      if (hasBuildVersion()) {
        hash = (37 * hash) + BUILD_VERSION_FIELD_NUMBER;
        hash = (53 * hash) + getBuildVersion().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static chromeos_update_engine.UpdateMetadata.ImageInfo parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.ImageInfo parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.ImageInfo parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.ImageInfo parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.ImageInfo parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.ImageInfo parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.ImageInfo parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.ImageInfo parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.ImageInfo parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.ImageInfo parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.ImageInfo parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.ImageInfo parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(chromeos_update_engine.UpdateMetadata.ImageInfo prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Describe an image we are based on in a human friendly way.
     * Examples:
     *   dev-channel, x86-alex, 1.2.3, mp-v3
     *   nplusone-channel, x86-alex, 1.2.4, mp-v3, dev-channel, 1.2.3
     * All fields will be set, if this message is present.
     * </pre>
     *
     * Protobuf type {@code chromeos_update_engine.ImageInfo}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:chromeos_update_engine.ImageInfo)
        chromeos_update_engine.UpdateMetadata.ImageInfoOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_ImageInfo_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_ImageInfo_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                chromeos_update_engine.UpdateMetadata.ImageInfo.class, chromeos_update_engine.UpdateMetadata.ImageInfo.Builder.class);
      }

      // Construct using chromeos_update_engine.UpdateMetadata.ImageInfo.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        board_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        key_ = "";
        bitField0_ = (bitField0_ & ~0x00000002);
        channel_ = "";
        bitField0_ = (bitField0_ & ~0x00000004);
        version_ = "";
        bitField0_ = (bitField0_ & ~0x00000008);
        buildChannel_ = "";
        bitField0_ = (bitField0_ & ~0x00000010);
        buildVersion_ = "";
        bitField0_ = (bitField0_ & ~0x00000020);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_ImageInfo_descriptor;
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.ImageInfo getDefaultInstanceForType() {
        return chromeos_update_engine.UpdateMetadata.ImageInfo.getDefaultInstance();
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.ImageInfo build() {
        chromeos_update_engine.UpdateMetadata.ImageInfo result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.ImageInfo buildPartial() {
        chromeos_update_engine.UpdateMetadata.ImageInfo result = new chromeos_update_engine.UpdateMetadata.ImageInfo(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          to_bitField0_ |= 0x00000001;
        }
        result.board_ = board_;
        if (((from_bitField0_ & 0x00000002) != 0)) {
          to_bitField0_ |= 0x00000002;
        }
        result.key_ = key_;
        if (((from_bitField0_ & 0x00000004) != 0)) {
          to_bitField0_ |= 0x00000004;
        }
        result.channel_ = channel_;
        if (((from_bitField0_ & 0x00000008) != 0)) {
          to_bitField0_ |= 0x00000008;
        }
        result.version_ = version_;
        if (((from_bitField0_ & 0x00000010) != 0)) {
          to_bitField0_ |= 0x00000010;
        }
        result.buildChannel_ = buildChannel_;
        if (((from_bitField0_ & 0x00000020) != 0)) {
          to_bitField0_ |= 0x00000020;
        }
        result.buildVersion_ = buildVersion_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof chromeos_update_engine.UpdateMetadata.ImageInfo) {
          return mergeFrom((chromeos_update_engine.UpdateMetadata.ImageInfo)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(chromeos_update_engine.UpdateMetadata.ImageInfo other) {
        if (other == chromeos_update_engine.UpdateMetadata.ImageInfo.getDefaultInstance()) return this;
        if (other.hasBoard()) {
          bitField0_ |= 0x00000001;
          board_ = other.board_;
          onChanged();
        }
        if (other.hasKey()) {
          bitField0_ |= 0x00000002;
          key_ = other.key_;
          onChanged();
        }
        if (other.hasChannel()) {
          bitField0_ |= 0x00000004;
          channel_ = other.channel_;
          onChanged();
        }
        if (other.hasVersion()) {
          bitField0_ |= 0x00000008;
          version_ = other.version_;
          onChanged();
        }
        if (other.hasBuildChannel()) {
          bitField0_ |= 0x00000010;
          buildChannel_ = other.buildChannel_;
          onChanged();
        }
        if (other.hasBuildVersion()) {
          bitField0_ |= 0x00000020;
          buildVersion_ = other.buildVersion_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        chromeos_update_engine.UpdateMetadata.ImageInfo parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (chromeos_update_engine.UpdateMetadata.ImageInfo) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object board_ = "";
      /**
       * <code>optional string board = 1;</code>
       * @return Whether the board field is set.
       */
      public boolean hasBoard() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>optional string board = 1;</code>
       * @return The board.
       */
      public java.lang.String getBoard() {
        java.lang.Object ref = board_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            board_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string board = 1;</code>
       * @return The bytes for board.
       */
      public com.google.protobuf.ByteString
          getBoardBytes() {
        java.lang.Object ref = board_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          board_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string board = 1;</code>
       * @param value The board to set.
       * @return This builder for chaining.
       */
      public Builder setBoard(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        board_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional string board = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearBoard() {
        bitField0_ = (bitField0_ & ~0x00000001);
        board_ = getDefaultInstance().getBoard();
        onChanged();
        return this;
      }
      /**
       * <code>optional string board = 1;</code>
       * @param value The bytes for board to set.
       * @return This builder for chaining.
       */
      public Builder setBoardBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        board_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object key_ = "";
      /**
       * <code>optional string key = 2;</code>
       * @return Whether the key field is set.
       */
      public boolean hasKey() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <code>optional string key = 2;</code>
       * @return The key.
       */
      public java.lang.String getKey() {
        java.lang.Object ref = key_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            key_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string key = 2;</code>
       * @return The bytes for key.
       */
      public com.google.protobuf.ByteString
          getKeyBytes() {
        java.lang.Object ref = key_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          key_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string key = 2;</code>
       * @param value The key to set.
       * @return This builder for chaining.
       */
      public Builder setKey(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        key_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional string key = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearKey() {
        bitField0_ = (bitField0_ & ~0x00000002);
        key_ = getDefaultInstance().getKey();
        onChanged();
        return this;
      }
      /**
       * <code>optional string key = 2;</code>
       * @param value The bytes for key to set.
       * @return This builder for chaining.
       */
      public Builder setKeyBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        key_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object channel_ = "";
      /**
       * <code>optional string channel = 3;</code>
       * @return Whether the channel field is set.
       */
      public boolean hasChannel() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <code>optional string channel = 3;</code>
       * @return The channel.
       */
      public java.lang.String getChannel() {
        java.lang.Object ref = channel_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            channel_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string channel = 3;</code>
       * @return The bytes for channel.
       */
      public com.google.protobuf.ByteString
          getChannelBytes() {
        java.lang.Object ref = channel_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          channel_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string channel = 3;</code>
       * @param value The channel to set.
       * @return This builder for chaining.
       */
      public Builder setChannel(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000004;
        channel_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional string channel = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearChannel() {
        bitField0_ = (bitField0_ & ~0x00000004);
        channel_ = getDefaultInstance().getChannel();
        onChanged();
        return this;
      }
      /**
       * <code>optional string channel = 3;</code>
       * @param value The bytes for channel to set.
       * @return This builder for chaining.
       */
      public Builder setChannelBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000004;
        channel_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object version_ = "";
      /**
       * <code>optional string version = 4;</code>
       * @return Whether the version field is set.
       */
      public boolean hasVersion() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <code>optional string version = 4;</code>
       * @return The version.
       */
      public java.lang.String getVersion() {
        java.lang.Object ref = version_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            version_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string version = 4;</code>
       * @return The bytes for version.
       */
      public com.google.protobuf.ByteString
          getVersionBytes() {
        java.lang.Object ref = version_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          version_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string version = 4;</code>
       * @param value The version to set.
       * @return This builder for chaining.
       */
      public Builder setVersion(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000008;
        version_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional string version = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearVersion() {
        bitField0_ = (bitField0_ & ~0x00000008);
        version_ = getDefaultInstance().getVersion();
        onChanged();
        return this;
      }
      /**
       * <code>optional string version = 4;</code>
       * @param value The bytes for version to set.
       * @return This builder for chaining.
       */
      public Builder setVersionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000008;
        version_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object buildChannel_ = "";
      /**
       * <pre>
       * If these values aren't present, they should be assumed to match
       * the equivalent value above. They are normally only different for
       * special image types such as nplusone images.
       * </pre>
       *
       * <code>optional string build_channel = 5;</code>
       * @return Whether the buildChannel field is set.
       */
      public boolean hasBuildChannel() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * If these values aren't present, they should be assumed to match
       * the equivalent value above. They are normally only different for
       * special image types such as nplusone images.
       * </pre>
       *
       * <code>optional string build_channel = 5;</code>
       * @return The buildChannel.
       */
      public java.lang.String getBuildChannel() {
        java.lang.Object ref = buildChannel_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            buildChannel_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * If these values aren't present, they should be assumed to match
       * the equivalent value above. They are normally only different for
       * special image types such as nplusone images.
       * </pre>
       *
       * <code>optional string build_channel = 5;</code>
       * @return The bytes for buildChannel.
       */
      public com.google.protobuf.ByteString
          getBuildChannelBytes() {
        java.lang.Object ref = buildChannel_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          buildChannel_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * If these values aren't present, they should be assumed to match
       * the equivalent value above. They are normally only different for
       * special image types such as nplusone images.
       * </pre>
       *
       * <code>optional string build_channel = 5;</code>
       * @param value The buildChannel to set.
       * @return This builder for chaining.
       */
      public Builder setBuildChannel(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000010;
        buildChannel_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If these values aren't present, they should be assumed to match
       * the equivalent value above. They are normally only different for
       * special image types such as nplusone images.
       * </pre>
       *
       * <code>optional string build_channel = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearBuildChannel() {
        bitField0_ = (bitField0_ & ~0x00000010);
        buildChannel_ = getDefaultInstance().getBuildChannel();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If these values aren't present, they should be assumed to match
       * the equivalent value above. They are normally only different for
       * special image types such as nplusone images.
       * </pre>
       *
       * <code>optional string build_channel = 5;</code>
       * @param value The bytes for buildChannel to set.
       * @return This builder for chaining.
       */
      public Builder setBuildChannelBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000010;
        buildChannel_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object buildVersion_ = "";
      /**
       * <code>optional string build_version = 6;</code>
       * @return Whether the buildVersion field is set.
       */
      public boolean hasBuildVersion() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <code>optional string build_version = 6;</code>
       * @return The buildVersion.
       */
      public java.lang.String getBuildVersion() {
        java.lang.Object ref = buildVersion_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            buildVersion_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string build_version = 6;</code>
       * @return The bytes for buildVersion.
       */
      public com.google.protobuf.ByteString
          getBuildVersionBytes() {
        java.lang.Object ref = buildVersion_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          buildVersion_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string build_version = 6;</code>
       * @param value The buildVersion to set.
       * @return This builder for chaining.
       */
      public Builder setBuildVersion(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000020;
        buildVersion_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional string build_version = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearBuildVersion() {
        bitField0_ = (bitField0_ & ~0x00000020);
        buildVersion_ = getDefaultInstance().getBuildVersion();
        onChanged();
        return this;
      }
      /**
       * <code>optional string build_version = 6;</code>
       * @param value The bytes for buildVersion to set.
       * @return This builder for chaining.
       */
      public Builder setBuildVersionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000020;
        buildVersion_ = value;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:chromeos_update_engine.ImageInfo)
    }

    // @@protoc_insertion_point(class_scope:chromeos_update_engine.ImageInfo)
    private static final chromeos_update_engine.UpdateMetadata.ImageInfo DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new chromeos_update_engine.UpdateMetadata.ImageInfo();
    }

    public static chromeos_update_engine.UpdateMetadata.ImageInfo getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<ImageInfo>
        PARSER = new com.google.protobuf.AbstractParser<ImageInfo>() {
      @java.lang.Override
      public ImageInfo parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ImageInfo(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ImageInfo> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ImageInfo> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.ImageInfo getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface InstallOperationOrBuilder extends
      // @@protoc_insertion_point(interface_extends:chromeos_update_engine.InstallOperation)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>required .chromeos_update_engine.InstallOperation.Type type = 1;</code>
     * @return Whether the type field is set.
     */
    boolean hasType();
    /**
     * <code>required .chromeos_update_engine.InstallOperation.Type type = 1;</code>
     * @return The type.
     */
    chromeos_update_engine.UpdateMetadata.InstallOperation.Type getType();

    /**
     * <pre>
     * Only minor version 6 or newer support 64 bits |data_offset| and
     * |data_length|, older client will read them as uint32.
     * The offset into the delta file (after the protobuf)
     * where the data (if any) is stored
     * </pre>
     *
     * <code>optional uint64 data_offset = 2;</code>
     * @return Whether the dataOffset field is set.
     */
    boolean hasDataOffset();
    /**
     * <pre>
     * Only minor version 6 or newer support 64 bits |data_offset| and
     * |data_length|, older client will read them as uint32.
     * The offset into the delta file (after the protobuf)
     * where the data (if any) is stored
     * </pre>
     *
     * <code>optional uint64 data_offset = 2;</code>
     * @return The dataOffset.
     */
    long getDataOffset();

    /**
     * <pre>
     * The length of the data in the delta file
     * </pre>
     *
     * <code>optional uint64 data_length = 3;</code>
     * @return Whether the dataLength field is set.
     */
    boolean hasDataLength();
    /**
     * <pre>
     * The length of the data in the delta file
     * </pre>
     *
     * <code>optional uint64 data_length = 3;</code>
     * @return The dataLength.
     */
    long getDataLength();

    /**
     * <pre>
     * Ordered list of extents that are read from (if any) and written to.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.Extent src_extents = 4;</code>
     */
    java.util.List<chromeos_update_engine.UpdateMetadata.Extent>
        getSrcExtentsList();
    /**
     * <pre>
     * Ordered list of extents that are read from (if any) and written to.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.Extent src_extents = 4;</code>
     */
    chromeos_update_engine.UpdateMetadata.Extent getSrcExtents(int index);
    /**
     * <pre>
     * Ordered list of extents that are read from (if any) and written to.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.Extent src_extents = 4;</code>
     */
    int getSrcExtentsCount();
    /**
     * <pre>
     * Ordered list of extents that are read from (if any) and written to.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.Extent src_extents = 4;</code>
     */
    java.util.List<? extends chromeos_update_engine.UpdateMetadata.ExtentOrBuilder>
        getSrcExtentsOrBuilderList();
    /**
     * <pre>
     * Ordered list of extents that are read from (if any) and written to.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.Extent src_extents = 4;</code>
     */
    chromeos_update_engine.UpdateMetadata.ExtentOrBuilder getSrcExtentsOrBuilder(
        int index);

    /**
     * <pre>
     * Byte length of src, equal to the number of blocks in src_extents *
     * block_size. It is used for BSDIFF and SOURCE_BSDIFF, because we need to
     * pass that external program the number of bytes to read from the blocks we
     * pass it.  This is not used in any other operation.
     * </pre>
     *
     * <code>optional uint64 src_length = 5;</code>
     * @return Whether the srcLength field is set.
     */
    boolean hasSrcLength();
    /**
     * <pre>
     * Byte length of src, equal to the number of blocks in src_extents *
     * block_size. It is used for BSDIFF and SOURCE_BSDIFF, because we need to
     * pass that external program the number of bytes to read from the blocks we
     * pass it.  This is not used in any other operation.
     * </pre>
     *
     * <code>optional uint64 src_length = 5;</code>
     * @return The srcLength.
     */
    long getSrcLength();

    /**
     * <code>repeated .chromeos_update_engine.Extent dst_extents = 6;</code>
     */
    java.util.List<chromeos_update_engine.UpdateMetadata.Extent>
        getDstExtentsList();
    /**
     * <code>repeated .chromeos_update_engine.Extent dst_extents = 6;</code>
     */
    chromeos_update_engine.UpdateMetadata.Extent getDstExtents(int index);
    /**
     * <code>repeated .chromeos_update_engine.Extent dst_extents = 6;</code>
     */
    int getDstExtentsCount();
    /**
     * <code>repeated .chromeos_update_engine.Extent dst_extents = 6;</code>
     */
    java.util.List<? extends chromeos_update_engine.UpdateMetadata.ExtentOrBuilder>
        getDstExtentsOrBuilderList();
    /**
     * <code>repeated .chromeos_update_engine.Extent dst_extents = 6;</code>
     */
    chromeos_update_engine.UpdateMetadata.ExtentOrBuilder getDstExtentsOrBuilder(
        int index);

    /**
     * <pre>
     * Byte length of dst, equal to the number of blocks in dst_extents *
     * block_size. Used for BSDIFF and SOURCE_BSDIFF, but not in any other
     * operation.
     * </pre>
     *
     * <code>optional uint64 dst_length = 7;</code>
     * @return Whether the dstLength field is set.
     */
    boolean hasDstLength();
    /**
     * <pre>
     * Byte length of dst, equal to the number of blocks in dst_extents *
     * block_size. Used for BSDIFF and SOURCE_BSDIFF, but not in any other
     * operation.
     * </pre>
     *
     * <code>optional uint64 dst_length = 7;</code>
     * @return The dstLength.
     */
    long getDstLength();

    /**
     * <pre>
     * Optional SHA 256 hash of the blob associated with this operation.
     * This is used as a primary validation for http-based downloads and
     * as a defense-in-depth validation for https-based downloads. If
     * the operation doesn't refer to any blob, this field will have
     * zero bytes.
     * </pre>
     *
     * <code>optional bytes data_sha256_hash = 8;</code>
     * @return Whether the dataSha256Hash field is set.
     */
    boolean hasDataSha256Hash();
    /**
     * <pre>
     * Optional SHA 256 hash of the blob associated with this operation.
     * This is used as a primary validation for http-based downloads and
     * as a defense-in-depth validation for https-based downloads. If
     * the operation doesn't refer to any blob, this field will have
     * zero bytes.
     * </pre>
     *
     * <code>optional bytes data_sha256_hash = 8;</code>
     * @return The dataSha256Hash.
     */
    com.google.protobuf.ByteString getDataSha256Hash();

    /**
     * <pre>
     * Indicates the SHA 256 hash of the source data referenced in src_extents at
     * the time of applying the operation. If present, the update_engine daemon
     * MUST read and verify the source data before applying the operation.
     * </pre>
     *
     * <code>optional bytes src_sha256_hash = 9;</code>
     * @return Whether the srcSha256Hash field is set.
     */
    boolean hasSrcSha256Hash();
    /**
     * <pre>
     * Indicates the SHA 256 hash of the source data referenced in src_extents at
     * the time of applying the operation. If present, the update_engine daemon
     * MUST read and verify the source data before applying the operation.
     * </pre>
     *
     * <code>optional bytes src_sha256_hash = 9;</code>
     * @return The srcSha256Hash.
     */
    com.google.protobuf.ByteString getSrcSha256Hash();
  }
  /**
   * Protobuf type {@code chromeos_update_engine.InstallOperation}
   */
  public static final class InstallOperation extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:chromeos_update_engine.InstallOperation)
      InstallOperationOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use InstallOperation.newBuilder() to construct.
    private InstallOperation(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private InstallOperation() {
      type_ = 0;
      srcExtents_ = java.util.Collections.emptyList();
      dstExtents_ = java.util.Collections.emptyList();
      dataSha256Hash_ = com.google.protobuf.ByteString.EMPTY;
      srcSha256Hash_ = com.google.protobuf.ByteString.EMPTY;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new InstallOperation();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private InstallOperation(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 8: {
              int rawValue = input.readEnum();
                @SuppressWarnings("deprecation")
              chromeos_update_engine.UpdateMetadata.InstallOperation.Type value = chromeos_update_engine.UpdateMetadata.InstallOperation.Type.valueOf(rawValue);
              if (value == null) {
                unknownFields.mergeVarintField(1, rawValue);
              } else {
                bitField0_ |= 0x00000001;
                type_ = rawValue;
              }
              break;
            }
            case 16: {
              bitField0_ |= 0x00000002;
              dataOffset_ = input.readUInt64();
              break;
            }
            case 24: {
              bitField0_ |= 0x00000004;
              dataLength_ = input.readUInt64();
              break;
            }
            case 34: {
              if (!((mutable_bitField0_ & 0x00000008) != 0)) {
                srcExtents_ = new java.util.ArrayList<chromeos_update_engine.UpdateMetadata.Extent>();
                mutable_bitField0_ |= 0x00000008;
              }
              srcExtents_.add(
                  input.readMessage(chromeos_update_engine.UpdateMetadata.Extent.PARSER, extensionRegistry));
              break;
            }
            case 40: {
              bitField0_ |= 0x00000008;
              srcLength_ = input.readUInt64();
              break;
            }
            case 50: {
              if (!((mutable_bitField0_ & 0x00000020) != 0)) {
                dstExtents_ = new java.util.ArrayList<chromeos_update_engine.UpdateMetadata.Extent>();
                mutable_bitField0_ |= 0x00000020;
              }
              dstExtents_.add(
                  input.readMessage(chromeos_update_engine.UpdateMetadata.Extent.PARSER, extensionRegistry));
              break;
            }
            case 56: {
              bitField0_ |= 0x00000010;
              dstLength_ = input.readUInt64();
              break;
            }
            case 66: {
              bitField0_ |= 0x00000020;
              dataSha256Hash_ = input.readBytes();
              break;
            }
            case 74: {
              bitField0_ |= 0x00000040;
              srcSha256Hash_ = input.readBytes();
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000008) != 0)) {
          srcExtents_ = java.util.Collections.unmodifiableList(srcExtents_);
        }
        if (((mutable_bitField0_ & 0x00000020) != 0)) {
          dstExtents_ = java.util.Collections.unmodifiableList(dstExtents_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_InstallOperation_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_InstallOperation_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              chromeos_update_engine.UpdateMetadata.InstallOperation.class, chromeos_update_engine.UpdateMetadata.InstallOperation.Builder.class);
    }

    /**
     * Protobuf enum {@code chromeos_update_engine.InstallOperation.Type}
     */
    public enum Type
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <pre>
       * Replace destination extents w/ attached data
       * </pre>
       *
       * <code>REPLACE = 0;</code>
       */
      REPLACE(0),
      /**
       * <pre>
       * Replace destination extents w/ attached bzipped data
       * </pre>
       *
       * <code>REPLACE_BZ = 1;</code>
       */
      REPLACE_BZ(1),
      /**
       * <pre>
       * Move source extents to destination extents
       * </pre>
       *
       * <code>MOVE = 2 [deprecated = true];</code>
       */
      @java.lang.Deprecated
      MOVE(2),
      /**
       * <pre>
       * The data is a bsdiff binary diff
       * </pre>
       *
       * <code>BSDIFF = 3 [deprecated = true];</code>
       */
      @java.lang.Deprecated
      BSDIFF(3),
      /**
       * <pre>
       * On minor version 2 or newer, these operations are supported:
       * </pre>
       *
       * <code>SOURCE_COPY = 4;</code>
       */
      SOURCE_COPY(4),
      /**
       * <pre>
       * Like BSDIFF, but read from source partition
       * </pre>
       *
       * <code>SOURCE_BSDIFF = 5;</code>
       */
      SOURCE_BSDIFF(5),
      /**
       * <pre>
       * On minor version 3 or newer and on major version 2 or newer, these
       * operations are supported:
       * </pre>
       *
       * <code>REPLACE_XZ = 8;</code>
       */
      REPLACE_XZ(8),
      /**
       * <pre>
       * On minor version 4 or newer, these operations are supported:
       * </pre>
       *
       * <code>ZERO = 6;</code>
       */
      ZERO(6),
      /**
       * <pre>
       * Discard the destination blocks, reading as undefined.
       * </pre>
       *
       * <code>DISCARD = 7;</code>
       */
      DISCARD(7),
      /**
       * <pre>
       * Like SOURCE_BSDIFF, but compressed with brotli.
       * </pre>
       *
       * <code>BROTLI_BSDIFF = 10;</code>
       */
      BROTLI_BSDIFF(10),
      /**
       * <pre>
       * On minor version 5 or newer, these operations are supported:
       * </pre>
       *
       * <code>PUFFDIFF = 9;</code>
       */
      PUFFDIFF(9),
      ;

      /**
       * <pre>
       * Replace destination extents w/ attached data
       * </pre>
       *
       * <code>REPLACE = 0;</code>
       */
      public static final int REPLACE_VALUE = 0;
      /**
       * <pre>
       * Replace destination extents w/ attached bzipped data
       * </pre>
       *
       * <code>REPLACE_BZ = 1;</code>
       */
      public static final int REPLACE_BZ_VALUE = 1;
      /**
       * <pre>
       * Move source extents to destination extents
       * </pre>
       *
       * <code>MOVE = 2 [deprecated = true];</code>
       */
      @java.lang.Deprecated public static final int MOVE_VALUE = 2;
      /**
       * <pre>
       * The data is a bsdiff binary diff
       * </pre>
       *
       * <code>BSDIFF = 3 [deprecated = true];</code>
       */
      @java.lang.Deprecated public static final int BSDIFF_VALUE = 3;
      /**
       * <pre>
       * On minor version 2 or newer, these operations are supported:
       * </pre>
       *
       * <code>SOURCE_COPY = 4;</code>
       */
      public static final int SOURCE_COPY_VALUE = 4;
      /**
       * <pre>
       * Like BSDIFF, but read from source partition
       * </pre>
       *
       * <code>SOURCE_BSDIFF = 5;</code>
       */
      public static final int SOURCE_BSDIFF_VALUE = 5;
      /**
       * <pre>
       * On minor version 3 or newer and on major version 2 or newer, these
       * operations are supported:
       * </pre>
       *
       * <code>REPLACE_XZ = 8;</code>
       */
      public static final int REPLACE_XZ_VALUE = 8;
      /**
       * <pre>
       * On minor version 4 or newer, these operations are supported:
       * </pre>
       *
       * <code>ZERO = 6;</code>
       */
      public static final int ZERO_VALUE = 6;
      /**
       * <pre>
       * Discard the destination blocks, reading as undefined.
       * </pre>
       *
       * <code>DISCARD = 7;</code>
       */
      public static final int DISCARD_VALUE = 7;
      /**
       * <pre>
       * Like SOURCE_BSDIFF, but compressed with brotli.
       * </pre>
       *
       * <code>BROTLI_BSDIFF = 10;</code>
       */
      public static final int BROTLI_BSDIFF_VALUE = 10;
      /**
       * <pre>
       * On minor version 5 or newer, these operations are supported:
       * </pre>
       *
       * <code>PUFFDIFF = 9;</code>
       */
      public static final int PUFFDIFF_VALUE = 9;


      public final int getNumber() {
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static Type valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static Type forNumber(int value) {
        switch (value) {
          case 0: return REPLACE;
          case 1: return REPLACE_BZ;
          case 2: return MOVE;
          case 3: return BSDIFF;
          case 4: return SOURCE_COPY;
          case 5: return SOURCE_BSDIFF;
          case 8: return REPLACE_XZ;
          case 6: return ZERO;
          case 7: return DISCARD;
          case 10: return BROTLI_BSDIFF;
          case 9: return PUFFDIFF;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<Type>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          Type> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<Type>() {
              public Type findValueByNumber(int number) {
                return Type.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return chromeos_update_engine.UpdateMetadata.InstallOperation.getDescriptor().getEnumTypes().get(0);
      }

      private static final Type[] VALUES = values();

      public static Type valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private Type(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:chromeos_update_engine.InstallOperation.Type)
    }

    private int bitField0_;
    public static final int TYPE_FIELD_NUMBER = 1;
    private int type_;
    /**
     * <code>required .chromeos_update_engine.InstallOperation.Type type = 1;</code>
     * @return Whether the type field is set.
     */
    @java.lang.Override public boolean hasType() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>required .chromeos_update_engine.InstallOperation.Type type = 1;</code>
     * @return The type.
     */
    @java.lang.Override public chromeos_update_engine.UpdateMetadata.InstallOperation.Type getType() {
      @SuppressWarnings("deprecation")
      chromeos_update_engine.UpdateMetadata.InstallOperation.Type result = chromeos_update_engine.UpdateMetadata.InstallOperation.Type.valueOf(type_);
      return result == null ? chromeos_update_engine.UpdateMetadata.InstallOperation.Type.REPLACE : result;
    }

    public static final int DATA_OFFSET_FIELD_NUMBER = 2;
    private long dataOffset_;
    /**
     * <pre>
     * Only minor version 6 or newer support 64 bits |data_offset| and
     * |data_length|, older client will read them as uint32.
     * The offset into the delta file (after the protobuf)
     * where the data (if any) is stored
     * </pre>
     *
     * <code>optional uint64 data_offset = 2;</code>
     * @return Whether the dataOffset field is set.
     */
    @java.lang.Override
    public boolean hasDataOffset() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Only minor version 6 or newer support 64 bits |data_offset| and
     * |data_length|, older client will read them as uint32.
     * The offset into the delta file (after the protobuf)
     * where the data (if any) is stored
     * </pre>
     *
     * <code>optional uint64 data_offset = 2;</code>
     * @return The dataOffset.
     */
    @java.lang.Override
    public long getDataOffset() {
      return dataOffset_;
    }

    public static final int DATA_LENGTH_FIELD_NUMBER = 3;
    private long dataLength_;
    /**
     * <pre>
     * The length of the data in the delta file
     * </pre>
     *
     * <code>optional uint64 data_length = 3;</code>
     * @return Whether the dataLength field is set.
     */
    @java.lang.Override
    public boolean hasDataLength() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * The length of the data in the delta file
     * </pre>
     *
     * <code>optional uint64 data_length = 3;</code>
     * @return The dataLength.
     */
    @java.lang.Override
    public long getDataLength() {
      return dataLength_;
    }

    public static final int SRC_EXTENTS_FIELD_NUMBER = 4;
    private java.util.List<chromeos_update_engine.UpdateMetadata.Extent> srcExtents_;
    /**
     * <pre>
     * Ordered list of extents that are read from (if any) and written to.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.Extent src_extents = 4;</code>
     */
    @java.lang.Override
    public java.util.List<chromeos_update_engine.UpdateMetadata.Extent> getSrcExtentsList() {
      return srcExtents_;
    }
    /**
     * <pre>
     * Ordered list of extents that are read from (if any) and written to.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.Extent src_extents = 4;</code>
     */
    @java.lang.Override
    public java.util.List<? extends chromeos_update_engine.UpdateMetadata.ExtentOrBuilder>
        getSrcExtentsOrBuilderList() {
      return srcExtents_;
    }
    /**
     * <pre>
     * Ordered list of extents that are read from (if any) and written to.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.Extent src_extents = 4;</code>
     */
    @java.lang.Override
    public int getSrcExtentsCount() {
      return srcExtents_.size();
    }
    /**
     * <pre>
     * Ordered list of extents that are read from (if any) and written to.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.Extent src_extents = 4;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.Extent getSrcExtents(int index) {
      return srcExtents_.get(index);
    }
    /**
     * <pre>
     * Ordered list of extents that are read from (if any) and written to.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.Extent src_extents = 4;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.ExtentOrBuilder getSrcExtentsOrBuilder(
        int index) {
      return srcExtents_.get(index);
    }

    public static final int SRC_LENGTH_FIELD_NUMBER = 5;
    private long srcLength_;
    /**
     * <pre>
     * Byte length of src, equal to the number of blocks in src_extents *
     * block_size. It is used for BSDIFF and SOURCE_BSDIFF, because we need to
     * pass that external program the number of bytes to read from the blocks we
     * pass it.  This is not used in any other operation.
     * </pre>
     *
     * <code>optional uint64 src_length = 5;</code>
     * @return Whether the srcLength field is set.
     */
    @java.lang.Override
    public boolean hasSrcLength() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * Byte length of src, equal to the number of blocks in src_extents *
     * block_size. It is used for BSDIFF and SOURCE_BSDIFF, because we need to
     * pass that external program the number of bytes to read from the blocks we
     * pass it.  This is not used in any other operation.
     * </pre>
     *
     * <code>optional uint64 src_length = 5;</code>
     * @return The srcLength.
     */
    @java.lang.Override
    public long getSrcLength() {
      return srcLength_;
    }

    public static final int DST_EXTENTS_FIELD_NUMBER = 6;
    private java.util.List<chromeos_update_engine.UpdateMetadata.Extent> dstExtents_;
    /**
     * <code>repeated .chromeos_update_engine.Extent dst_extents = 6;</code>
     */
    @java.lang.Override
    public java.util.List<chromeos_update_engine.UpdateMetadata.Extent> getDstExtentsList() {
      return dstExtents_;
    }
    /**
     * <code>repeated .chromeos_update_engine.Extent dst_extents = 6;</code>
     */
    @java.lang.Override
    public java.util.List<? extends chromeos_update_engine.UpdateMetadata.ExtentOrBuilder>
        getDstExtentsOrBuilderList() {
      return dstExtents_;
    }
    /**
     * <code>repeated .chromeos_update_engine.Extent dst_extents = 6;</code>
     */
    @java.lang.Override
    public int getDstExtentsCount() {
      return dstExtents_.size();
    }
    /**
     * <code>repeated .chromeos_update_engine.Extent dst_extents = 6;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.Extent getDstExtents(int index) {
      return dstExtents_.get(index);
    }
    /**
     * <code>repeated .chromeos_update_engine.Extent dst_extents = 6;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.ExtentOrBuilder getDstExtentsOrBuilder(
        int index) {
      return dstExtents_.get(index);
    }

    public static final int DST_LENGTH_FIELD_NUMBER = 7;
    private long dstLength_;
    /**
     * <pre>
     * Byte length of dst, equal to the number of blocks in dst_extents *
     * block_size. Used for BSDIFF and SOURCE_BSDIFF, but not in any other
     * operation.
     * </pre>
     *
     * <code>optional uint64 dst_length = 7;</code>
     * @return Whether the dstLength field is set.
     */
    @java.lang.Override
    public boolean hasDstLength() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * Byte length of dst, equal to the number of blocks in dst_extents *
     * block_size. Used for BSDIFF and SOURCE_BSDIFF, but not in any other
     * operation.
     * </pre>
     *
     * <code>optional uint64 dst_length = 7;</code>
     * @return The dstLength.
     */
    @java.lang.Override
    public long getDstLength() {
      return dstLength_;
    }

    public static final int DATA_SHA256_HASH_FIELD_NUMBER = 8;
    private com.google.protobuf.ByteString dataSha256Hash_;
    /**
     * <pre>
     * Optional SHA 256 hash of the blob associated with this operation.
     * This is used as a primary validation for http-based downloads and
     * as a defense-in-depth validation for https-based downloads. If
     * the operation doesn't refer to any blob, this field will have
     * zero bytes.
     * </pre>
     *
     * <code>optional bytes data_sha256_hash = 8;</code>
     * @return Whether the dataSha256Hash field is set.
     */
    @java.lang.Override
    public boolean hasDataSha256Hash() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * Optional SHA 256 hash of the blob associated with this operation.
     * This is used as a primary validation for http-based downloads and
     * as a defense-in-depth validation for https-based downloads. If
     * the operation doesn't refer to any blob, this field will have
     * zero bytes.
     * </pre>
     *
     * <code>optional bytes data_sha256_hash = 8;</code>
     * @return The dataSha256Hash.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getDataSha256Hash() {
      return dataSha256Hash_;
    }

    public static final int SRC_SHA256_HASH_FIELD_NUMBER = 9;
    private com.google.protobuf.ByteString srcSha256Hash_;
    /**
     * <pre>
     * Indicates the SHA 256 hash of the source data referenced in src_extents at
     * the time of applying the operation. If present, the update_engine daemon
     * MUST read and verify the source data before applying the operation.
     * </pre>
     *
     * <code>optional bytes src_sha256_hash = 9;</code>
     * @return Whether the srcSha256Hash field is set.
     */
    @java.lang.Override
    public boolean hasSrcSha256Hash() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * Indicates the SHA 256 hash of the source data referenced in src_extents at
     * the time of applying the operation. If present, the update_engine daemon
     * MUST read and verify the source data before applying the operation.
     * </pre>
     *
     * <code>optional bytes src_sha256_hash = 9;</code>
     * @return The srcSha256Hash.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getSrcSha256Hash() {
      return srcSha256Hash_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (!hasType()) {
        memoizedIsInitialized = 0;
        return false;
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeEnum(1, type_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeUInt64(2, dataOffset_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeUInt64(3, dataLength_);
      }
      for (int i = 0; i < srcExtents_.size(); i++) {
        output.writeMessage(4, srcExtents_.get(i));
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeUInt64(5, srcLength_);
      }
      for (int i = 0; i < dstExtents_.size(); i++) {
        output.writeMessage(6, dstExtents_.get(i));
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeUInt64(7, dstLength_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        output.writeBytes(8, dataSha256Hash_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        output.writeBytes(9, srcSha256Hash_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(1, type_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(2, dataOffset_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(3, dataLength_);
      }
      for (int i = 0; i < srcExtents_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, srcExtents_.get(i));
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(5, srcLength_);
      }
      for (int i = 0; i < dstExtents_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(6, dstExtents_.get(i));
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(7, dstLength_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(8, dataSha256Hash_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(9, srcSha256Hash_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof chromeos_update_engine.UpdateMetadata.InstallOperation)) {
        return super.equals(obj);
      }
      chromeos_update_engine.UpdateMetadata.InstallOperation other = (chromeos_update_engine.UpdateMetadata.InstallOperation) obj;

      if (hasType() != other.hasType()) return false;
      if (hasType()) {
        if (type_ != other.type_) return false;
      }
      if (hasDataOffset() != other.hasDataOffset()) return false;
      if (hasDataOffset()) {
        if (getDataOffset()
            != other.getDataOffset()) return false;
      }
      if (hasDataLength() != other.hasDataLength()) return false;
      if (hasDataLength()) {
        if (getDataLength()
            != other.getDataLength()) return false;
      }
      if (!getSrcExtentsList()
          .equals(other.getSrcExtentsList())) return false;
      if (hasSrcLength() != other.hasSrcLength()) return false;
      if (hasSrcLength()) {
        if (getSrcLength()
            != other.getSrcLength()) return false;
      }
      if (!getDstExtentsList()
          .equals(other.getDstExtentsList())) return false;
      if (hasDstLength() != other.hasDstLength()) return false;
      if (hasDstLength()) {
        if (getDstLength()
            != other.getDstLength()) return false;
      }
      if (hasDataSha256Hash() != other.hasDataSha256Hash()) return false;
      if (hasDataSha256Hash()) {
        if (!getDataSha256Hash()
            .equals(other.getDataSha256Hash())) return false;
      }
      if (hasSrcSha256Hash() != other.hasSrcSha256Hash()) return false;
      if (hasSrcSha256Hash()) {
        if (!getSrcSha256Hash()
            .equals(other.getSrcSha256Hash())) return false;
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasType()) {
        hash = (37 * hash) + TYPE_FIELD_NUMBER;
        hash = (53 * hash) + type_;
      }
      if (hasDataOffset()) {
        hash = (37 * hash) + DATA_OFFSET_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getDataOffset());
      }
      if (hasDataLength()) {
        hash = (37 * hash) + DATA_LENGTH_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getDataLength());
      }
      if (getSrcExtentsCount() > 0) {
        hash = (37 * hash) + SRC_EXTENTS_FIELD_NUMBER;
        hash = (53 * hash) + getSrcExtentsList().hashCode();
      }
      if (hasSrcLength()) {
        hash = (37 * hash) + SRC_LENGTH_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getSrcLength());
      }
      if (getDstExtentsCount() > 0) {
        hash = (37 * hash) + DST_EXTENTS_FIELD_NUMBER;
        hash = (53 * hash) + getDstExtentsList().hashCode();
      }
      if (hasDstLength()) {
        hash = (37 * hash) + DST_LENGTH_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getDstLength());
      }
      if (hasDataSha256Hash()) {
        hash = (37 * hash) + DATA_SHA256_HASH_FIELD_NUMBER;
        hash = (53 * hash) + getDataSha256Hash().hashCode();
      }
      if (hasSrcSha256Hash()) {
        hash = (37 * hash) + SRC_SHA256_HASH_FIELD_NUMBER;
        hash = (53 * hash) + getSrcSha256Hash().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static chromeos_update_engine.UpdateMetadata.InstallOperation parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.InstallOperation parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.InstallOperation parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.InstallOperation parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.InstallOperation parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.InstallOperation parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.InstallOperation parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.InstallOperation parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.InstallOperation parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.InstallOperation parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.InstallOperation parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.InstallOperation parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(chromeos_update_engine.UpdateMetadata.InstallOperation prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code chromeos_update_engine.InstallOperation}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:chromeos_update_engine.InstallOperation)
        chromeos_update_engine.UpdateMetadata.InstallOperationOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_InstallOperation_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_InstallOperation_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                chromeos_update_engine.UpdateMetadata.InstallOperation.class, chromeos_update_engine.UpdateMetadata.InstallOperation.Builder.class);
      }

      // Construct using chromeos_update_engine.UpdateMetadata.InstallOperation.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getSrcExtentsFieldBuilder();
          getDstExtentsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        type_ = 0;
        bitField0_ = (bitField0_ & ~0x00000001);
        dataOffset_ = 0L;
        bitField0_ = (bitField0_ & ~0x00000002);
        dataLength_ = 0L;
        bitField0_ = (bitField0_ & ~0x00000004);
        if (srcExtentsBuilder_ == null) {
          srcExtents_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000008);
        } else {
          srcExtentsBuilder_.clear();
        }
        srcLength_ = 0L;
        bitField0_ = (bitField0_ & ~0x00000010);
        if (dstExtentsBuilder_ == null) {
          dstExtents_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000020);
        } else {
          dstExtentsBuilder_.clear();
        }
        dstLength_ = 0L;
        bitField0_ = (bitField0_ & ~0x00000040);
        dataSha256Hash_ = com.google.protobuf.ByteString.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000080);
        srcSha256Hash_ = com.google.protobuf.ByteString.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000100);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_InstallOperation_descriptor;
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.InstallOperation getDefaultInstanceForType() {
        return chromeos_update_engine.UpdateMetadata.InstallOperation.getDefaultInstance();
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.InstallOperation build() {
        chromeos_update_engine.UpdateMetadata.InstallOperation result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.InstallOperation buildPartial() {
        chromeos_update_engine.UpdateMetadata.InstallOperation result = new chromeos_update_engine.UpdateMetadata.InstallOperation(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          to_bitField0_ |= 0x00000001;
        }
        result.type_ = type_;
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.dataOffset_ = dataOffset_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.dataLength_ = dataLength_;
          to_bitField0_ |= 0x00000004;
        }
        if (srcExtentsBuilder_ == null) {
          if (((bitField0_ & 0x00000008) != 0)) {
            srcExtents_ = java.util.Collections.unmodifiableList(srcExtents_);
            bitField0_ = (bitField0_ & ~0x00000008);
          }
          result.srcExtents_ = srcExtents_;
        } else {
          result.srcExtents_ = srcExtentsBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.srcLength_ = srcLength_;
          to_bitField0_ |= 0x00000008;
        }
        if (dstExtentsBuilder_ == null) {
          if (((bitField0_ & 0x00000020) != 0)) {
            dstExtents_ = java.util.Collections.unmodifiableList(dstExtents_);
            bitField0_ = (bitField0_ & ~0x00000020);
          }
          result.dstExtents_ = dstExtents_;
        } else {
          result.dstExtents_ = dstExtentsBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.dstLength_ = dstLength_;
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          to_bitField0_ |= 0x00000020;
        }
        result.dataSha256Hash_ = dataSha256Hash_;
        if (((from_bitField0_ & 0x00000100) != 0)) {
          to_bitField0_ |= 0x00000040;
        }
        result.srcSha256Hash_ = srcSha256Hash_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof chromeos_update_engine.UpdateMetadata.InstallOperation) {
          return mergeFrom((chromeos_update_engine.UpdateMetadata.InstallOperation)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(chromeos_update_engine.UpdateMetadata.InstallOperation other) {
        if (other == chromeos_update_engine.UpdateMetadata.InstallOperation.getDefaultInstance()) return this;
        if (other.hasType()) {
          setType(other.getType());
        }
        if (other.hasDataOffset()) {
          setDataOffset(other.getDataOffset());
        }
        if (other.hasDataLength()) {
          setDataLength(other.getDataLength());
        }
        if (srcExtentsBuilder_ == null) {
          if (!other.srcExtents_.isEmpty()) {
            if (srcExtents_.isEmpty()) {
              srcExtents_ = other.srcExtents_;
              bitField0_ = (bitField0_ & ~0x00000008);
            } else {
              ensureSrcExtentsIsMutable();
              srcExtents_.addAll(other.srcExtents_);
            }
            onChanged();
          }
        } else {
          if (!other.srcExtents_.isEmpty()) {
            if (srcExtentsBuilder_.isEmpty()) {
              srcExtentsBuilder_.dispose();
              srcExtentsBuilder_ = null;
              srcExtents_ = other.srcExtents_;
              bitField0_ = (bitField0_ & ~0x00000008);
              srcExtentsBuilder_ =
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getSrcExtentsFieldBuilder() : null;
            } else {
              srcExtentsBuilder_.addAllMessages(other.srcExtents_);
            }
          }
        }
        if (other.hasSrcLength()) {
          setSrcLength(other.getSrcLength());
        }
        if (dstExtentsBuilder_ == null) {
          if (!other.dstExtents_.isEmpty()) {
            if (dstExtents_.isEmpty()) {
              dstExtents_ = other.dstExtents_;
              bitField0_ = (bitField0_ & ~0x00000020);
            } else {
              ensureDstExtentsIsMutable();
              dstExtents_.addAll(other.dstExtents_);
            }
            onChanged();
          }
        } else {
          if (!other.dstExtents_.isEmpty()) {
            if (dstExtentsBuilder_.isEmpty()) {
              dstExtentsBuilder_.dispose();
              dstExtentsBuilder_ = null;
              dstExtents_ = other.dstExtents_;
              bitField0_ = (bitField0_ & ~0x00000020);
              dstExtentsBuilder_ =
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getDstExtentsFieldBuilder() : null;
            } else {
              dstExtentsBuilder_.addAllMessages(other.dstExtents_);
            }
          }
        }
        if (other.hasDstLength()) {
          setDstLength(other.getDstLength());
        }
        if (other.hasDataSha256Hash()) {
          setDataSha256Hash(other.getDataSha256Hash());
        }
        if (other.hasSrcSha256Hash()) {
          setSrcSha256Hash(other.getSrcSha256Hash());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        if (!hasType()) {
          return false;
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        chromeos_update_engine.UpdateMetadata.InstallOperation parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (chromeos_update_engine.UpdateMetadata.InstallOperation) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private int type_ = 0;
      /**
       * <code>required .chromeos_update_engine.InstallOperation.Type type = 1;</code>
       * @return Whether the type field is set.
       */
      @java.lang.Override public boolean hasType() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>required .chromeos_update_engine.InstallOperation.Type type = 1;</code>
       * @return The type.
       */
      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.InstallOperation.Type getType() {
        @SuppressWarnings("deprecation")
        chromeos_update_engine.UpdateMetadata.InstallOperation.Type result = chromeos_update_engine.UpdateMetadata.InstallOperation.Type.valueOf(type_);
        return result == null ? chromeos_update_engine.UpdateMetadata.InstallOperation.Type.REPLACE : result;
      }
      /**
       * <code>required .chromeos_update_engine.InstallOperation.Type type = 1;</code>
       * @param value The type to set.
       * @return This builder for chaining.
       */
      public Builder setType(chromeos_update_engine.UpdateMetadata.InstallOperation.Type value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        type_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>required .chromeos_update_engine.InstallOperation.Type type = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearType() {
        bitField0_ = (bitField0_ & ~0x00000001);
        type_ = 0;
        onChanged();
        return this;
      }

      private long dataOffset_ ;
      /**
       * <pre>
       * Only minor version 6 or newer support 64 bits |data_offset| and
       * |data_length|, older client will read them as uint32.
       * The offset into the delta file (after the protobuf)
       * where the data (if any) is stored
       * </pre>
       *
       * <code>optional uint64 data_offset = 2;</code>
       * @return Whether the dataOffset field is set.
       */
      @java.lang.Override
      public boolean hasDataOffset() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Only minor version 6 or newer support 64 bits |data_offset| and
       * |data_length|, older client will read them as uint32.
       * The offset into the delta file (after the protobuf)
       * where the data (if any) is stored
       * </pre>
       *
       * <code>optional uint64 data_offset = 2;</code>
       * @return The dataOffset.
       */
      @java.lang.Override
      public long getDataOffset() {
        return dataOffset_;
      }
      /**
       * <pre>
       * Only minor version 6 or newer support 64 bits |data_offset| and
       * |data_length|, older client will read them as uint32.
       * The offset into the delta file (after the protobuf)
       * where the data (if any) is stored
       * </pre>
       *
       * <code>optional uint64 data_offset = 2;</code>
       * @param value The dataOffset to set.
       * @return This builder for chaining.
       */
      public Builder setDataOffset(long value) {
        bitField0_ |= 0x00000002;
        dataOffset_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Only minor version 6 or newer support 64 bits |data_offset| and
       * |data_length|, older client will read them as uint32.
       * The offset into the delta file (after the protobuf)
       * where the data (if any) is stored
       * </pre>
       *
       * <code>optional uint64 data_offset = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearDataOffset() {
        bitField0_ = (bitField0_ & ~0x00000002);
        dataOffset_ = 0L;
        onChanged();
        return this;
      }

      private long dataLength_ ;
      /**
       * <pre>
       * The length of the data in the delta file
       * </pre>
       *
       * <code>optional uint64 data_length = 3;</code>
       * @return Whether the dataLength field is set.
       */
      @java.lang.Override
      public boolean hasDataLength() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * The length of the data in the delta file
       * </pre>
       *
       * <code>optional uint64 data_length = 3;</code>
       * @return The dataLength.
       */
      @java.lang.Override
      public long getDataLength() {
        return dataLength_;
      }
      /**
       * <pre>
       * The length of the data in the delta file
       * </pre>
       *
       * <code>optional uint64 data_length = 3;</code>
       * @param value The dataLength to set.
       * @return This builder for chaining.
       */
      public Builder setDataLength(long value) {
        bitField0_ |= 0x00000004;
        dataLength_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The length of the data in the delta file
       * </pre>
       *
       * <code>optional uint64 data_length = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearDataLength() {
        bitField0_ = (bitField0_ & ~0x00000004);
        dataLength_ = 0L;
        onChanged();
        return this;
      }

      private java.util.List<chromeos_update_engine.UpdateMetadata.Extent> srcExtents_ =
        java.util.Collections.emptyList();
      private void ensureSrcExtentsIsMutable() {
        if (!((bitField0_ & 0x00000008) != 0)) {
          srcExtents_ = new java.util.ArrayList<chromeos_update_engine.UpdateMetadata.Extent>(srcExtents_);
          bitField0_ |= 0x00000008;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.Extent, chromeos_update_engine.UpdateMetadata.Extent.Builder, chromeos_update_engine.UpdateMetadata.ExtentOrBuilder> srcExtentsBuilder_;

      /**
       * <pre>
       * Ordered list of extents that are read from (if any) and written to.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Extent src_extents = 4;</code>
       */
      public java.util.List<chromeos_update_engine.UpdateMetadata.Extent> getSrcExtentsList() {
        if (srcExtentsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(srcExtents_);
        } else {
          return srcExtentsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Ordered list of extents that are read from (if any) and written to.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Extent src_extents = 4;</code>
       */
      public int getSrcExtentsCount() {
        if (srcExtentsBuilder_ == null) {
          return srcExtents_.size();
        } else {
          return srcExtentsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Ordered list of extents that are read from (if any) and written to.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Extent src_extents = 4;</code>
       */
      public chromeos_update_engine.UpdateMetadata.Extent getSrcExtents(int index) {
        if (srcExtentsBuilder_ == null) {
          return srcExtents_.get(index);
        } else {
          return srcExtentsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Ordered list of extents that are read from (if any) and written to.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Extent src_extents = 4;</code>
       */
      public Builder setSrcExtents(
          int index, chromeos_update_engine.UpdateMetadata.Extent value) {
        if (srcExtentsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSrcExtentsIsMutable();
          srcExtents_.set(index, value);
          onChanged();
        } else {
          srcExtentsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Ordered list of extents that are read from (if any) and written to.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Extent src_extents = 4;</code>
       */
      public Builder setSrcExtents(
          int index, chromeos_update_engine.UpdateMetadata.Extent.Builder builderForValue) {
        if (srcExtentsBuilder_ == null) {
          ensureSrcExtentsIsMutable();
          srcExtents_.set(index, builderForValue.build());
          onChanged();
        } else {
          srcExtentsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Ordered list of extents that are read from (if any) and written to.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Extent src_extents = 4;</code>
       */
      public Builder addSrcExtents(chromeos_update_engine.UpdateMetadata.Extent value) {
        if (srcExtentsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSrcExtentsIsMutable();
          srcExtents_.add(value);
          onChanged();
        } else {
          srcExtentsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Ordered list of extents that are read from (if any) and written to.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Extent src_extents = 4;</code>
       */
      public Builder addSrcExtents(
          int index, chromeos_update_engine.UpdateMetadata.Extent value) {
        if (srcExtentsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSrcExtentsIsMutable();
          srcExtents_.add(index, value);
          onChanged();
        } else {
          srcExtentsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Ordered list of extents that are read from (if any) and written to.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Extent src_extents = 4;</code>
       */
      public Builder addSrcExtents(
          chromeos_update_engine.UpdateMetadata.Extent.Builder builderForValue) {
        if (srcExtentsBuilder_ == null) {
          ensureSrcExtentsIsMutable();
          srcExtents_.add(builderForValue.build());
          onChanged();
        } else {
          srcExtentsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Ordered list of extents that are read from (if any) and written to.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Extent src_extents = 4;</code>
       */
      public Builder addSrcExtents(
          int index, chromeos_update_engine.UpdateMetadata.Extent.Builder builderForValue) {
        if (srcExtentsBuilder_ == null) {
          ensureSrcExtentsIsMutable();
          srcExtents_.add(index, builderForValue.build());
          onChanged();
        } else {
          srcExtentsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Ordered list of extents that are read from (if any) and written to.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Extent src_extents = 4;</code>
       */
      public Builder addAllSrcExtents(
          java.lang.Iterable<? extends chromeos_update_engine.UpdateMetadata.Extent> values) {
        if (srcExtentsBuilder_ == null) {
          ensureSrcExtentsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, srcExtents_);
          onChanged();
        } else {
          srcExtentsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Ordered list of extents that are read from (if any) and written to.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Extent src_extents = 4;</code>
       */
      public Builder clearSrcExtents() {
        if (srcExtentsBuilder_ == null) {
          srcExtents_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000008);
          onChanged();
        } else {
          srcExtentsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Ordered list of extents that are read from (if any) and written to.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Extent src_extents = 4;</code>
       */
      public Builder removeSrcExtents(int index) {
        if (srcExtentsBuilder_ == null) {
          ensureSrcExtentsIsMutable();
          srcExtents_.remove(index);
          onChanged();
        } else {
          srcExtentsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Ordered list of extents that are read from (if any) and written to.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Extent src_extents = 4;</code>
       */
      public chromeos_update_engine.UpdateMetadata.Extent.Builder getSrcExtentsBuilder(
          int index) {
        return getSrcExtentsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Ordered list of extents that are read from (if any) and written to.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Extent src_extents = 4;</code>
       */
      public chromeos_update_engine.UpdateMetadata.ExtentOrBuilder getSrcExtentsOrBuilder(
          int index) {
        if (srcExtentsBuilder_ == null) {
          return srcExtents_.get(index);  } else {
          return srcExtentsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Ordered list of extents that are read from (if any) and written to.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Extent src_extents = 4;</code>
       */
      public java.util.List<? extends chromeos_update_engine.UpdateMetadata.ExtentOrBuilder>
           getSrcExtentsOrBuilderList() {
        if (srcExtentsBuilder_ != null) {
          return srcExtentsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(srcExtents_);
        }
      }
      /**
       * <pre>
       * Ordered list of extents that are read from (if any) and written to.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Extent src_extents = 4;</code>
       */
      public chromeos_update_engine.UpdateMetadata.Extent.Builder addSrcExtentsBuilder() {
        return getSrcExtentsFieldBuilder().addBuilder(
            chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance());
      }
      /**
       * <pre>
       * Ordered list of extents that are read from (if any) and written to.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Extent src_extents = 4;</code>
       */
      public chromeos_update_engine.UpdateMetadata.Extent.Builder addSrcExtentsBuilder(
          int index) {
        return getSrcExtentsFieldBuilder().addBuilder(
            index, chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance());
      }
      /**
       * <pre>
       * Ordered list of extents that are read from (if any) and written to.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Extent src_extents = 4;</code>
       */
      public java.util.List<chromeos_update_engine.UpdateMetadata.Extent.Builder>
           getSrcExtentsBuilderList() {
        return getSrcExtentsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.Extent, chromeos_update_engine.UpdateMetadata.Extent.Builder, chromeos_update_engine.UpdateMetadata.ExtentOrBuilder>
          getSrcExtentsFieldBuilder() {
        if (srcExtentsBuilder_ == null) {
          srcExtentsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              chromeos_update_engine.UpdateMetadata.Extent, chromeos_update_engine.UpdateMetadata.Extent.Builder, chromeos_update_engine.UpdateMetadata.ExtentOrBuilder>(
                  srcExtents_,
                  ((bitField0_ & 0x00000008) != 0),
                  getParentForChildren(),
                  isClean());
          srcExtents_ = null;
        }
        return srcExtentsBuilder_;
      }

      private long srcLength_ ;
      /**
       * <pre>
       * Byte length of src, equal to the number of blocks in src_extents *
       * block_size. It is used for BSDIFF and SOURCE_BSDIFF, because we need to
       * pass that external program the number of bytes to read from the blocks we
       * pass it.  This is not used in any other operation.
       * </pre>
       *
       * <code>optional uint64 src_length = 5;</code>
       * @return Whether the srcLength field is set.
       */
      @java.lang.Override
      public boolean hasSrcLength() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * Byte length of src, equal to the number of blocks in src_extents *
       * block_size. It is used for BSDIFF and SOURCE_BSDIFF, because we need to
       * pass that external program the number of bytes to read from the blocks we
       * pass it.  This is not used in any other operation.
       * </pre>
       *
       * <code>optional uint64 src_length = 5;</code>
       * @return The srcLength.
       */
      @java.lang.Override
      public long getSrcLength() {
        return srcLength_;
      }
      /**
       * <pre>
       * Byte length of src, equal to the number of blocks in src_extents *
       * block_size. It is used for BSDIFF and SOURCE_BSDIFF, because we need to
       * pass that external program the number of bytes to read from the blocks we
       * pass it.  This is not used in any other operation.
       * </pre>
       *
       * <code>optional uint64 src_length = 5;</code>
       * @param value The srcLength to set.
       * @return This builder for chaining.
       */
      public Builder setSrcLength(long value) {
        bitField0_ |= 0x00000010;
        srcLength_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Byte length of src, equal to the number of blocks in src_extents *
       * block_size. It is used for BSDIFF and SOURCE_BSDIFF, because we need to
       * pass that external program the number of bytes to read from the blocks we
       * pass it.  This is not used in any other operation.
       * </pre>
       *
       * <code>optional uint64 src_length = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearSrcLength() {
        bitField0_ = (bitField0_ & ~0x00000010);
        srcLength_ = 0L;
        onChanged();
        return this;
      }

      private java.util.List<chromeos_update_engine.UpdateMetadata.Extent> dstExtents_ =
        java.util.Collections.emptyList();
      private void ensureDstExtentsIsMutable() {
        if (!((bitField0_ & 0x00000020) != 0)) {
          dstExtents_ = new java.util.ArrayList<chromeos_update_engine.UpdateMetadata.Extent>(dstExtents_);
          bitField0_ |= 0x00000020;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.Extent, chromeos_update_engine.UpdateMetadata.Extent.Builder, chromeos_update_engine.UpdateMetadata.ExtentOrBuilder> dstExtentsBuilder_;

      /**
       * <code>repeated .chromeos_update_engine.Extent dst_extents = 6;</code>
       */
      public java.util.List<chromeos_update_engine.UpdateMetadata.Extent> getDstExtentsList() {
        if (dstExtentsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(dstExtents_);
        } else {
          return dstExtentsBuilder_.getMessageList();
        }
      }
      /**
       * <code>repeated .chromeos_update_engine.Extent dst_extents = 6;</code>
       */
      public int getDstExtentsCount() {
        if (dstExtentsBuilder_ == null) {
          return dstExtents_.size();
        } else {
          return dstExtentsBuilder_.getCount();
        }
      }
      /**
       * <code>repeated .chromeos_update_engine.Extent dst_extents = 6;</code>
       */
      public chromeos_update_engine.UpdateMetadata.Extent getDstExtents(int index) {
        if (dstExtentsBuilder_ == null) {
          return dstExtents_.get(index);
        } else {
          return dstExtentsBuilder_.getMessage(index);
        }
      }
      /**
       * <code>repeated .chromeos_update_engine.Extent dst_extents = 6;</code>
       */
      public Builder setDstExtents(
          int index, chromeos_update_engine.UpdateMetadata.Extent value) {
        if (dstExtentsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureDstExtentsIsMutable();
          dstExtents_.set(index, value);
          onChanged();
        } else {
          dstExtentsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .chromeos_update_engine.Extent dst_extents = 6;</code>
       */
      public Builder setDstExtents(
          int index, chromeos_update_engine.UpdateMetadata.Extent.Builder builderForValue) {
        if (dstExtentsBuilder_ == null) {
          ensureDstExtentsIsMutable();
          dstExtents_.set(index, builderForValue.build());
          onChanged();
        } else {
          dstExtentsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .chromeos_update_engine.Extent dst_extents = 6;</code>
       */
      public Builder addDstExtents(chromeos_update_engine.UpdateMetadata.Extent value) {
        if (dstExtentsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureDstExtentsIsMutable();
          dstExtents_.add(value);
          onChanged();
        } else {
          dstExtentsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <code>repeated .chromeos_update_engine.Extent dst_extents = 6;</code>
       */
      public Builder addDstExtents(
          int index, chromeos_update_engine.UpdateMetadata.Extent value) {
        if (dstExtentsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureDstExtentsIsMutable();
          dstExtents_.add(index, value);
          onChanged();
        } else {
          dstExtentsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .chromeos_update_engine.Extent dst_extents = 6;</code>
       */
      public Builder addDstExtents(
          chromeos_update_engine.UpdateMetadata.Extent.Builder builderForValue) {
        if (dstExtentsBuilder_ == null) {
          ensureDstExtentsIsMutable();
          dstExtents_.add(builderForValue.build());
          onChanged();
        } else {
          dstExtentsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .chromeos_update_engine.Extent dst_extents = 6;</code>
       */
      public Builder addDstExtents(
          int index, chromeos_update_engine.UpdateMetadata.Extent.Builder builderForValue) {
        if (dstExtentsBuilder_ == null) {
          ensureDstExtentsIsMutable();
          dstExtents_.add(index, builderForValue.build());
          onChanged();
        } else {
          dstExtentsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .chromeos_update_engine.Extent dst_extents = 6;</code>
       */
      public Builder addAllDstExtents(
          java.lang.Iterable<? extends chromeos_update_engine.UpdateMetadata.Extent> values) {
        if (dstExtentsBuilder_ == null) {
          ensureDstExtentsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, dstExtents_);
          onChanged();
        } else {
          dstExtentsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <code>repeated .chromeos_update_engine.Extent dst_extents = 6;</code>
       */
      public Builder clearDstExtents() {
        if (dstExtentsBuilder_ == null) {
          dstExtents_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000020);
          onChanged();
        } else {
          dstExtentsBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>repeated .chromeos_update_engine.Extent dst_extents = 6;</code>
       */
      public Builder removeDstExtents(int index) {
        if (dstExtentsBuilder_ == null) {
          ensureDstExtentsIsMutable();
          dstExtents_.remove(index);
          onChanged();
        } else {
          dstExtentsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <code>repeated .chromeos_update_engine.Extent dst_extents = 6;</code>
       */
      public chromeos_update_engine.UpdateMetadata.Extent.Builder getDstExtentsBuilder(
          int index) {
        return getDstExtentsFieldBuilder().getBuilder(index);
      }
      /**
       * <code>repeated .chromeos_update_engine.Extent dst_extents = 6;</code>
       */
      public chromeos_update_engine.UpdateMetadata.ExtentOrBuilder getDstExtentsOrBuilder(
          int index) {
        if (dstExtentsBuilder_ == null) {
          return dstExtents_.get(index);  } else {
          return dstExtentsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <code>repeated .chromeos_update_engine.Extent dst_extents = 6;</code>
       */
      public java.util.List<? extends chromeos_update_engine.UpdateMetadata.ExtentOrBuilder>
           getDstExtentsOrBuilderList() {
        if (dstExtentsBuilder_ != null) {
          return dstExtentsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(dstExtents_);
        }
      }
      /**
       * <code>repeated .chromeos_update_engine.Extent dst_extents = 6;</code>
       */
      public chromeos_update_engine.UpdateMetadata.Extent.Builder addDstExtentsBuilder() {
        return getDstExtentsFieldBuilder().addBuilder(
            chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance());
      }
      /**
       * <code>repeated .chromeos_update_engine.Extent dst_extents = 6;</code>
       */
      public chromeos_update_engine.UpdateMetadata.Extent.Builder addDstExtentsBuilder(
          int index) {
        return getDstExtentsFieldBuilder().addBuilder(
            index, chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance());
      }
      /**
       * <code>repeated .chromeos_update_engine.Extent dst_extents = 6;</code>
       */
      public java.util.List<chromeos_update_engine.UpdateMetadata.Extent.Builder>
           getDstExtentsBuilderList() {
        return getDstExtentsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.Extent, chromeos_update_engine.UpdateMetadata.Extent.Builder, chromeos_update_engine.UpdateMetadata.ExtentOrBuilder>
          getDstExtentsFieldBuilder() {
        if (dstExtentsBuilder_ == null) {
          dstExtentsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              chromeos_update_engine.UpdateMetadata.Extent, chromeos_update_engine.UpdateMetadata.Extent.Builder, chromeos_update_engine.UpdateMetadata.ExtentOrBuilder>(
                  dstExtents_,
                  ((bitField0_ & 0x00000020) != 0),
                  getParentForChildren(),
                  isClean());
          dstExtents_ = null;
        }
        return dstExtentsBuilder_;
      }

      private long dstLength_ ;
      /**
       * <pre>
       * Byte length of dst, equal to the number of blocks in dst_extents *
       * block_size. Used for BSDIFF and SOURCE_BSDIFF, but not in any other
       * operation.
       * </pre>
       *
       * <code>optional uint64 dst_length = 7;</code>
       * @return Whether the dstLength field is set.
       */
      @java.lang.Override
      public boolean hasDstLength() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <pre>
       * Byte length of dst, equal to the number of blocks in dst_extents *
       * block_size. Used for BSDIFF and SOURCE_BSDIFF, but not in any other
       * operation.
       * </pre>
       *
       * <code>optional uint64 dst_length = 7;</code>
       * @return The dstLength.
       */
      @java.lang.Override
      public long getDstLength() {
        return dstLength_;
      }
      /**
       * <pre>
       * Byte length of dst, equal to the number of blocks in dst_extents *
       * block_size. Used for BSDIFF and SOURCE_BSDIFF, but not in any other
       * operation.
       * </pre>
       *
       * <code>optional uint64 dst_length = 7;</code>
       * @param value The dstLength to set.
       * @return This builder for chaining.
       */
      public Builder setDstLength(long value) {
        bitField0_ |= 0x00000040;
        dstLength_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Byte length of dst, equal to the number of blocks in dst_extents *
       * block_size. Used for BSDIFF and SOURCE_BSDIFF, but not in any other
       * operation.
       * </pre>
       *
       * <code>optional uint64 dst_length = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearDstLength() {
        bitField0_ = (bitField0_ & ~0x00000040);
        dstLength_ = 0L;
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString dataSha256Hash_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * Optional SHA 256 hash of the blob associated with this operation.
       * This is used as a primary validation for http-based downloads and
       * as a defense-in-depth validation for https-based downloads. If
       * the operation doesn't refer to any blob, this field will have
       * zero bytes.
       * </pre>
       *
       * <code>optional bytes data_sha256_hash = 8;</code>
       * @return Whether the dataSha256Hash field is set.
       */
      @java.lang.Override
      public boolean hasDataSha256Hash() {
        return ((bitField0_ & 0x00000080) != 0);
      }
      /**
       * <pre>
       * Optional SHA 256 hash of the blob associated with this operation.
       * This is used as a primary validation for http-based downloads and
       * as a defense-in-depth validation for https-based downloads. If
       * the operation doesn't refer to any blob, this field will have
       * zero bytes.
       * </pre>
       *
       * <code>optional bytes data_sha256_hash = 8;</code>
       * @return The dataSha256Hash.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getDataSha256Hash() {
        return dataSha256Hash_;
      }
      /**
       * <pre>
       * Optional SHA 256 hash of the blob associated with this operation.
       * This is used as a primary validation for http-based downloads and
       * as a defense-in-depth validation for https-based downloads. If
       * the operation doesn't refer to any blob, this field will have
       * zero bytes.
       * </pre>
       *
       * <code>optional bytes data_sha256_hash = 8;</code>
       * @param value The dataSha256Hash to set.
       * @return This builder for chaining.
       */
      public Builder setDataSha256Hash(com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000080;
        dataSha256Hash_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Optional SHA 256 hash of the blob associated with this operation.
       * This is used as a primary validation for http-based downloads and
       * as a defense-in-depth validation for https-based downloads. If
       * the operation doesn't refer to any blob, this field will have
       * zero bytes.
       * </pre>
       *
       * <code>optional bytes data_sha256_hash = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearDataSha256Hash() {
        bitField0_ = (bitField0_ & ~0x00000080);
        dataSha256Hash_ = getDefaultInstance().getDataSha256Hash();
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString srcSha256Hash_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * Indicates the SHA 256 hash of the source data referenced in src_extents at
       * the time of applying the operation. If present, the update_engine daemon
       * MUST read and verify the source data before applying the operation.
       * </pre>
       *
       * <code>optional bytes src_sha256_hash = 9;</code>
       * @return Whether the srcSha256Hash field is set.
       */
      @java.lang.Override
      public boolean hasSrcSha256Hash() {
        return ((bitField0_ & 0x00000100) != 0);
      }
      /**
       * <pre>
       * Indicates the SHA 256 hash of the source data referenced in src_extents at
       * the time of applying the operation. If present, the update_engine daemon
       * MUST read and verify the source data before applying the operation.
       * </pre>
       *
       * <code>optional bytes src_sha256_hash = 9;</code>
       * @return The srcSha256Hash.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getSrcSha256Hash() {
        return srcSha256Hash_;
      }
      /**
       * <pre>
       * Indicates the SHA 256 hash of the source data referenced in src_extents at
       * the time of applying the operation. If present, the update_engine daemon
       * MUST read and verify the source data before applying the operation.
       * </pre>
       *
       * <code>optional bytes src_sha256_hash = 9;</code>
       * @param value The srcSha256Hash to set.
       * @return This builder for chaining.
       */
      public Builder setSrcSha256Hash(com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000100;
        srcSha256Hash_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Indicates the SHA 256 hash of the source data referenced in src_extents at
       * the time of applying the operation. If present, the update_engine daemon
       * MUST read and verify the source data before applying the operation.
       * </pre>
       *
       * <code>optional bytes src_sha256_hash = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearSrcSha256Hash() {
        bitField0_ = (bitField0_ & ~0x00000100);
        srcSha256Hash_ = getDefaultInstance().getSrcSha256Hash();
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:chromeos_update_engine.InstallOperation)
    }

    // @@protoc_insertion_point(class_scope:chromeos_update_engine.InstallOperation)
    private static final chromeos_update_engine.UpdateMetadata.InstallOperation DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new chromeos_update_engine.UpdateMetadata.InstallOperation();
    }

    public static chromeos_update_engine.UpdateMetadata.InstallOperation getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<InstallOperation>
        PARSER = new com.google.protobuf.AbstractParser<InstallOperation>() {
      @java.lang.Override
      public InstallOperation parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new InstallOperation(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<InstallOperation> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<InstallOperation> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.InstallOperation getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface PartitionUpdateOrBuilder extends
      // @@protoc_insertion_point(interface_extends:chromeos_update_engine.PartitionUpdate)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * A platform-specific name to identify the partition set being updated. For
     * example, in Chrome OS this could be "ROOT" or "KERNEL".
     * </pre>
     *
     * <code>required string partition_name = 1;</code>
     * @return Whether the partitionName field is set.
     */
    boolean hasPartitionName();
    /**
     * <pre>
     * A platform-specific name to identify the partition set being updated. For
     * example, in Chrome OS this could be "ROOT" or "KERNEL".
     * </pre>
     *
     * <code>required string partition_name = 1;</code>
     * @return The partitionName.
     */
    java.lang.String getPartitionName();
    /**
     * <pre>
     * A platform-specific name to identify the partition set being updated. For
     * example, in Chrome OS this could be "ROOT" or "KERNEL".
     * </pre>
     *
     * <code>required string partition_name = 1;</code>
     * @return The bytes for partitionName.
     */
    com.google.protobuf.ByteString
        getPartitionNameBytes();

    /**
     * <pre>
     * Whether this partition carries a filesystem with post-install program that
     * must be run to finalize the update process. See also |postinstall_path| and
     * |filesystem_type|.
     * </pre>
     *
     * <code>optional bool run_postinstall = 2;</code>
     * @return Whether the runPostinstall field is set.
     */
    boolean hasRunPostinstall();
    /**
     * <pre>
     * Whether this partition carries a filesystem with post-install program that
     * must be run to finalize the update process. See also |postinstall_path| and
     * |filesystem_type|.
     * </pre>
     *
     * <code>optional bool run_postinstall = 2;</code>
     * @return The runPostinstall.
     */
    boolean getRunPostinstall();

    /**
     * <pre>
     * The path of the executable program to run during the post-install step,
     * relative to the root of this filesystem. If not set, the default "postinst"
     * will be used. This setting is only used when |run_postinstall| is set and
     * true.
     * </pre>
     *
     * <code>optional string postinstall_path = 3;</code>
     * @return Whether the postinstallPath field is set.
     */
    boolean hasPostinstallPath();
    /**
     * <pre>
     * The path of the executable program to run during the post-install step,
     * relative to the root of this filesystem. If not set, the default "postinst"
     * will be used. This setting is only used when |run_postinstall| is set and
     * true.
     * </pre>
     *
     * <code>optional string postinstall_path = 3;</code>
     * @return The postinstallPath.
     */
    java.lang.String getPostinstallPath();
    /**
     * <pre>
     * The path of the executable program to run during the post-install step,
     * relative to the root of this filesystem. If not set, the default "postinst"
     * will be used. This setting is only used when |run_postinstall| is set and
     * true.
     * </pre>
     *
     * <code>optional string postinstall_path = 3;</code>
     * @return The bytes for postinstallPath.
     */
    com.google.protobuf.ByteString
        getPostinstallPathBytes();

    /**
     * <pre>
     * The filesystem type as passed to the mount(2) syscall when mounting the new
     * filesystem to run the post-install program. If not set, a fixed list of
     * filesystems will be attempted. This setting is only used if
     * |run_postinstall| is set and true.
     * </pre>
     *
     * <code>optional string filesystem_type = 4;</code>
     * @return Whether the filesystemType field is set.
     */
    boolean hasFilesystemType();
    /**
     * <pre>
     * The filesystem type as passed to the mount(2) syscall when mounting the new
     * filesystem to run the post-install program. If not set, a fixed list of
     * filesystems will be attempted. This setting is only used if
     * |run_postinstall| is set and true.
     * </pre>
     *
     * <code>optional string filesystem_type = 4;</code>
     * @return The filesystemType.
     */
    java.lang.String getFilesystemType();
    /**
     * <pre>
     * The filesystem type as passed to the mount(2) syscall when mounting the new
     * filesystem to run the post-install program. If not set, a fixed list of
     * filesystems will be attempted. This setting is only used if
     * |run_postinstall| is set and true.
     * </pre>
     *
     * <code>optional string filesystem_type = 4;</code>
     * @return The bytes for filesystemType.
     */
    com.google.protobuf.ByteString
        getFilesystemTypeBytes();

    /**
     * <pre>
     * If present, a list of signatures of the new_partition_info.hash signed with
     * different keys. If the update_engine daemon requires vendor-signed images
     * and has its public key installed, one of the signatures should be valid
     * for /postinstall to run.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;</code>
     */
    java.util.List<chromeos_update_engine.UpdateMetadata.Signatures.Signature>
        getNewPartitionSignatureList();
    /**
     * <pre>
     * If present, a list of signatures of the new_partition_info.hash signed with
     * different keys. If the update_engine daemon requires vendor-signed images
     * and has its public key installed, one of the signatures should be valid
     * for /postinstall to run.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;</code>
     */
    chromeos_update_engine.UpdateMetadata.Signatures.Signature getNewPartitionSignature(int index);
    /**
     * <pre>
     * If present, a list of signatures of the new_partition_info.hash signed with
     * different keys. If the update_engine daemon requires vendor-signed images
     * and has its public key installed, one of the signatures should be valid
     * for /postinstall to run.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;</code>
     */
    int getNewPartitionSignatureCount();
    /**
     * <pre>
     * If present, a list of signatures of the new_partition_info.hash signed with
     * different keys. If the update_engine daemon requires vendor-signed images
     * and has its public key installed, one of the signatures should be valid
     * for /postinstall to run.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;</code>
     */
    java.util.List<? extends chromeos_update_engine.UpdateMetadata.Signatures.SignatureOrBuilder>
        getNewPartitionSignatureOrBuilderList();
    /**
     * <pre>
     * If present, a list of signatures of the new_partition_info.hash signed with
     * different keys. If the update_engine daemon requires vendor-signed images
     * and has its public key installed, one of the signatures should be valid
     * for /postinstall to run.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;</code>
     */
    chromeos_update_engine.UpdateMetadata.Signatures.SignatureOrBuilder getNewPartitionSignatureOrBuilder(
        int index);

    /**
     * <code>optional .chromeos_update_engine.PartitionInfo old_partition_info = 6;</code>
     * @return Whether the oldPartitionInfo field is set.
     */
    boolean hasOldPartitionInfo();
    /**
     * <code>optional .chromeos_update_engine.PartitionInfo old_partition_info = 6;</code>
     * @return The oldPartitionInfo.
     */
    chromeos_update_engine.UpdateMetadata.PartitionInfo getOldPartitionInfo();
    /**
     * <code>optional .chromeos_update_engine.PartitionInfo old_partition_info = 6;</code>
     */
    chromeos_update_engine.UpdateMetadata.PartitionInfoOrBuilder getOldPartitionInfoOrBuilder();

    /**
     * <code>optional .chromeos_update_engine.PartitionInfo new_partition_info = 7;</code>
     * @return Whether the newPartitionInfo field is set.
     */
    boolean hasNewPartitionInfo();
    /**
     * <code>optional .chromeos_update_engine.PartitionInfo new_partition_info = 7;</code>
     * @return The newPartitionInfo.
     */
    chromeos_update_engine.UpdateMetadata.PartitionInfo getNewPartitionInfo();
    /**
     * <code>optional .chromeos_update_engine.PartitionInfo new_partition_info = 7;</code>
     */
    chromeos_update_engine.UpdateMetadata.PartitionInfoOrBuilder getNewPartitionInfoOrBuilder();

    /**
     * <pre>
     * The list of operations to be performed to apply this PartitionUpdate. The
     * associated operation blobs (in operations[i].data_offset, data_length)
     * should be stored contiguously and in the same order.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.InstallOperation operations = 8;</code>
     */
    java.util.List<chromeos_update_engine.UpdateMetadata.InstallOperation>
        getOperationsList();
    /**
     * <pre>
     * The list of operations to be performed to apply this PartitionUpdate. The
     * associated operation blobs (in operations[i].data_offset, data_length)
     * should be stored contiguously and in the same order.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.InstallOperation operations = 8;</code>
     */
    chromeos_update_engine.UpdateMetadata.InstallOperation getOperations(int index);
    /**
     * <pre>
     * The list of operations to be performed to apply this PartitionUpdate. The
     * associated operation blobs (in operations[i].data_offset, data_length)
     * should be stored contiguously and in the same order.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.InstallOperation operations = 8;</code>
     */
    int getOperationsCount();
    /**
     * <pre>
     * The list of operations to be performed to apply this PartitionUpdate. The
     * associated operation blobs (in operations[i].data_offset, data_length)
     * should be stored contiguously and in the same order.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.InstallOperation operations = 8;</code>
     */
    java.util.List<? extends chromeos_update_engine.UpdateMetadata.InstallOperationOrBuilder>
        getOperationsOrBuilderList();
    /**
     * <pre>
     * The list of operations to be performed to apply this PartitionUpdate. The
     * associated operation blobs (in operations[i].data_offset, data_length)
     * should be stored contiguously and in the same order.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.InstallOperation operations = 8;</code>
     */
    chromeos_update_engine.UpdateMetadata.InstallOperationOrBuilder getOperationsOrBuilder(
        int index);

    /**
     * <pre>
     * Whether a failure in the postinstall step for this partition should be
     * ignored.
     * </pre>
     *
     * <code>optional bool postinstall_optional = 9;</code>
     * @return Whether the postinstallOptional field is set.
     */
    boolean hasPostinstallOptional();
    /**
     * <pre>
     * Whether a failure in the postinstall step for this partition should be
     * ignored.
     * </pre>
     *
     * <code>optional bool postinstall_optional = 9;</code>
     * @return The postinstallOptional.
     */
    boolean getPostinstallOptional();

    /**
     * <pre>
     * The extent for data covered by verity hash tree.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.Extent hash_tree_data_extent = 10;</code>
     * @return Whether the hashTreeDataExtent field is set.
     */
    boolean hasHashTreeDataExtent();
    /**
     * <pre>
     * The extent for data covered by verity hash tree.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.Extent hash_tree_data_extent = 10;</code>
     * @return The hashTreeDataExtent.
     */
    chromeos_update_engine.UpdateMetadata.Extent getHashTreeDataExtent();
    /**
     * <pre>
     * The extent for data covered by verity hash tree.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.Extent hash_tree_data_extent = 10;</code>
     */
    chromeos_update_engine.UpdateMetadata.ExtentOrBuilder getHashTreeDataExtentOrBuilder();

    /**
     * <pre>
     * The extent to store verity hash tree.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.Extent hash_tree_extent = 11;</code>
     * @return Whether the hashTreeExtent field is set.
     */
    boolean hasHashTreeExtent();
    /**
     * <pre>
     * The extent to store verity hash tree.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.Extent hash_tree_extent = 11;</code>
     * @return The hashTreeExtent.
     */
    chromeos_update_engine.UpdateMetadata.Extent getHashTreeExtent();
    /**
     * <pre>
     * The extent to store verity hash tree.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.Extent hash_tree_extent = 11;</code>
     */
    chromeos_update_engine.UpdateMetadata.ExtentOrBuilder getHashTreeExtentOrBuilder();

    /**
     * <pre>
     * The hash algorithm used in verity hash tree.
     * </pre>
     *
     * <code>optional string hash_tree_algorithm = 12;</code>
     * @return Whether the hashTreeAlgorithm field is set.
     */
    boolean hasHashTreeAlgorithm();
    /**
     * <pre>
     * The hash algorithm used in verity hash tree.
     * </pre>
     *
     * <code>optional string hash_tree_algorithm = 12;</code>
     * @return The hashTreeAlgorithm.
     */
    java.lang.String getHashTreeAlgorithm();
    /**
     * <pre>
     * The hash algorithm used in verity hash tree.
     * </pre>
     *
     * <code>optional string hash_tree_algorithm = 12;</code>
     * @return The bytes for hashTreeAlgorithm.
     */
    com.google.protobuf.ByteString
        getHashTreeAlgorithmBytes();

    /**
     * <pre>
     * The salt used for verity hash tree.
     * </pre>
     *
     * <code>optional bytes hash_tree_salt = 13;</code>
     * @return Whether the hashTreeSalt field is set.
     */
    boolean hasHashTreeSalt();
    /**
     * <pre>
     * The salt used for verity hash tree.
     * </pre>
     *
     * <code>optional bytes hash_tree_salt = 13;</code>
     * @return The hashTreeSalt.
     */
    com.google.protobuf.ByteString getHashTreeSalt();

    /**
     * <pre>
     * The extent for data covered by FEC.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.Extent fec_data_extent = 14;</code>
     * @return Whether the fecDataExtent field is set.
     */
    boolean hasFecDataExtent();
    /**
     * <pre>
     * The extent for data covered by FEC.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.Extent fec_data_extent = 14;</code>
     * @return The fecDataExtent.
     */
    chromeos_update_engine.UpdateMetadata.Extent getFecDataExtent();
    /**
     * <pre>
     * The extent for data covered by FEC.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.Extent fec_data_extent = 14;</code>
     */
    chromeos_update_engine.UpdateMetadata.ExtentOrBuilder getFecDataExtentOrBuilder();

    /**
     * <pre>
     * The extent to store FEC.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.Extent fec_extent = 15;</code>
     * @return Whether the fecExtent field is set.
     */
    boolean hasFecExtent();
    /**
     * <pre>
     * The extent to store FEC.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.Extent fec_extent = 15;</code>
     * @return The fecExtent.
     */
    chromeos_update_engine.UpdateMetadata.Extent getFecExtent();
    /**
     * <pre>
     * The extent to store FEC.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.Extent fec_extent = 15;</code>
     */
    chromeos_update_engine.UpdateMetadata.ExtentOrBuilder getFecExtentOrBuilder();

    /**
     * <pre>
     * The number of FEC roots.
     * </pre>
     *
     * <code>optional uint32 fec_roots = 16 [default = 2];</code>
     * @return Whether the fecRoots field is set.
     */
    boolean hasFecRoots();
    /**
     * <pre>
     * The number of FEC roots.
     * </pre>
     *
     * <code>optional uint32 fec_roots = 16 [default = 2];</code>
     * @return The fecRoots.
     */
    int getFecRoots();
  }
  /**
   * <pre>
   * Describes the update to apply to a single partition.
   * </pre>
   *
   * Protobuf type {@code chromeos_update_engine.PartitionUpdate}
   */
  public static final class PartitionUpdate extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:chromeos_update_engine.PartitionUpdate)
      PartitionUpdateOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use PartitionUpdate.newBuilder() to construct.
    private PartitionUpdate(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private PartitionUpdate() {
      partitionName_ = "";
      postinstallPath_ = "";
      filesystemType_ = "";
      newPartitionSignature_ = java.util.Collections.emptyList();
      operations_ = java.util.Collections.emptyList();
      hashTreeAlgorithm_ = "";
      hashTreeSalt_ = com.google.protobuf.ByteString.EMPTY;
      fecRoots_ = 2;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new PartitionUpdate();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private PartitionUpdate(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              partitionName_ = bs;
              break;
            }
            case 16: {
              bitField0_ |= 0x00000002;
              runPostinstall_ = input.readBool();
              break;
            }
            case 26: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000004;
              postinstallPath_ = bs;
              break;
            }
            case 34: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000008;
              filesystemType_ = bs;
              break;
            }
            case 42: {
              if (!((mutable_bitField0_ & 0x00000010) != 0)) {
                newPartitionSignature_ = new java.util.ArrayList<chromeos_update_engine.UpdateMetadata.Signatures.Signature>();
                mutable_bitField0_ |= 0x00000010;
              }
              newPartitionSignature_.add(
                  input.readMessage(chromeos_update_engine.UpdateMetadata.Signatures.Signature.PARSER, extensionRegistry));
              break;
            }
            case 50: {
              chromeos_update_engine.UpdateMetadata.PartitionInfo.Builder subBuilder = null;
              if (((bitField0_ & 0x00000010) != 0)) {
                subBuilder = oldPartitionInfo_.toBuilder();
              }
              oldPartitionInfo_ = input.readMessage(chromeos_update_engine.UpdateMetadata.PartitionInfo.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(oldPartitionInfo_);
                oldPartitionInfo_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000010;
              break;
            }
            case 58: {
              chromeos_update_engine.UpdateMetadata.PartitionInfo.Builder subBuilder = null;
              if (((bitField0_ & 0x00000020) != 0)) {
                subBuilder = newPartitionInfo_.toBuilder();
              }
              newPartitionInfo_ = input.readMessage(chromeos_update_engine.UpdateMetadata.PartitionInfo.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(newPartitionInfo_);
                newPartitionInfo_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000020;
              break;
            }
            case 66: {
              if (!((mutable_bitField0_ & 0x00000080) != 0)) {
                operations_ = new java.util.ArrayList<chromeos_update_engine.UpdateMetadata.InstallOperation>();
                mutable_bitField0_ |= 0x00000080;
              }
              operations_.add(
                  input.readMessage(chromeos_update_engine.UpdateMetadata.InstallOperation.PARSER, extensionRegistry));
              break;
            }
            case 72: {
              bitField0_ |= 0x00000040;
              postinstallOptional_ = input.readBool();
              break;
            }
            case 82: {
              chromeos_update_engine.UpdateMetadata.Extent.Builder subBuilder = null;
              if (((bitField0_ & 0x00000080) != 0)) {
                subBuilder = hashTreeDataExtent_.toBuilder();
              }
              hashTreeDataExtent_ = input.readMessage(chromeos_update_engine.UpdateMetadata.Extent.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(hashTreeDataExtent_);
                hashTreeDataExtent_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000080;
              break;
            }
            case 90: {
              chromeos_update_engine.UpdateMetadata.Extent.Builder subBuilder = null;
              if (((bitField0_ & 0x00000100) != 0)) {
                subBuilder = hashTreeExtent_.toBuilder();
              }
              hashTreeExtent_ = input.readMessage(chromeos_update_engine.UpdateMetadata.Extent.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(hashTreeExtent_);
                hashTreeExtent_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000100;
              break;
            }
            case 98: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000200;
              hashTreeAlgorithm_ = bs;
              break;
            }
            case 106: {
              bitField0_ |= 0x00000400;
              hashTreeSalt_ = input.readBytes();
              break;
            }
            case 114: {
              chromeos_update_engine.UpdateMetadata.Extent.Builder subBuilder = null;
              if (((bitField0_ & 0x00000800) != 0)) {
                subBuilder = fecDataExtent_.toBuilder();
              }
              fecDataExtent_ = input.readMessage(chromeos_update_engine.UpdateMetadata.Extent.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(fecDataExtent_);
                fecDataExtent_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000800;
              break;
            }
            case 122: {
              chromeos_update_engine.UpdateMetadata.Extent.Builder subBuilder = null;
              if (((bitField0_ & 0x00001000) != 0)) {
                subBuilder = fecExtent_.toBuilder();
              }
              fecExtent_ = input.readMessage(chromeos_update_engine.UpdateMetadata.Extent.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(fecExtent_);
                fecExtent_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00001000;
              break;
            }
            case 128: {
              bitField0_ |= 0x00002000;
              fecRoots_ = input.readUInt32();
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000010) != 0)) {
          newPartitionSignature_ = java.util.Collections.unmodifiableList(newPartitionSignature_);
        }
        if (((mutable_bitField0_ & 0x00000080) != 0)) {
          operations_ = java.util.Collections.unmodifiableList(operations_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_PartitionUpdate_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_PartitionUpdate_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              chromeos_update_engine.UpdateMetadata.PartitionUpdate.class, chromeos_update_engine.UpdateMetadata.PartitionUpdate.Builder.class);
    }

    private int bitField0_;
    public static final int PARTITION_NAME_FIELD_NUMBER = 1;
    private volatile java.lang.Object partitionName_;
    /**
     * <pre>
     * A platform-specific name to identify the partition set being updated. For
     * example, in Chrome OS this could be "ROOT" or "KERNEL".
     * </pre>
     *
     * <code>required string partition_name = 1;</code>
     * @return Whether the partitionName field is set.
     */
    @java.lang.Override
    public boolean hasPartitionName() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * A platform-specific name to identify the partition set being updated. For
     * example, in Chrome OS this could be "ROOT" or "KERNEL".
     * </pre>
     *
     * <code>required string partition_name = 1;</code>
     * @return The partitionName.
     */
    @java.lang.Override
    public java.lang.String getPartitionName() {
      java.lang.Object ref = partitionName_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          partitionName_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * A platform-specific name to identify the partition set being updated. For
     * example, in Chrome OS this could be "ROOT" or "KERNEL".
     * </pre>
     *
     * <code>required string partition_name = 1;</code>
     * @return The bytes for partitionName.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getPartitionNameBytes() {
      java.lang.Object ref = partitionName_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        partitionName_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int RUN_POSTINSTALL_FIELD_NUMBER = 2;
    private boolean runPostinstall_;
    /**
     * <pre>
     * Whether this partition carries a filesystem with post-install program that
     * must be run to finalize the update process. See also |postinstall_path| and
     * |filesystem_type|.
     * </pre>
     *
     * <code>optional bool run_postinstall = 2;</code>
     * @return Whether the runPostinstall field is set.
     */
    @java.lang.Override
    public boolean hasRunPostinstall() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Whether this partition carries a filesystem with post-install program that
     * must be run to finalize the update process. See also |postinstall_path| and
     * |filesystem_type|.
     * </pre>
     *
     * <code>optional bool run_postinstall = 2;</code>
     * @return The runPostinstall.
     */
    @java.lang.Override
    public boolean getRunPostinstall() {
      return runPostinstall_;
    }

    public static final int POSTINSTALL_PATH_FIELD_NUMBER = 3;
    private volatile java.lang.Object postinstallPath_;
    /**
     * <pre>
     * The path of the executable program to run during the post-install step,
     * relative to the root of this filesystem. If not set, the default "postinst"
     * will be used. This setting is only used when |run_postinstall| is set and
     * true.
     * </pre>
     *
     * <code>optional string postinstall_path = 3;</code>
     * @return Whether the postinstallPath field is set.
     */
    @java.lang.Override
    public boolean hasPostinstallPath() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * The path of the executable program to run during the post-install step,
     * relative to the root of this filesystem. If not set, the default "postinst"
     * will be used. This setting is only used when |run_postinstall| is set and
     * true.
     * </pre>
     *
     * <code>optional string postinstall_path = 3;</code>
     * @return The postinstallPath.
     */
    @java.lang.Override
    public java.lang.String getPostinstallPath() {
      java.lang.Object ref = postinstallPath_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          postinstallPath_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The path of the executable program to run during the post-install step,
     * relative to the root of this filesystem. If not set, the default "postinst"
     * will be used. This setting is only used when |run_postinstall| is set and
     * true.
     * </pre>
     *
     * <code>optional string postinstall_path = 3;</code>
     * @return The bytes for postinstallPath.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getPostinstallPathBytes() {
      java.lang.Object ref = postinstallPath_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        postinstallPath_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int FILESYSTEM_TYPE_FIELD_NUMBER = 4;
    private volatile java.lang.Object filesystemType_;
    /**
     * <pre>
     * The filesystem type as passed to the mount(2) syscall when mounting the new
     * filesystem to run the post-install program. If not set, a fixed list of
     * filesystems will be attempted. This setting is only used if
     * |run_postinstall| is set and true.
     * </pre>
     *
     * <code>optional string filesystem_type = 4;</code>
     * @return Whether the filesystemType field is set.
     */
    @java.lang.Override
    public boolean hasFilesystemType() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * The filesystem type as passed to the mount(2) syscall when mounting the new
     * filesystem to run the post-install program. If not set, a fixed list of
     * filesystems will be attempted. This setting is only used if
     * |run_postinstall| is set and true.
     * </pre>
     *
     * <code>optional string filesystem_type = 4;</code>
     * @return The filesystemType.
     */
    @java.lang.Override
    public java.lang.String getFilesystemType() {
      java.lang.Object ref = filesystemType_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          filesystemType_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The filesystem type as passed to the mount(2) syscall when mounting the new
     * filesystem to run the post-install program. If not set, a fixed list of
     * filesystems will be attempted. This setting is only used if
     * |run_postinstall| is set and true.
     * </pre>
     *
     * <code>optional string filesystem_type = 4;</code>
     * @return The bytes for filesystemType.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getFilesystemTypeBytes() {
      java.lang.Object ref = filesystemType_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        filesystemType_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int NEW_PARTITION_SIGNATURE_FIELD_NUMBER = 5;
    private java.util.List<chromeos_update_engine.UpdateMetadata.Signatures.Signature> newPartitionSignature_;
    /**
     * <pre>
     * If present, a list of signatures of the new_partition_info.hash signed with
     * different keys. If the update_engine daemon requires vendor-signed images
     * and has its public key installed, one of the signatures should be valid
     * for /postinstall to run.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;</code>
     */
    @java.lang.Override
    public java.util.List<chromeos_update_engine.UpdateMetadata.Signatures.Signature> getNewPartitionSignatureList() {
      return newPartitionSignature_;
    }
    /**
     * <pre>
     * If present, a list of signatures of the new_partition_info.hash signed with
     * different keys. If the update_engine daemon requires vendor-signed images
     * and has its public key installed, one of the signatures should be valid
     * for /postinstall to run.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;</code>
     */
    @java.lang.Override
    public java.util.List<? extends chromeos_update_engine.UpdateMetadata.Signatures.SignatureOrBuilder>
        getNewPartitionSignatureOrBuilderList() {
      return newPartitionSignature_;
    }
    /**
     * <pre>
     * If present, a list of signatures of the new_partition_info.hash signed with
     * different keys. If the update_engine daemon requires vendor-signed images
     * and has its public key installed, one of the signatures should be valid
     * for /postinstall to run.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;</code>
     */
    @java.lang.Override
    public int getNewPartitionSignatureCount() {
      return newPartitionSignature_.size();
    }
    /**
     * <pre>
     * If present, a list of signatures of the new_partition_info.hash signed with
     * different keys. If the update_engine daemon requires vendor-signed images
     * and has its public key installed, one of the signatures should be valid
     * for /postinstall to run.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.Signatures.Signature getNewPartitionSignature(int index) {
      return newPartitionSignature_.get(index);
    }
    /**
     * <pre>
     * If present, a list of signatures of the new_partition_info.hash signed with
     * different keys. If the update_engine daemon requires vendor-signed images
     * and has its public key installed, one of the signatures should be valid
     * for /postinstall to run.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.Signatures.SignatureOrBuilder getNewPartitionSignatureOrBuilder(
        int index) {
      return newPartitionSignature_.get(index);
    }

    public static final int OLD_PARTITION_INFO_FIELD_NUMBER = 6;
    private chromeos_update_engine.UpdateMetadata.PartitionInfo oldPartitionInfo_;
    /**
     * <code>optional .chromeos_update_engine.PartitionInfo old_partition_info = 6;</code>
     * @return Whether the oldPartitionInfo field is set.
     */
    @java.lang.Override
    public boolean hasOldPartitionInfo() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <code>optional .chromeos_update_engine.PartitionInfo old_partition_info = 6;</code>
     * @return The oldPartitionInfo.
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.PartitionInfo getOldPartitionInfo() {
      return oldPartitionInfo_ == null ? chromeos_update_engine.UpdateMetadata.PartitionInfo.getDefaultInstance() : oldPartitionInfo_;
    }
    /**
     * <code>optional .chromeos_update_engine.PartitionInfo old_partition_info = 6;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.PartitionInfoOrBuilder getOldPartitionInfoOrBuilder() {
      return oldPartitionInfo_ == null ? chromeos_update_engine.UpdateMetadata.PartitionInfo.getDefaultInstance() : oldPartitionInfo_;
    }

    public static final int NEW_PARTITION_INFO_FIELD_NUMBER = 7;
    private chromeos_update_engine.UpdateMetadata.PartitionInfo newPartitionInfo_;
    /**
     * <code>optional .chromeos_update_engine.PartitionInfo new_partition_info = 7;</code>
     * @return Whether the newPartitionInfo field is set.
     */
    @java.lang.Override
    public boolean hasNewPartitionInfo() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <code>optional .chromeos_update_engine.PartitionInfo new_partition_info = 7;</code>
     * @return The newPartitionInfo.
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.PartitionInfo getNewPartitionInfo() {
      return newPartitionInfo_ == null ? chromeos_update_engine.UpdateMetadata.PartitionInfo.getDefaultInstance() : newPartitionInfo_;
    }
    /**
     * <code>optional .chromeos_update_engine.PartitionInfo new_partition_info = 7;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.PartitionInfoOrBuilder getNewPartitionInfoOrBuilder() {
      return newPartitionInfo_ == null ? chromeos_update_engine.UpdateMetadata.PartitionInfo.getDefaultInstance() : newPartitionInfo_;
    }

    public static final int OPERATIONS_FIELD_NUMBER = 8;
    private java.util.List<chromeos_update_engine.UpdateMetadata.InstallOperation> operations_;
    /**
     * <pre>
     * The list of operations to be performed to apply this PartitionUpdate. The
     * associated operation blobs (in operations[i].data_offset, data_length)
     * should be stored contiguously and in the same order.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.InstallOperation operations = 8;</code>
     */
    @java.lang.Override
    public java.util.List<chromeos_update_engine.UpdateMetadata.InstallOperation> getOperationsList() {
      return operations_;
    }
    /**
     * <pre>
     * The list of operations to be performed to apply this PartitionUpdate. The
     * associated operation blobs (in operations[i].data_offset, data_length)
     * should be stored contiguously and in the same order.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.InstallOperation operations = 8;</code>
     */
    @java.lang.Override
    public java.util.List<? extends chromeos_update_engine.UpdateMetadata.InstallOperationOrBuilder>
        getOperationsOrBuilderList() {
      return operations_;
    }
    /**
     * <pre>
     * The list of operations to be performed to apply this PartitionUpdate. The
     * associated operation blobs (in operations[i].data_offset, data_length)
     * should be stored contiguously and in the same order.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.InstallOperation operations = 8;</code>
     */
    @java.lang.Override
    public int getOperationsCount() {
      return operations_.size();
    }
    /**
     * <pre>
     * The list of operations to be performed to apply this PartitionUpdate. The
     * associated operation blobs (in operations[i].data_offset, data_length)
     * should be stored contiguously and in the same order.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.InstallOperation operations = 8;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.InstallOperation getOperations(int index) {
      return operations_.get(index);
    }
    /**
     * <pre>
     * The list of operations to be performed to apply this PartitionUpdate. The
     * associated operation blobs (in operations[i].data_offset, data_length)
     * should be stored contiguously and in the same order.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.InstallOperation operations = 8;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.InstallOperationOrBuilder getOperationsOrBuilder(
        int index) {
      return operations_.get(index);
    }

    public static final int POSTINSTALL_OPTIONAL_FIELD_NUMBER = 9;
    private boolean postinstallOptional_;
    /**
     * <pre>
     * Whether a failure in the postinstall step for this partition should be
     * ignored.
     * </pre>
     *
     * <code>optional bool postinstall_optional = 9;</code>
     * @return Whether the postinstallOptional field is set.
     */
    @java.lang.Override
    public boolean hasPostinstallOptional() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * Whether a failure in the postinstall step for this partition should be
     * ignored.
     * </pre>
     *
     * <code>optional bool postinstall_optional = 9;</code>
     * @return The postinstallOptional.
     */
    @java.lang.Override
    public boolean getPostinstallOptional() {
      return postinstallOptional_;
    }

    public static final int HASH_TREE_DATA_EXTENT_FIELD_NUMBER = 10;
    private chromeos_update_engine.UpdateMetadata.Extent hashTreeDataExtent_;
    /**
     * <pre>
     * The extent for data covered by verity hash tree.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.Extent hash_tree_data_extent = 10;</code>
     * @return Whether the hashTreeDataExtent field is set.
     */
    @java.lang.Override
    public boolean hasHashTreeDataExtent() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * The extent for data covered by verity hash tree.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.Extent hash_tree_data_extent = 10;</code>
     * @return The hashTreeDataExtent.
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.Extent getHashTreeDataExtent() {
      return hashTreeDataExtent_ == null ? chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance() : hashTreeDataExtent_;
    }
    /**
     * <pre>
     * The extent for data covered by verity hash tree.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.Extent hash_tree_data_extent = 10;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.ExtentOrBuilder getHashTreeDataExtentOrBuilder() {
      return hashTreeDataExtent_ == null ? chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance() : hashTreeDataExtent_;
    }

    public static final int HASH_TREE_EXTENT_FIELD_NUMBER = 11;
    private chromeos_update_engine.UpdateMetadata.Extent hashTreeExtent_;
    /**
     * <pre>
     * The extent to store verity hash tree.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.Extent hash_tree_extent = 11;</code>
     * @return Whether the hashTreeExtent field is set.
     */
    @java.lang.Override
    public boolean hasHashTreeExtent() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     * <pre>
     * The extent to store verity hash tree.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.Extent hash_tree_extent = 11;</code>
     * @return The hashTreeExtent.
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.Extent getHashTreeExtent() {
      return hashTreeExtent_ == null ? chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance() : hashTreeExtent_;
    }
    /**
     * <pre>
     * The extent to store verity hash tree.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.Extent hash_tree_extent = 11;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.ExtentOrBuilder getHashTreeExtentOrBuilder() {
      return hashTreeExtent_ == null ? chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance() : hashTreeExtent_;
    }

    public static final int HASH_TREE_ALGORITHM_FIELD_NUMBER = 12;
    private volatile java.lang.Object hashTreeAlgorithm_;
    /**
     * <pre>
     * The hash algorithm used in verity hash tree.
     * </pre>
     *
     * <code>optional string hash_tree_algorithm = 12;</code>
     * @return Whether the hashTreeAlgorithm field is set.
     */
    @java.lang.Override
    public boolean hasHashTreeAlgorithm() {
      return ((bitField0_ & 0x00000200) != 0);
    }
    /**
     * <pre>
     * The hash algorithm used in verity hash tree.
     * </pre>
     *
     * <code>optional string hash_tree_algorithm = 12;</code>
     * @return The hashTreeAlgorithm.
     */
    @java.lang.Override
    public java.lang.String getHashTreeAlgorithm() {
      java.lang.Object ref = hashTreeAlgorithm_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          hashTreeAlgorithm_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The hash algorithm used in verity hash tree.
     * </pre>
     *
     * <code>optional string hash_tree_algorithm = 12;</code>
     * @return The bytes for hashTreeAlgorithm.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getHashTreeAlgorithmBytes() {
      java.lang.Object ref = hashTreeAlgorithm_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        hashTreeAlgorithm_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int HASH_TREE_SALT_FIELD_NUMBER = 13;
    private com.google.protobuf.ByteString hashTreeSalt_;
    /**
     * <pre>
     * The salt used for verity hash tree.
     * </pre>
     *
     * <code>optional bytes hash_tree_salt = 13;</code>
     * @return Whether the hashTreeSalt field is set.
     */
    @java.lang.Override
    public boolean hasHashTreeSalt() {
      return ((bitField0_ & 0x00000400) != 0);
    }
    /**
     * <pre>
     * The salt used for verity hash tree.
     * </pre>
     *
     * <code>optional bytes hash_tree_salt = 13;</code>
     * @return The hashTreeSalt.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getHashTreeSalt() {
      return hashTreeSalt_;
    }

    public static final int FEC_DATA_EXTENT_FIELD_NUMBER = 14;
    private chromeos_update_engine.UpdateMetadata.Extent fecDataExtent_;
    /**
     * <pre>
     * The extent for data covered by FEC.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.Extent fec_data_extent = 14;</code>
     * @return Whether the fecDataExtent field is set.
     */
    @java.lang.Override
    public boolean hasFecDataExtent() {
      return ((bitField0_ & 0x00000800) != 0);
    }
    /**
     * <pre>
     * The extent for data covered by FEC.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.Extent fec_data_extent = 14;</code>
     * @return The fecDataExtent.
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.Extent getFecDataExtent() {
      return fecDataExtent_ == null ? chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance() : fecDataExtent_;
    }
    /**
     * <pre>
     * The extent for data covered by FEC.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.Extent fec_data_extent = 14;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.ExtentOrBuilder getFecDataExtentOrBuilder() {
      return fecDataExtent_ == null ? chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance() : fecDataExtent_;
    }

    public static final int FEC_EXTENT_FIELD_NUMBER = 15;
    private chromeos_update_engine.UpdateMetadata.Extent fecExtent_;
    /**
     * <pre>
     * The extent to store FEC.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.Extent fec_extent = 15;</code>
     * @return Whether the fecExtent field is set.
     */
    @java.lang.Override
    public boolean hasFecExtent() {
      return ((bitField0_ & 0x00001000) != 0);
    }
    /**
     * <pre>
     * The extent to store FEC.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.Extent fec_extent = 15;</code>
     * @return The fecExtent.
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.Extent getFecExtent() {
      return fecExtent_ == null ? chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance() : fecExtent_;
    }
    /**
     * <pre>
     * The extent to store FEC.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.Extent fec_extent = 15;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.ExtentOrBuilder getFecExtentOrBuilder() {
      return fecExtent_ == null ? chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance() : fecExtent_;
    }

    public static final int FEC_ROOTS_FIELD_NUMBER = 16;
    private int fecRoots_;
    /**
     * <pre>
     * The number of FEC roots.
     * </pre>
     *
     * <code>optional uint32 fec_roots = 16 [default = 2];</code>
     * @return Whether the fecRoots field is set.
     */
    @java.lang.Override
    public boolean hasFecRoots() {
      return ((bitField0_ & 0x00002000) != 0);
    }
    /**
     * <pre>
     * The number of FEC roots.
     * </pre>
     *
     * <code>optional uint32 fec_roots = 16 [default = 2];</code>
     * @return The fecRoots.
     */
    @java.lang.Override
    public int getFecRoots() {
      return fecRoots_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (!hasPartitionName()) {
        memoizedIsInitialized = 0;
        return false;
      }
      for (int i = 0; i < getOperationsCount(); i++) {
        if (!getOperations(i).isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, partitionName_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeBool(2, runPostinstall_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, postinstallPath_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 4, filesystemType_);
      }
      for (int i = 0; i < newPartitionSignature_.size(); i++) {
        output.writeMessage(5, newPartitionSignature_.get(i));
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeMessage(6, getOldPartitionInfo());
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        output.writeMessage(7, getNewPartitionInfo());
      }
      for (int i = 0; i < operations_.size(); i++) {
        output.writeMessage(8, operations_.get(i));
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        output.writeBool(9, postinstallOptional_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        output.writeMessage(10, getHashTreeDataExtent());
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        output.writeMessage(11, getHashTreeExtent());
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 12, hashTreeAlgorithm_);
      }
      if (((bitField0_ & 0x00000400) != 0)) {
        output.writeBytes(13, hashTreeSalt_);
      }
      if (((bitField0_ & 0x00000800) != 0)) {
        output.writeMessage(14, getFecDataExtent());
      }
      if (((bitField0_ & 0x00001000) != 0)) {
        output.writeMessage(15, getFecExtent());
      }
      if (((bitField0_ & 0x00002000) != 0)) {
        output.writeUInt32(16, fecRoots_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, partitionName_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(2, runPostinstall_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, postinstallPath_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, filesystemType_);
      }
      for (int i = 0; i < newPartitionSignature_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, newPartitionSignature_.get(i));
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(6, getOldPartitionInfo());
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(7, getNewPartitionInfo());
      }
      for (int i = 0; i < operations_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(8, operations_.get(i));
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(9, postinstallOptional_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(10, getHashTreeDataExtent());
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(11, getHashTreeExtent());
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(12, hashTreeAlgorithm_);
      }
      if (((bitField0_ & 0x00000400) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(13, hashTreeSalt_);
      }
      if (((bitField0_ & 0x00000800) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(14, getFecDataExtent());
      }
      if (((bitField0_ & 0x00001000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(15, getFecExtent());
      }
      if (((bitField0_ & 0x00002000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(16, fecRoots_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof chromeos_update_engine.UpdateMetadata.PartitionUpdate)) {
        return super.equals(obj);
      }
      chromeos_update_engine.UpdateMetadata.PartitionUpdate other = (chromeos_update_engine.UpdateMetadata.PartitionUpdate) obj;

      if (hasPartitionName() != other.hasPartitionName()) return false;
      if (hasPartitionName()) {
        if (!getPartitionName()
            .equals(other.getPartitionName())) return false;
      }
      if (hasRunPostinstall() != other.hasRunPostinstall()) return false;
      if (hasRunPostinstall()) {
        if (getRunPostinstall()
            != other.getRunPostinstall()) return false;
      }
      if (hasPostinstallPath() != other.hasPostinstallPath()) return false;
      if (hasPostinstallPath()) {
        if (!getPostinstallPath()
            .equals(other.getPostinstallPath())) return false;
      }
      if (hasFilesystemType() != other.hasFilesystemType()) return false;
      if (hasFilesystemType()) {
        if (!getFilesystemType()
            .equals(other.getFilesystemType())) return false;
      }
      if (!getNewPartitionSignatureList()
          .equals(other.getNewPartitionSignatureList())) return false;
      if (hasOldPartitionInfo() != other.hasOldPartitionInfo()) return false;
      if (hasOldPartitionInfo()) {
        if (!getOldPartitionInfo()
            .equals(other.getOldPartitionInfo())) return false;
      }
      if (hasNewPartitionInfo() != other.hasNewPartitionInfo()) return false;
      if (hasNewPartitionInfo()) {
        if (!getNewPartitionInfo()
            .equals(other.getNewPartitionInfo())) return false;
      }
      if (!getOperationsList()
          .equals(other.getOperationsList())) return false;
      if (hasPostinstallOptional() != other.hasPostinstallOptional()) return false;
      if (hasPostinstallOptional()) {
        if (getPostinstallOptional()
            != other.getPostinstallOptional()) return false;
      }
      if (hasHashTreeDataExtent() != other.hasHashTreeDataExtent()) return false;
      if (hasHashTreeDataExtent()) {
        if (!getHashTreeDataExtent()
            .equals(other.getHashTreeDataExtent())) return false;
      }
      if (hasHashTreeExtent() != other.hasHashTreeExtent()) return false;
      if (hasHashTreeExtent()) {
        if (!getHashTreeExtent()
            .equals(other.getHashTreeExtent())) return false;
      }
      if (hasHashTreeAlgorithm() != other.hasHashTreeAlgorithm()) return false;
      if (hasHashTreeAlgorithm()) {
        if (!getHashTreeAlgorithm()
            .equals(other.getHashTreeAlgorithm())) return false;
      }
      if (hasHashTreeSalt() != other.hasHashTreeSalt()) return false;
      if (hasHashTreeSalt()) {
        if (!getHashTreeSalt()
            .equals(other.getHashTreeSalt())) return false;
      }
      if (hasFecDataExtent() != other.hasFecDataExtent()) return false;
      if (hasFecDataExtent()) {
        if (!getFecDataExtent()
            .equals(other.getFecDataExtent())) return false;
      }
      if (hasFecExtent() != other.hasFecExtent()) return false;
      if (hasFecExtent()) {
        if (!getFecExtent()
            .equals(other.getFecExtent())) return false;
      }
      if (hasFecRoots() != other.hasFecRoots()) return false;
      if (hasFecRoots()) {
        if (getFecRoots()
            != other.getFecRoots()) return false;
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasPartitionName()) {
        hash = (37 * hash) + PARTITION_NAME_FIELD_NUMBER;
        hash = (53 * hash) + getPartitionName().hashCode();
      }
      if (hasRunPostinstall()) {
        hash = (37 * hash) + RUN_POSTINSTALL_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getRunPostinstall());
      }
      if (hasPostinstallPath()) {
        hash = (37 * hash) + POSTINSTALL_PATH_FIELD_NUMBER;
        hash = (53 * hash) + getPostinstallPath().hashCode();
      }
      if (hasFilesystemType()) {
        hash = (37 * hash) + FILESYSTEM_TYPE_FIELD_NUMBER;
        hash = (53 * hash) + getFilesystemType().hashCode();
      }
      if (getNewPartitionSignatureCount() > 0) {
        hash = (37 * hash) + NEW_PARTITION_SIGNATURE_FIELD_NUMBER;
        hash = (53 * hash) + getNewPartitionSignatureList().hashCode();
      }
      if (hasOldPartitionInfo()) {
        hash = (37 * hash) + OLD_PARTITION_INFO_FIELD_NUMBER;
        hash = (53 * hash) + getOldPartitionInfo().hashCode();
      }
      if (hasNewPartitionInfo()) {
        hash = (37 * hash) + NEW_PARTITION_INFO_FIELD_NUMBER;
        hash = (53 * hash) + getNewPartitionInfo().hashCode();
      }
      if (getOperationsCount() > 0) {
        hash = (37 * hash) + OPERATIONS_FIELD_NUMBER;
        hash = (53 * hash) + getOperationsList().hashCode();
      }
      if (hasPostinstallOptional()) {
        hash = (37 * hash) + POSTINSTALL_OPTIONAL_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getPostinstallOptional());
      }
      if (hasHashTreeDataExtent()) {
        hash = (37 * hash) + HASH_TREE_DATA_EXTENT_FIELD_NUMBER;
        hash = (53 * hash) + getHashTreeDataExtent().hashCode();
      }
      if (hasHashTreeExtent()) {
        hash = (37 * hash) + HASH_TREE_EXTENT_FIELD_NUMBER;
        hash = (53 * hash) + getHashTreeExtent().hashCode();
      }
      if (hasHashTreeAlgorithm()) {
        hash = (37 * hash) + HASH_TREE_ALGORITHM_FIELD_NUMBER;
        hash = (53 * hash) + getHashTreeAlgorithm().hashCode();
      }
      if (hasHashTreeSalt()) {
        hash = (37 * hash) + HASH_TREE_SALT_FIELD_NUMBER;
        hash = (53 * hash) + getHashTreeSalt().hashCode();
      }
      if (hasFecDataExtent()) {
        hash = (37 * hash) + FEC_DATA_EXTENT_FIELD_NUMBER;
        hash = (53 * hash) + getFecDataExtent().hashCode();
      }
      if (hasFecExtent()) {
        hash = (37 * hash) + FEC_EXTENT_FIELD_NUMBER;
        hash = (53 * hash) + getFecExtent().hashCode();
      }
      if (hasFecRoots()) {
        hash = (37 * hash) + FEC_ROOTS_FIELD_NUMBER;
        hash = (53 * hash) + getFecRoots();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static chromeos_update_engine.UpdateMetadata.PartitionUpdate parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.PartitionUpdate parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.PartitionUpdate parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.PartitionUpdate parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.PartitionUpdate parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.PartitionUpdate parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.PartitionUpdate parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.PartitionUpdate parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.PartitionUpdate parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.PartitionUpdate parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.PartitionUpdate parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.PartitionUpdate parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(chromeos_update_engine.UpdateMetadata.PartitionUpdate prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Describes the update to apply to a single partition.
     * </pre>
     *
     * Protobuf type {@code chromeos_update_engine.PartitionUpdate}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:chromeos_update_engine.PartitionUpdate)
        chromeos_update_engine.UpdateMetadata.PartitionUpdateOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_PartitionUpdate_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_PartitionUpdate_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                chromeos_update_engine.UpdateMetadata.PartitionUpdate.class, chromeos_update_engine.UpdateMetadata.PartitionUpdate.Builder.class);
      }

      // Construct using chromeos_update_engine.UpdateMetadata.PartitionUpdate.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getNewPartitionSignatureFieldBuilder();
          getOldPartitionInfoFieldBuilder();
          getNewPartitionInfoFieldBuilder();
          getOperationsFieldBuilder();
          getHashTreeDataExtentFieldBuilder();
          getHashTreeExtentFieldBuilder();
          getFecDataExtentFieldBuilder();
          getFecExtentFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        partitionName_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        runPostinstall_ = false;
        bitField0_ = (bitField0_ & ~0x00000002);
        postinstallPath_ = "";
        bitField0_ = (bitField0_ & ~0x00000004);
        filesystemType_ = "";
        bitField0_ = (bitField0_ & ~0x00000008);
        if (newPartitionSignatureBuilder_ == null) {
          newPartitionSignature_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000010);
        } else {
          newPartitionSignatureBuilder_.clear();
        }
        if (oldPartitionInfoBuilder_ == null) {
          oldPartitionInfo_ = null;
        } else {
          oldPartitionInfoBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000020);
        if (newPartitionInfoBuilder_ == null) {
          newPartitionInfo_ = null;
        } else {
          newPartitionInfoBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000040);
        if (operationsBuilder_ == null) {
          operations_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000080);
        } else {
          operationsBuilder_.clear();
        }
        postinstallOptional_ = false;
        bitField0_ = (bitField0_ & ~0x00000100);
        if (hashTreeDataExtentBuilder_ == null) {
          hashTreeDataExtent_ = null;
        } else {
          hashTreeDataExtentBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000200);
        if (hashTreeExtentBuilder_ == null) {
          hashTreeExtent_ = null;
        } else {
          hashTreeExtentBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000400);
        hashTreeAlgorithm_ = "";
        bitField0_ = (bitField0_ & ~0x00000800);
        hashTreeSalt_ = com.google.protobuf.ByteString.EMPTY;
        bitField0_ = (bitField0_ & ~0x00001000);
        if (fecDataExtentBuilder_ == null) {
          fecDataExtent_ = null;
        } else {
          fecDataExtentBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00002000);
        if (fecExtentBuilder_ == null) {
          fecExtent_ = null;
        } else {
          fecExtentBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00004000);
        fecRoots_ = 2;
        bitField0_ = (bitField0_ & ~0x00008000);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_PartitionUpdate_descriptor;
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.PartitionUpdate getDefaultInstanceForType() {
        return chromeos_update_engine.UpdateMetadata.PartitionUpdate.getDefaultInstance();
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.PartitionUpdate build() {
        chromeos_update_engine.UpdateMetadata.PartitionUpdate result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.PartitionUpdate buildPartial() {
        chromeos_update_engine.UpdateMetadata.PartitionUpdate result = new chromeos_update_engine.UpdateMetadata.PartitionUpdate(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          to_bitField0_ |= 0x00000001;
        }
        result.partitionName_ = partitionName_;
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.runPostinstall_ = runPostinstall_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          to_bitField0_ |= 0x00000004;
        }
        result.postinstallPath_ = postinstallPath_;
        if (((from_bitField0_ & 0x00000008) != 0)) {
          to_bitField0_ |= 0x00000008;
        }
        result.filesystemType_ = filesystemType_;
        if (newPartitionSignatureBuilder_ == null) {
          if (((bitField0_ & 0x00000010) != 0)) {
            newPartitionSignature_ = java.util.Collections.unmodifiableList(newPartitionSignature_);
            bitField0_ = (bitField0_ & ~0x00000010);
          }
          result.newPartitionSignature_ = newPartitionSignature_;
        } else {
          result.newPartitionSignature_ = newPartitionSignatureBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          if (oldPartitionInfoBuilder_ == null) {
            result.oldPartitionInfo_ = oldPartitionInfo_;
          } else {
            result.oldPartitionInfo_ = oldPartitionInfoBuilder_.build();
          }
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          if (newPartitionInfoBuilder_ == null) {
            result.newPartitionInfo_ = newPartitionInfo_;
          } else {
            result.newPartitionInfo_ = newPartitionInfoBuilder_.build();
          }
          to_bitField0_ |= 0x00000020;
        }
        if (operationsBuilder_ == null) {
          if (((bitField0_ & 0x00000080) != 0)) {
            operations_ = java.util.Collections.unmodifiableList(operations_);
            bitField0_ = (bitField0_ & ~0x00000080);
          }
          result.operations_ = operations_;
        } else {
          result.operations_ = operationsBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000100) != 0)) {
          result.postinstallOptional_ = postinstallOptional_;
          to_bitField0_ |= 0x00000040;
        }
        if (((from_bitField0_ & 0x00000200) != 0)) {
          if (hashTreeDataExtentBuilder_ == null) {
            result.hashTreeDataExtent_ = hashTreeDataExtent_;
          } else {
            result.hashTreeDataExtent_ = hashTreeDataExtentBuilder_.build();
          }
          to_bitField0_ |= 0x00000080;
        }
        if (((from_bitField0_ & 0x00000400) != 0)) {
          if (hashTreeExtentBuilder_ == null) {
            result.hashTreeExtent_ = hashTreeExtent_;
          } else {
            result.hashTreeExtent_ = hashTreeExtentBuilder_.build();
          }
          to_bitField0_ |= 0x00000100;
        }
        if (((from_bitField0_ & 0x00000800) != 0)) {
          to_bitField0_ |= 0x00000200;
        }
        result.hashTreeAlgorithm_ = hashTreeAlgorithm_;
        if (((from_bitField0_ & 0x00001000) != 0)) {
          to_bitField0_ |= 0x00000400;
        }
        result.hashTreeSalt_ = hashTreeSalt_;
        if (((from_bitField0_ & 0x00002000) != 0)) {
          if (fecDataExtentBuilder_ == null) {
            result.fecDataExtent_ = fecDataExtent_;
          } else {
            result.fecDataExtent_ = fecDataExtentBuilder_.build();
          }
          to_bitField0_ |= 0x00000800;
        }
        if (((from_bitField0_ & 0x00004000) != 0)) {
          if (fecExtentBuilder_ == null) {
            result.fecExtent_ = fecExtent_;
          } else {
            result.fecExtent_ = fecExtentBuilder_.build();
          }
          to_bitField0_ |= 0x00001000;
        }
        if (((from_bitField0_ & 0x00008000) != 0)) {
          to_bitField0_ |= 0x00002000;
        }
        result.fecRoots_ = fecRoots_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof chromeos_update_engine.UpdateMetadata.PartitionUpdate) {
          return mergeFrom((chromeos_update_engine.UpdateMetadata.PartitionUpdate)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(chromeos_update_engine.UpdateMetadata.PartitionUpdate other) {
        if (other == chromeos_update_engine.UpdateMetadata.PartitionUpdate.getDefaultInstance()) return this;
        if (other.hasPartitionName()) {
          bitField0_ |= 0x00000001;
          partitionName_ = other.partitionName_;
          onChanged();
        }
        if (other.hasRunPostinstall()) {
          setRunPostinstall(other.getRunPostinstall());
        }
        if (other.hasPostinstallPath()) {
          bitField0_ |= 0x00000004;
          postinstallPath_ = other.postinstallPath_;
          onChanged();
        }
        if (other.hasFilesystemType()) {
          bitField0_ |= 0x00000008;
          filesystemType_ = other.filesystemType_;
          onChanged();
        }
        if (newPartitionSignatureBuilder_ == null) {
          if (!other.newPartitionSignature_.isEmpty()) {
            if (newPartitionSignature_.isEmpty()) {
              newPartitionSignature_ = other.newPartitionSignature_;
              bitField0_ = (bitField0_ & ~0x00000010);
            } else {
              ensureNewPartitionSignatureIsMutable();
              newPartitionSignature_.addAll(other.newPartitionSignature_);
            }
            onChanged();
          }
        } else {
          if (!other.newPartitionSignature_.isEmpty()) {
            if (newPartitionSignatureBuilder_.isEmpty()) {
              newPartitionSignatureBuilder_.dispose();
              newPartitionSignatureBuilder_ = null;
              newPartitionSignature_ = other.newPartitionSignature_;
              bitField0_ = (bitField0_ & ~0x00000010);
              newPartitionSignatureBuilder_ =
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getNewPartitionSignatureFieldBuilder() : null;
            } else {
              newPartitionSignatureBuilder_.addAllMessages(other.newPartitionSignature_);
            }
          }
        }
        if (other.hasOldPartitionInfo()) {
          mergeOldPartitionInfo(other.getOldPartitionInfo());
        }
        if (other.hasNewPartitionInfo()) {
          mergeNewPartitionInfo(other.getNewPartitionInfo());
        }
        if (operationsBuilder_ == null) {
          if (!other.operations_.isEmpty()) {
            if (operations_.isEmpty()) {
              operations_ = other.operations_;
              bitField0_ = (bitField0_ & ~0x00000080);
            } else {
              ensureOperationsIsMutable();
              operations_.addAll(other.operations_);
            }
            onChanged();
          }
        } else {
          if (!other.operations_.isEmpty()) {
            if (operationsBuilder_.isEmpty()) {
              operationsBuilder_.dispose();
              operationsBuilder_ = null;
              operations_ = other.operations_;
              bitField0_ = (bitField0_ & ~0x00000080);
              operationsBuilder_ =
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getOperationsFieldBuilder() : null;
            } else {
              operationsBuilder_.addAllMessages(other.operations_);
            }
          }
        }
        if (other.hasPostinstallOptional()) {
          setPostinstallOptional(other.getPostinstallOptional());
        }
        if (other.hasHashTreeDataExtent()) {
          mergeHashTreeDataExtent(other.getHashTreeDataExtent());
        }
        if (other.hasHashTreeExtent()) {
          mergeHashTreeExtent(other.getHashTreeExtent());
        }
        if (other.hasHashTreeAlgorithm()) {
          bitField0_ |= 0x00000800;
          hashTreeAlgorithm_ = other.hashTreeAlgorithm_;
          onChanged();
        }
        if (other.hasHashTreeSalt()) {
          setHashTreeSalt(other.getHashTreeSalt());
        }
        if (other.hasFecDataExtent()) {
          mergeFecDataExtent(other.getFecDataExtent());
        }
        if (other.hasFecExtent()) {
          mergeFecExtent(other.getFecExtent());
        }
        if (other.hasFecRoots()) {
          setFecRoots(other.getFecRoots());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        if (!hasPartitionName()) {
          return false;
        }
        for (int i = 0; i < getOperationsCount(); i++) {
          if (!getOperations(i).isInitialized()) {
            return false;
          }
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        chromeos_update_engine.UpdateMetadata.PartitionUpdate parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (chromeos_update_engine.UpdateMetadata.PartitionUpdate) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object partitionName_ = "";
      /**
       * <pre>
       * A platform-specific name to identify the partition set being updated. For
       * example, in Chrome OS this could be "ROOT" or "KERNEL".
       * </pre>
       *
       * <code>required string partition_name = 1;</code>
       * @return Whether the partitionName field is set.
       */
      public boolean hasPartitionName() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * A platform-specific name to identify the partition set being updated. For
       * example, in Chrome OS this could be "ROOT" or "KERNEL".
       * </pre>
       *
       * <code>required string partition_name = 1;</code>
       * @return The partitionName.
       */
      public java.lang.String getPartitionName() {
        java.lang.Object ref = partitionName_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            partitionName_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * A platform-specific name to identify the partition set being updated. For
       * example, in Chrome OS this could be "ROOT" or "KERNEL".
       * </pre>
       *
       * <code>required string partition_name = 1;</code>
       * @return The bytes for partitionName.
       */
      public com.google.protobuf.ByteString
          getPartitionNameBytes() {
        java.lang.Object ref = partitionName_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          partitionName_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * A platform-specific name to identify the partition set being updated. For
       * example, in Chrome OS this could be "ROOT" or "KERNEL".
       * </pre>
       *
       * <code>required string partition_name = 1;</code>
       * @param value The partitionName to set.
       * @return This builder for chaining.
       */
      public Builder setPartitionName(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        partitionName_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A platform-specific name to identify the partition set being updated. For
       * example, in Chrome OS this could be "ROOT" or "KERNEL".
       * </pre>
       *
       * <code>required string partition_name = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearPartitionName() {
        bitField0_ = (bitField0_ & ~0x00000001);
        partitionName_ = getDefaultInstance().getPartitionName();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A platform-specific name to identify the partition set being updated. For
       * example, in Chrome OS this could be "ROOT" or "KERNEL".
       * </pre>
       *
       * <code>required string partition_name = 1;</code>
       * @param value The bytes for partitionName to set.
       * @return This builder for chaining.
       */
      public Builder setPartitionNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        partitionName_ = value;
        onChanged();
        return this;
      }

      private boolean runPostinstall_ ;
      /**
       * <pre>
       * Whether this partition carries a filesystem with post-install program that
       * must be run to finalize the update process. See also |postinstall_path| and
       * |filesystem_type|.
       * </pre>
       *
       * <code>optional bool run_postinstall = 2;</code>
       * @return Whether the runPostinstall field is set.
       */
      @java.lang.Override
      public boolean hasRunPostinstall() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Whether this partition carries a filesystem with post-install program that
       * must be run to finalize the update process. See also |postinstall_path| and
       * |filesystem_type|.
       * </pre>
       *
       * <code>optional bool run_postinstall = 2;</code>
       * @return The runPostinstall.
       */
      @java.lang.Override
      public boolean getRunPostinstall() {
        return runPostinstall_;
      }
      /**
       * <pre>
       * Whether this partition carries a filesystem with post-install program that
       * must be run to finalize the update process. See also |postinstall_path| and
       * |filesystem_type|.
       * </pre>
       *
       * <code>optional bool run_postinstall = 2;</code>
       * @param value The runPostinstall to set.
       * @return This builder for chaining.
       */
      public Builder setRunPostinstall(boolean value) {
        bitField0_ |= 0x00000002;
        runPostinstall_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether this partition carries a filesystem with post-install program that
       * must be run to finalize the update process. See also |postinstall_path| and
       * |filesystem_type|.
       * </pre>
       *
       * <code>optional bool run_postinstall = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearRunPostinstall() {
        bitField0_ = (bitField0_ & ~0x00000002);
        runPostinstall_ = false;
        onChanged();
        return this;
      }

      private java.lang.Object postinstallPath_ = "";
      /**
       * <pre>
       * The path of the executable program to run during the post-install step,
       * relative to the root of this filesystem. If not set, the default "postinst"
       * will be used. This setting is only used when |run_postinstall| is set and
       * true.
       * </pre>
       *
       * <code>optional string postinstall_path = 3;</code>
       * @return Whether the postinstallPath field is set.
       */
      public boolean hasPostinstallPath() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * The path of the executable program to run during the post-install step,
       * relative to the root of this filesystem. If not set, the default "postinst"
       * will be used. This setting is only used when |run_postinstall| is set and
       * true.
       * </pre>
       *
       * <code>optional string postinstall_path = 3;</code>
       * @return The postinstallPath.
       */
      public java.lang.String getPostinstallPath() {
        java.lang.Object ref = postinstallPath_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            postinstallPath_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The path of the executable program to run during the post-install step,
       * relative to the root of this filesystem. If not set, the default "postinst"
       * will be used. This setting is only used when |run_postinstall| is set and
       * true.
       * </pre>
       *
       * <code>optional string postinstall_path = 3;</code>
       * @return The bytes for postinstallPath.
       */
      public com.google.protobuf.ByteString
          getPostinstallPathBytes() {
        java.lang.Object ref = postinstallPath_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          postinstallPath_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The path of the executable program to run during the post-install step,
       * relative to the root of this filesystem. If not set, the default "postinst"
       * will be used. This setting is only used when |run_postinstall| is set and
       * true.
       * </pre>
       *
       * <code>optional string postinstall_path = 3;</code>
       * @param value The postinstallPath to set.
       * @return This builder for chaining.
       */
      public Builder setPostinstallPath(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000004;
        postinstallPath_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The path of the executable program to run during the post-install step,
       * relative to the root of this filesystem. If not set, the default "postinst"
       * will be used. This setting is only used when |run_postinstall| is set and
       * true.
       * </pre>
       *
       * <code>optional string postinstall_path = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearPostinstallPath() {
        bitField0_ = (bitField0_ & ~0x00000004);
        postinstallPath_ = getDefaultInstance().getPostinstallPath();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The path of the executable program to run during the post-install step,
       * relative to the root of this filesystem. If not set, the default "postinst"
       * will be used. This setting is only used when |run_postinstall| is set and
       * true.
       * </pre>
       *
       * <code>optional string postinstall_path = 3;</code>
       * @param value The bytes for postinstallPath to set.
       * @return This builder for chaining.
       */
      public Builder setPostinstallPathBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000004;
        postinstallPath_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object filesystemType_ = "";
      /**
       * <pre>
       * The filesystem type as passed to the mount(2) syscall when mounting the new
       * filesystem to run the post-install program. If not set, a fixed list of
       * filesystems will be attempted. This setting is only used if
       * |run_postinstall| is set and true.
       * </pre>
       *
       * <code>optional string filesystem_type = 4;</code>
       * @return Whether the filesystemType field is set.
       */
      public boolean hasFilesystemType() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * The filesystem type as passed to the mount(2) syscall when mounting the new
       * filesystem to run the post-install program. If not set, a fixed list of
       * filesystems will be attempted. This setting is only used if
       * |run_postinstall| is set and true.
       * </pre>
       *
       * <code>optional string filesystem_type = 4;</code>
       * @return The filesystemType.
       */
      public java.lang.String getFilesystemType() {
        java.lang.Object ref = filesystemType_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            filesystemType_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The filesystem type as passed to the mount(2) syscall when mounting the new
       * filesystem to run the post-install program. If not set, a fixed list of
       * filesystems will be attempted. This setting is only used if
       * |run_postinstall| is set and true.
       * </pre>
       *
       * <code>optional string filesystem_type = 4;</code>
       * @return The bytes for filesystemType.
       */
      public com.google.protobuf.ByteString
          getFilesystemTypeBytes() {
        java.lang.Object ref = filesystemType_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          filesystemType_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The filesystem type as passed to the mount(2) syscall when mounting the new
       * filesystem to run the post-install program. If not set, a fixed list of
       * filesystems will be attempted. This setting is only used if
       * |run_postinstall| is set and true.
       * </pre>
       *
       * <code>optional string filesystem_type = 4;</code>
       * @param value The filesystemType to set.
       * @return This builder for chaining.
       */
      public Builder setFilesystemType(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000008;
        filesystemType_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The filesystem type as passed to the mount(2) syscall when mounting the new
       * filesystem to run the post-install program. If not set, a fixed list of
       * filesystems will be attempted. This setting is only used if
       * |run_postinstall| is set and true.
       * </pre>
       *
       * <code>optional string filesystem_type = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearFilesystemType() {
        bitField0_ = (bitField0_ & ~0x00000008);
        filesystemType_ = getDefaultInstance().getFilesystemType();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The filesystem type as passed to the mount(2) syscall when mounting the new
       * filesystem to run the post-install program. If not set, a fixed list of
       * filesystems will be attempted. This setting is only used if
       * |run_postinstall| is set and true.
       * </pre>
       *
       * <code>optional string filesystem_type = 4;</code>
       * @param value The bytes for filesystemType to set.
       * @return This builder for chaining.
       */
      public Builder setFilesystemTypeBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000008;
        filesystemType_ = value;
        onChanged();
        return this;
      }

      private java.util.List<chromeos_update_engine.UpdateMetadata.Signatures.Signature> newPartitionSignature_ =
        java.util.Collections.emptyList();
      private void ensureNewPartitionSignatureIsMutable() {
        if (!((bitField0_ & 0x00000010) != 0)) {
          newPartitionSignature_ = new java.util.ArrayList<chromeos_update_engine.UpdateMetadata.Signatures.Signature>(newPartitionSignature_);
          bitField0_ |= 0x00000010;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.Signatures.Signature, chromeos_update_engine.UpdateMetadata.Signatures.Signature.Builder, chromeos_update_engine.UpdateMetadata.Signatures.SignatureOrBuilder> newPartitionSignatureBuilder_;

      /**
       * <pre>
       * If present, a list of signatures of the new_partition_info.hash signed with
       * different keys. If the update_engine daemon requires vendor-signed images
       * and has its public key installed, one of the signatures should be valid
       * for /postinstall to run.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;</code>
       */
      public java.util.List<chromeos_update_engine.UpdateMetadata.Signatures.Signature> getNewPartitionSignatureList() {
        if (newPartitionSignatureBuilder_ == null) {
          return java.util.Collections.unmodifiableList(newPartitionSignature_);
        } else {
          return newPartitionSignatureBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * If present, a list of signatures of the new_partition_info.hash signed with
       * different keys. If the update_engine daemon requires vendor-signed images
       * and has its public key installed, one of the signatures should be valid
       * for /postinstall to run.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;</code>
       */
      public int getNewPartitionSignatureCount() {
        if (newPartitionSignatureBuilder_ == null) {
          return newPartitionSignature_.size();
        } else {
          return newPartitionSignatureBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * If present, a list of signatures of the new_partition_info.hash signed with
       * different keys. If the update_engine daemon requires vendor-signed images
       * and has its public key installed, one of the signatures should be valid
       * for /postinstall to run.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;</code>
       */
      public chromeos_update_engine.UpdateMetadata.Signatures.Signature getNewPartitionSignature(int index) {
        if (newPartitionSignatureBuilder_ == null) {
          return newPartitionSignature_.get(index);
        } else {
          return newPartitionSignatureBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * If present, a list of signatures of the new_partition_info.hash signed with
       * different keys. If the update_engine daemon requires vendor-signed images
       * and has its public key installed, one of the signatures should be valid
       * for /postinstall to run.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;</code>
       */
      public Builder setNewPartitionSignature(
          int index, chromeos_update_engine.UpdateMetadata.Signatures.Signature value) {
        if (newPartitionSignatureBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureNewPartitionSignatureIsMutable();
          newPartitionSignature_.set(index, value);
          onChanged();
        } else {
          newPartitionSignatureBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * If present, a list of signatures of the new_partition_info.hash signed with
       * different keys. If the update_engine daemon requires vendor-signed images
       * and has its public key installed, one of the signatures should be valid
       * for /postinstall to run.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;</code>
       */
      public Builder setNewPartitionSignature(
          int index, chromeos_update_engine.UpdateMetadata.Signatures.Signature.Builder builderForValue) {
        if (newPartitionSignatureBuilder_ == null) {
          ensureNewPartitionSignatureIsMutable();
          newPartitionSignature_.set(index, builderForValue.build());
          onChanged();
        } else {
          newPartitionSignatureBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * If present, a list of signatures of the new_partition_info.hash signed with
       * different keys. If the update_engine daemon requires vendor-signed images
       * and has its public key installed, one of the signatures should be valid
       * for /postinstall to run.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;</code>
       */
      public Builder addNewPartitionSignature(chromeos_update_engine.UpdateMetadata.Signatures.Signature value) {
        if (newPartitionSignatureBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureNewPartitionSignatureIsMutable();
          newPartitionSignature_.add(value);
          onChanged();
        } else {
          newPartitionSignatureBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * If present, a list of signatures of the new_partition_info.hash signed with
       * different keys. If the update_engine daemon requires vendor-signed images
       * and has its public key installed, one of the signatures should be valid
       * for /postinstall to run.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;</code>
       */
      public Builder addNewPartitionSignature(
          int index, chromeos_update_engine.UpdateMetadata.Signatures.Signature value) {
        if (newPartitionSignatureBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureNewPartitionSignatureIsMutable();
          newPartitionSignature_.add(index, value);
          onChanged();
        } else {
          newPartitionSignatureBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * If present, a list of signatures of the new_partition_info.hash signed with
       * different keys. If the update_engine daemon requires vendor-signed images
       * and has its public key installed, one of the signatures should be valid
       * for /postinstall to run.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;</code>
       */
      public Builder addNewPartitionSignature(
          chromeos_update_engine.UpdateMetadata.Signatures.Signature.Builder builderForValue) {
        if (newPartitionSignatureBuilder_ == null) {
          ensureNewPartitionSignatureIsMutable();
          newPartitionSignature_.add(builderForValue.build());
          onChanged();
        } else {
          newPartitionSignatureBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * If present, a list of signatures of the new_partition_info.hash signed with
       * different keys. If the update_engine daemon requires vendor-signed images
       * and has its public key installed, one of the signatures should be valid
       * for /postinstall to run.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;</code>
       */
      public Builder addNewPartitionSignature(
          int index, chromeos_update_engine.UpdateMetadata.Signatures.Signature.Builder builderForValue) {
        if (newPartitionSignatureBuilder_ == null) {
          ensureNewPartitionSignatureIsMutable();
          newPartitionSignature_.add(index, builderForValue.build());
          onChanged();
        } else {
          newPartitionSignatureBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * If present, a list of signatures of the new_partition_info.hash signed with
       * different keys. If the update_engine daemon requires vendor-signed images
       * and has its public key installed, one of the signatures should be valid
       * for /postinstall to run.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;</code>
       */
      public Builder addAllNewPartitionSignature(
          java.lang.Iterable<? extends chromeos_update_engine.UpdateMetadata.Signatures.Signature> values) {
        if (newPartitionSignatureBuilder_ == null) {
          ensureNewPartitionSignatureIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, newPartitionSignature_);
          onChanged();
        } else {
          newPartitionSignatureBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * If present, a list of signatures of the new_partition_info.hash signed with
       * different keys. If the update_engine daemon requires vendor-signed images
       * and has its public key installed, one of the signatures should be valid
       * for /postinstall to run.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;</code>
       */
      public Builder clearNewPartitionSignature() {
        if (newPartitionSignatureBuilder_ == null) {
          newPartitionSignature_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000010);
          onChanged();
        } else {
          newPartitionSignatureBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * If present, a list of signatures of the new_partition_info.hash signed with
       * different keys. If the update_engine daemon requires vendor-signed images
       * and has its public key installed, one of the signatures should be valid
       * for /postinstall to run.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;</code>
       */
      public Builder removeNewPartitionSignature(int index) {
        if (newPartitionSignatureBuilder_ == null) {
          ensureNewPartitionSignatureIsMutable();
          newPartitionSignature_.remove(index);
          onChanged();
        } else {
          newPartitionSignatureBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * If present, a list of signatures of the new_partition_info.hash signed with
       * different keys. If the update_engine daemon requires vendor-signed images
       * and has its public key installed, one of the signatures should be valid
       * for /postinstall to run.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;</code>
       */
      public chromeos_update_engine.UpdateMetadata.Signatures.Signature.Builder getNewPartitionSignatureBuilder(
          int index) {
        return getNewPartitionSignatureFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * If present, a list of signatures of the new_partition_info.hash signed with
       * different keys. If the update_engine daemon requires vendor-signed images
       * and has its public key installed, one of the signatures should be valid
       * for /postinstall to run.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;</code>
       */
      public chromeos_update_engine.UpdateMetadata.Signatures.SignatureOrBuilder getNewPartitionSignatureOrBuilder(
          int index) {
        if (newPartitionSignatureBuilder_ == null) {
          return newPartitionSignature_.get(index);  } else {
          return newPartitionSignatureBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * If present, a list of signatures of the new_partition_info.hash signed with
       * different keys. If the update_engine daemon requires vendor-signed images
       * and has its public key installed, one of the signatures should be valid
       * for /postinstall to run.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;</code>
       */
      public java.util.List<? extends chromeos_update_engine.UpdateMetadata.Signatures.SignatureOrBuilder>
           getNewPartitionSignatureOrBuilderList() {
        if (newPartitionSignatureBuilder_ != null) {
          return newPartitionSignatureBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(newPartitionSignature_);
        }
      }
      /**
       * <pre>
       * If present, a list of signatures of the new_partition_info.hash signed with
       * different keys. If the update_engine daemon requires vendor-signed images
       * and has its public key installed, one of the signatures should be valid
       * for /postinstall to run.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;</code>
       */
      public chromeos_update_engine.UpdateMetadata.Signatures.Signature.Builder addNewPartitionSignatureBuilder() {
        return getNewPartitionSignatureFieldBuilder().addBuilder(
            chromeos_update_engine.UpdateMetadata.Signatures.Signature.getDefaultInstance());
      }
      /**
       * <pre>
       * If present, a list of signatures of the new_partition_info.hash signed with
       * different keys. If the update_engine daemon requires vendor-signed images
       * and has its public key installed, one of the signatures should be valid
       * for /postinstall to run.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;</code>
       */
      public chromeos_update_engine.UpdateMetadata.Signatures.Signature.Builder addNewPartitionSignatureBuilder(
          int index) {
        return getNewPartitionSignatureFieldBuilder().addBuilder(
            index, chromeos_update_engine.UpdateMetadata.Signatures.Signature.getDefaultInstance());
      }
      /**
       * <pre>
       * If present, a list of signatures of the new_partition_info.hash signed with
       * different keys. If the update_engine daemon requires vendor-signed images
       * and has its public key installed, one of the signatures should be valid
       * for /postinstall to run.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;</code>
       */
      public java.util.List<chromeos_update_engine.UpdateMetadata.Signatures.Signature.Builder>
           getNewPartitionSignatureBuilderList() {
        return getNewPartitionSignatureFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.Signatures.Signature, chromeos_update_engine.UpdateMetadata.Signatures.Signature.Builder, chromeos_update_engine.UpdateMetadata.Signatures.SignatureOrBuilder>
          getNewPartitionSignatureFieldBuilder() {
        if (newPartitionSignatureBuilder_ == null) {
          newPartitionSignatureBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              chromeos_update_engine.UpdateMetadata.Signatures.Signature, chromeos_update_engine.UpdateMetadata.Signatures.Signature.Builder, chromeos_update_engine.UpdateMetadata.Signatures.SignatureOrBuilder>(
                  newPartitionSignature_,
                  ((bitField0_ & 0x00000010) != 0),
                  getParentForChildren(),
                  isClean());
          newPartitionSignature_ = null;
        }
        return newPartitionSignatureBuilder_;
      }

      private chromeos_update_engine.UpdateMetadata.PartitionInfo oldPartitionInfo_;
      private com.google.protobuf.SingleFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.PartitionInfo, chromeos_update_engine.UpdateMetadata.PartitionInfo.Builder, chromeos_update_engine.UpdateMetadata.PartitionInfoOrBuilder> oldPartitionInfoBuilder_;
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo old_partition_info = 6;</code>
       * @return Whether the oldPartitionInfo field is set.
       */
      public boolean hasOldPartitionInfo() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo old_partition_info = 6;</code>
       * @return The oldPartitionInfo.
       */
      public chromeos_update_engine.UpdateMetadata.PartitionInfo getOldPartitionInfo() {
        if (oldPartitionInfoBuilder_ == null) {
          return oldPartitionInfo_ == null ? chromeos_update_engine.UpdateMetadata.PartitionInfo.getDefaultInstance() : oldPartitionInfo_;
        } else {
          return oldPartitionInfoBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo old_partition_info = 6;</code>
       */
      public Builder setOldPartitionInfo(chromeos_update_engine.UpdateMetadata.PartitionInfo value) {
        if (oldPartitionInfoBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          oldPartitionInfo_ = value;
          onChanged();
        } else {
          oldPartitionInfoBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000020;
        return this;
      }
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo old_partition_info = 6;</code>
       */
      public Builder setOldPartitionInfo(
          chromeos_update_engine.UpdateMetadata.PartitionInfo.Builder builderForValue) {
        if (oldPartitionInfoBuilder_ == null) {
          oldPartitionInfo_ = builderForValue.build();
          onChanged();
        } else {
          oldPartitionInfoBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000020;
        return this;
      }
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo old_partition_info = 6;</code>
       */
      public Builder mergeOldPartitionInfo(chromeos_update_engine.UpdateMetadata.PartitionInfo value) {
        if (oldPartitionInfoBuilder_ == null) {
          if (((bitField0_ & 0x00000020) != 0) &&
              oldPartitionInfo_ != null &&
              oldPartitionInfo_ != chromeos_update_engine.UpdateMetadata.PartitionInfo.getDefaultInstance()) {
            oldPartitionInfo_ =
              chromeos_update_engine.UpdateMetadata.PartitionInfo.newBuilder(oldPartitionInfo_).mergeFrom(value).buildPartial();
          } else {
            oldPartitionInfo_ = value;
          }
          onChanged();
        } else {
          oldPartitionInfoBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000020;
        return this;
      }
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo old_partition_info = 6;</code>
       */
      public Builder clearOldPartitionInfo() {
        if (oldPartitionInfoBuilder_ == null) {
          oldPartitionInfo_ = null;
          onChanged();
        } else {
          oldPartitionInfoBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000020);
        return this;
      }
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo old_partition_info = 6;</code>
       */
      public chromeos_update_engine.UpdateMetadata.PartitionInfo.Builder getOldPartitionInfoBuilder() {
        bitField0_ |= 0x00000020;
        onChanged();
        return getOldPartitionInfoFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo old_partition_info = 6;</code>
       */
      public chromeos_update_engine.UpdateMetadata.PartitionInfoOrBuilder getOldPartitionInfoOrBuilder() {
        if (oldPartitionInfoBuilder_ != null) {
          return oldPartitionInfoBuilder_.getMessageOrBuilder();
        } else {
          return oldPartitionInfo_ == null ?
              chromeos_update_engine.UpdateMetadata.PartitionInfo.getDefaultInstance() : oldPartitionInfo_;
        }
      }
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo old_partition_info = 6;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.PartitionInfo, chromeos_update_engine.UpdateMetadata.PartitionInfo.Builder, chromeos_update_engine.UpdateMetadata.PartitionInfoOrBuilder>
          getOldPartitionInfoFieldBuilder() {
        if (oldPartitionInfoBuilder_ == null) {
          oldPartitionInfoBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              chromeos_update_engine.UpdateMetadata.PartitionInfo, chromeos_update_engine.UpdateMetadata.PartitionInfo.Builder, chromeos_update_engine.UpdateMetadata.PartitionInfoOrBuilder>(
                  getOldPartitionInfo(),
                  getParentForChildren(),
                  isClean());
          oldPartitionInfo_ = null;
        }
        return oldPartitionInfoBuilder_;
      }

      private chromeos_update_engine.UpdateMetadata.PartitionInfo newPartitionInfo_;
      private com.google.protobuf.SingleFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.PartitionInfo, chromeos_update_engine.UpdateMetadata.PartitionInfo.Builder, chromeos_update_engine.UpdateMetadata.PartitionInfoOrBuilder> newPartitionInfoBuilder_;
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo new_partition_info = 7;</code>
       * @return Whether the newPartitionInfo field is set.
       */
      public boolean hasNewPartitionInfo() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo new_partition_info = 7;</code>
       * @return The newPartitionInfo.
       */
      public chromeos_update_engine.UpdateMetadata.PartitionInfo getNewPartitionInfo() {
        if (newPartitionInfoBuilder_ == null) {
          return newPartitionInfo_ == null ? chromeos_update_engine.UpdateMetadata.PartitionInfo.getDefaultInstance() : newPartitionInfo_;
        } else {
          return newPartitionInfoBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo new_partition_info = 7;</code>
       */
      public Builder setNewPartitionInfo(chromeos_update_engine.UpdateMetadata.PartitionInfo value) {
        if (newPartitionInfoBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          newPartitionInfo_ = value;
          onChanged();
        } else {
          newPartitionInfoBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000040;
        return this;
      }
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo new_partition_info = 7;</code>
       */
      public Builder setNewPartitionInfo(
          chromeos_update_engine.UpdateMetadata.PartitionInfo.Builder builderForValue) {
        if (newPartitionInfoBuilder_ == null) {
          newPartitionInfo_ = builderForValue.build();
          onChanged();
        } else {
          newPartitionInfoBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000040;
        return this;
      }
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo new_partition_info = 7;</code>
       */
      public Builder mergeNewPartitionInfo(chromeos_update_engine.UpdateMetadata.PartitionInfo value) {
        if (newPartitionInfoBuilder_ == null) {
          if (((bitField0_ & 0x00000040) != 0) &&
              newPartitionInfo_ != null &&
              newPartitionInfo_ != chromeos_update_engine.UpdateMetadata.PartitionInfo.getDefaultInstance()) {
            newPartitionInfo_ =
              chromeos_update_engine.UpdateMetadata.PartitionInfo.newBuilder(newPartitionInfo_).mergeFrom(value).buildPartial();
          } else {
            newPartitionInfo_ = value;
          }
          onChanged();
        } else {
          newPartitionInfoBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000040;
        return this;
      }
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo new_partition_info = 7;</code>
       */
      public Builder clearNewPartitionInfo() {
        if (newPartitionInfoBuilder_ == null) {
          newPartitionInfo_ = null;
          onChanged();
        } else {
          newPartitionInfoBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000040);
        return this;
      }
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo new_partition_info = 7;</code>
       */
      public chromeos_update_engine.UpdateMetadata.PartitionInfo.Builder getNewPartitionInfoBuilder() {
        bitField0_ |= 0x00000040;
        onChanged();
        return getNewPartitionInfoFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo new_partition_info = 7;</code>
       */
      public chromeos_update_engine.UpdateMetadata.PartitionInfoOrBuilder getNewPartitionInfoOrBuilder() {
        if (newPartitionInfoBuilder_ != null) {
          return newPartitionInfoBuilder_.getMessageOrBuilder();
        } else {
          return newPartitionInfo_ == null ?
              chromeos_update_engine.UpdateMetadata.PartitionInfo.getDefaultInstance() : newPartitionInfo_;
        }
      }
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo new_partition_info = 7;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.PartitionInfo, chromeos_update_engine.UpdateMetadata.PartitionInfo.Builder, chromeos_update_engine.UpdateMetadata.PartitionInfoOrBuilder>
          getNewPartitionInfoFieldBuilder() {
        if (newPartitionInfoBuilder_ == null) {
          newPartitionInfoBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              chromeos_update_engine.UpdateMetadata.PartitionInfo, chromeos_update_engine.UpdateMetadata.PartitionInfo.Builder, chromeos_update_engine.UpdateMetadata.PartitionInfoOrBuilder>(
                  getNewPartitionInfo(),
                  getParentForChildren(),
                  isClean());
          newPartitionInfo_ = null;
        }
        return newPartitionInfoBuilder_;
      }

      private java.util.List<chromeos_update_engine.UpdateMetadata.InstallOperation> operations_ =
        java.util.Collections.emptyList();
      private void ensureOperationsIsMutable() {
        if (!((bitField0_ & 0x00000080) != 0)) {
          operations_ = new java.util.ArrayList<chromeos_update_engine.UpdateMetadata.InstallOperation>(operations_);
          bitField0_ |= 0x00000080;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.InstallOperation, chromeos_update_engine.UpdateMetadata.InstallOperation.Builder, chromeos_update_engine.UpdateMetadata.InstallOperationOrBuilder> operationsBuilder_;

      /**
       * <pre>
       * The list of operations to be performed to apply this PartitionUpdate. The
       * associated operation blobs (in operations[i].data_offset, data_length)
       * should be stored contiguously and in the same order.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.InstallOperation operations = 8;</code>
       */
      public java.util.List<chromeos_update_engine.UpdateMetadata.InstallOperation> getOperationsList() {
        if (operationsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(operations_);
        } else {
          return operationsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * The list of operations to be performed to apply this PartitionUpdate. The
       * associated operation blobs (in operations[i].data_offset, data_length)
       * should be stored contiguously and in the same order.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.InstallOperation operations = 8;</code>
       */
      public int getOperationsCount() {
        if (operationsBuilder_ == null) {
          return operations_.size();
        } else {
          return operationsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * The list of operations to be performed to apply this PartitionUpdate. The
       * associated operation blobs (in operations[i].data_offset, data_length)
       * should be stored contiguously and in the same order.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.InstallOperation operations = 8;</code>
       */
      public chromeos_update_engine.UpdateMetadata.InstallOperation getOperations(int index) {
        if (operationsBuilder_ == null) {
          return operations_.get(index);
        } else {
          return operationsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * The list of operations to be performed to apply this PartitionUpdate. The
       * associated operation blobs (in operations[i].data_offset, data_length)
       * should be stored contiguously and in the same order.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.InstallOperation operations = 8;</code>
       */
      public Builder setOperations(
          int index, chromeos_update_engine.UpdateMetadata.InstallOperation value) {
        if (operationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureOperationsIsMutable();
          operations_.set(index, value);
          onChanged();
        } else {
          operationsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * The list of operations to be performed to apply this PartitionUpdate. The
       * associated operation blobs (in operations[i].data_offset, data_length)
       * should be stored contiguously and in the same order.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.InstallOperation operations = 8;</code>
       */
      public Builder setOperations(
          int index, chromeos_update_engine.UpdateMetadata.InstallOperation.Builder builderForValue) {
        if (operationsBuilder_ == null) {
          ensureOperationsIsMutable();
          operations_.set(index, builderForValue.build());
          onChanged();
        } else {
          operationsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The list of operations to be performed to apply this PartitionUpdate. The
       * associated operation blobs (in operations[i].data_offset, data_length)
       * should be stored contiguously and in the same order.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.InstallOperation operations = 8;</code>
       */
      public Builder addOperations(chromeos_update_engine.UpdateMetadata.InstallOperation value) {
        if (operationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureOperationsIsMutable();
          operations_.add(value);
          onChanged();
        } else {
          operationsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * The list of operations to be performed to apply this PartitionUpdate. The
       * associated operation blobs (in operations[i].data_offset, data_length)
       * should be stored contiguously and in the same order.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.InstallOperation operations = 8;</code>
       */
      public Builder addOperations(
          int index, chromeos_update_engine.UpdateMetadata.InstallOperation value) {
        if (operationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureOperationsIsMutable();
          operations_.add(index, value);
          onChanged();
        } else {
          operationsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * The list of operations to be performed to apply this PartitionUpdate. The
       * associated operation blobs (in operations[i].data_offset, data_length)
       * should be stored contiguously and in the same order.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.InstallOperation operations = 8;</code>
       */
      public Builder addOperations(
          chromeos_update_engine.UpdateMetadata.InstallOperation.Builder builderForValue) {
        if (operationsBuilder_ == null) {
          ensureOperationsIsMutable();
          operations_.add(builderForValue.build());
          onChanged();
        } else {
          operationsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The list of operations to be performed to apply this PartitionUpdate. The
       * associated operation blobs (in operations[i].data_offset, data_length)
       * should be stored contiguously and in the same order.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.InstallOperation operations = 8;</code>
       */
      public Builder addOperations(
          int index, chromeos_update_engine.UpdateMetadata.InstallOperation.Builder builderForValue) {
        if (operationsBuilder_ == null) {
          ensureOperationsIsMutable();
          operations_.add(index, builderForValue.build());
          onChanged();
        } else {
          operationsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The list of operations to be performed to apply this PartitionUpdate. The
       * associated operation blobs (in operations[i].data_offset, data_length)
       * should be stored contiguously and in the same order.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.InstallOperation operations = 8;</code>
       */
      public Builder addAllOperations(
          java.lang.Iterable<? extends chromeos_update_engine.UpdateMetadata.InstallOperation> values) {
        if (operationsBuilder_ == null) {
          ensureOperationsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, operations_);
          onChanged();
        } else {
          operationsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * The list of operations to be performed to apply this PartitionUpdate. The
       * associated operation blobs (in operations[i].data_offset, data_length)
       * should be stored contiguously and in the same order.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.InstallOperation operations = 8;</code>
       */
      public Builder clearOperations() {
        if (operationsBuilder_ == null) {
          operations_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000080);
          onChanged();
        } else {
          operationsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * The list of operations to be performed to apply this PartitionUpdate. The
       * associated operation blobs (in operations[i].data_offset, data_length)
       * should be stored contiguously and in the same order.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.InstallOperation operations = 8;</code>
       */
      public Builder removeOperations(int index) {
        if (operationsBuilder_ == null) {
          ensureOperationsIsMutable();
          operations_.remove(index);
          onChanged();
        } else {
          operationsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * The list of operations to be performed to apply this PartitionUpdate. The
       * associated operation blobs (in operations[i].data_offset, data_length)
       * should be stored contiguously and in the same order.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.InstallOperation operations = 8;</code>
       */
      public chromeos_update_engine.UpdateMetadata.InstallOperation.Builder getOperationsBuilder(
          int index) {
        return getOperationsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * The list of operations to be performed to apply this PartitionUpdate. The
       * associated operation blobs (in operations[i].data_offset, data_length)
       * should be stored contiguously and in the same order.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.InstallOperation operations = 8;</code>
       */
      public chromeos_update_engine.UpdateMetadata.InstallOperationOrBuilder getOperationsOrBuilder(
          int index) {
        if (operationsBuilder_ == null) {
          return operations_.get(index);  } else {
          return operationsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * The list of operations to be performed to apply this PartitionUpdate. The
       * associated operation blobs (in operations[i].data_offset, data_length)
       * should be stored contiguously and in the same order.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.InstallOperation operations = 8;</code>
       */
      public java.util.List<? extends chromeos_update_engine.UpdateMetadata.InstallOperationOrBuilder>
           getOperationsOrBuilderList() {
        if (operationsBuilder_ != null) {
          return operationsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(operations_);
        }
      }
      /**
       * <pre>
       * The list of operations to be performed to apply this PartitionUpdate. The
       * associated operation blobs (in operations[i].data_offset, data_length)
       * should be stored contiguously and in the same order.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.InstallOperation operations = 8;</code>
       */
      public chromeos_update_engine.UpdateMetadata.InstallOperation.Builder addOperationsBuilder() {
        return getOperationsFieldBuilder().addBuilder(
            chromeos_update_engine.UpdateMetadata.InstallOperation.getDefaultInstance());
      }
      /**
       * <pre>
       * The list of operations to be performed to apply this PartitionUpdate. The
       * associated operation blobs (in operations[i].data_offset, data_length)
       * should be stored contiguously and in the same order.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.InstallOperation operations = 8;</code>
       */
      public chromeos_update_engine.UpdateMetadata.InstallOperation.Builder addOperationsBuilder(
          int index) {
        return getOperationsFieldBuilder().addBuilder(
            index, chromeos_update_engine.UpdateMetadata.InstallOperation.getDefaultInstance());
      }
      /**
       * <pre>
       * The list of operations to be performed to apply this PartitionUpdate. The
       * associated operation blobs (in operations[i].data_offset, data_length)
       * should be stored contiguously and in the same order.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.InstallOperation operations = 8;</code>
       */
      public java.util.List<chromeos_update_engine.UpdateMetadata.InstallOperation.Builder>
           getOperationsBuilderList() {
        return getOperationsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.InstallOperation, chromeos_update_engine.UpdateMetadata.InstallOperation.Builder, chromeos_update_engine.UpdateMetadata.InstallOperationOrBuilder>
          getOperationsFieldBuilder() {
        if (operationsBuilder_ == null) {
          operationsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              chromeos_update_engine.UpdateMetadata.InstallOperation, chromeos_update_engine.UpdateMetadata.InstallOperation.Builder, chromeos_update_engine.UpdateMetadata.InstallOperationOrBuilder>(
                  operations_,
                  ((bitField0_ & 0x00000080) != 0),
                  getParentForChildren(),
                  isClean());
          operations_ = null;
        }
        return operationsBuilder_;
      }

      private boolean postinstallOptional_ ;
      /**
       * <pre>
       * Whether a failure in the postinstall step for this partition should be
       * ignored.
       * </pre>
       *
       * <code>optional bool postinstall_optional = 9;</code>
       * @return Whether the postinstallOptional field is set.
       */
      @java.lang.Override
      public boolean hasPostinstallOptional() {
        return ((bitField0_ & 0x00000100) != 0);
      }
      /**
       * <pre>
       * Whether a failure in the postinstall step for this partition should be
       * ignored.
       * </pre>
       *
       * <code>optional bool postinstall_optional = 9;</code>
       * @return The postinstallOptional.
       */
      @java.lang.Override
      public boolean getPostinstallOptional() {
        return postinstallOptional_;
      }
      /**
       * <pre>
       * Whether a failure in the postinstall step for this partition should be
       * ignored.
       * </pre>
       *
       * <code>optional bool postinstall_optional = 9;</code>
       * @param value The postinstallOptional to set.
       * @return This builder for chaining.
       */
      public Builder setPostinstallOptional(boolean value) {
        bitField0_ |= 0x00000100;
        postinstallOptional_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether a failure in the postinstall step for this partition should be
       * ignored.
       * </pre>
       *
       * <code>optional bool postinstall_optional = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearPostinstallOptional() {
        bitField0_ = (bitField0_ & ~0x00000100);
        postinstallOptional_ = false;
        onChanged();
        return this;
      }

      private chromeos_update_engine.UpdateMetadata.Extent hashTreeDataExtent_;
      private com.google.protobuf.SingleFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.Extent, chromeos_update_engine.UpdateMetadata.Extent.Builder, chromeos_update_engine.UpdateMetadata.ExtentOrBuilder> hashTreeDataExtentBuilder_;
      /**
       * <pre>
       * The extent for data covered by verity hash tree.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent hash_tree_data_extent = 10;</code>
       * @return Whether the hashTreeDataExtent field is set.
       */
      public boolean hasHashTreeDataExtent() {
        return ((bitField0_ & 0x00000200) != 0);
      }
      /**
       * <pre>
       * The extent for data covered by verity hash tree.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent hash_tree_data_extent = 10;</code>
       * @return The hashTreeDataExtent.
       */
      public chromeos_update_engine.UpdateMetadata.Extent getHashTreeDataExtent() {
        if (hashTreeDataExtentBuilder_ == null) {
          return hashTreeDataExtent_ == null ? chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance() : hashTreeDataExtent_;
        } else {
          return hashTreeDataExtentBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The extent for data covered by verity hash tree.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent hash_tree_data_extent = 10;</code>
       */
      public Builder setHashTreeDataExtent(chromeos_update_engine.UpdateMetadata.Extent value) {
        if (hashTreeDataExtentBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          hashTreeDataExtent_ = value;
          onChanged();
        } else {
          hashTreeDataExtentBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000200;
        return this;
      }
      /**
       * <pre>
       * The extent for data covered by verity hash tree.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent hash_tree_data_extent = 10;</code>
       */
      public Builder setHashTreeDataExtent(
          chromeos_update_engine.UpdateMetadata.Extent.Builder builderForValue) {
        if (hashTreeDataExtentBuilder_ == null) {
          hashTreeDataExtent_ = builderForValue.build();
          onChanged();
        } else {
          hashTreeDataExtentBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000200;
        return this;
      }
      /**
       * <pre>
       * The extent for data covered by verity hash tree.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent hash_tree_data_extent = 10;</code>
       */
      public Builder mergeHashTreeDataExtent(chromeos_update_engine.UpdateMetadata.Extent value) {
        if (hashTreeDataExtentBuilder_ == null) {
          if (((bitField0_ & 0x00000200) != 0) &&
              hashTreeDataExtent_ != null &&
              hashTreeDataExtent_ != chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance()) {
            hashTreeDataExtent_ =
              chromeos_update_engine.UpdateMetadata.Extent.newBuilder(hashTreeDataExtent_).mergeFrom(value).buildPartial();
          } else {
            hashTreeDataExtent_ = value;
          }
          onChanged();
        } else {
          hashTreeDataExtentBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000200;
        return this;
      }
      /**
       * <pre>
       * The extent for data covered by verity hash tree.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent hash_tree_data_extent = 10;</code>
       */
      public Builder clearHashTreeDataExtent() {
        if (hashTreeDataExtentBuilder_ == null) {
          hashTreeDataExtent_ = null;
          onChanged();
        } else {
          hashTreeDataExtentBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000200);
        return this;
      }
      /**
       * <pre>
       * The extent for data covered by verity hash tree.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent hash_tree_data_extent = 10;</code>
       */
      public chromeos_update_engine.UpdateMetadata.Extent.Builder getHashTreeDataExtentBuilder() {
        bitField0_ |= 0x00000200;
        onChanged();
        return getHashTreeDataExtentFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The extent for data covered by verity hash tree.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent hash_tree_data_extent = 10;</code>
       */
      public chromeos_update_engine.UpdateMetadata.ExtentOrBuilder getHashTreeDataExtentOrBuilder() {
        if (hashTreeDataExtentBuilder_ != null) {
          return hashTreeDataExtentBuilder_.getMessageOrBuilder();
        } else {
          return hashTreeDataExtent_ == null ?
              chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance() : hashTreeDataExtent_;
        }
      }
      /**
       * <pre>
       * The extent for data covered by verity hash tree.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent hash_tree_data_extent = 10;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.Extent, chromeos_update_engine.UpdateMetadata.Extent.Builder, chromeos_update_engine.UpdateMetadata.ExtentOrBuilder>
          getHashTreeDataExtentFieldBuilder() {
        if (hashTreeDataExtentBuilder_ == null) {
          hashTreeDataExtentBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              chromeos_update_engine.UpdateMetadata.Extent, chromeos_update_engine.UpdateMetadata.Extent.Builder, chromeos_update_engine.UpdateMetadata.ExtentOrBuilder>(
                  getHashTreeDataExtent(),
                  getParentForChildren(),
                  isClean());
          hashTreeDataExtent_ = null;
        }
        return hashTreeDataExtentBuilder_;
      }

      private chromeos_update_engine.UpdateMetadata.Extent hashTreeExtent_;
      private com.google.protobuf.SingleFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.Extent, chromeos_update_engine.UpdateMetadata.Extent.Builder, chromeos_update_engine.UpdateMetadata.ExtentOrBuilder> hashTreeExtentBuilder_;
      /**
       * <pre>
       * The extent to store verity hash tree.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent hash_tree_extent = 11;</code>
       * @return Whether the hashTreeExtent field is set.
       */
      public boolean hasHashTreeExtent() {
        return ((bitField0_ & 0x00000400) != 0);
      }
      /**
       * <pre>
       * The extent to store verity hash tree.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent hash_tree_extent = 11;</code>
       * @return The hashTreeExtent.
       */
      public chromeos_update_engine.UpdateMetadata.Extent getHashTreeExtent() {
        if (hashTreeExtentBuilder_ == null) {
          return hashTreeExtent_ == null ? chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance() : hashTreeExtent_;
        } else {
          return hashTreeExtentBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The extent to store verity hash tree.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent hash_tree_extent = 11;</code>
       */
      public Builder setHashTreeExtent(chromeos_update_engine.UpdateMetadata.Extent value) {
        if (hashTreeExtentBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          hashTreeExtent_ = value;
          onChanged();
        } else {
          hashTreeExtentBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000400;
        return this;
      }
      /**
       * <pre>
       * The extent to store verity hash tree.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent hash_tree_extent = 11;</code>
       */
      public Builder setHashTreeExtent(
          chromeos_update_engine.UpdateMetadata.Extent.Builder builderForValue) {
        if (hashTreeExtentBuilder_ == null) {
          hashTreeExtent_ = builderForValue.build();
          onChanged();
        } else {
          hashTreeExtentBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000400;
        return this;
      }
      /**
       * <pre>
       * The extent to store verity hash tree.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent hash_tree_extent = 11;</code>
       */
      public Builder mergeHashTreeExtent(chromeos_update_engine.UpdateMetadata.Extent value) {
        if (hashTreeExtentBuilder_ == null) {
          if (((bitField0_ & 0x00000400) != 0) &&
              hashTreeExtent_ != null &&
              hashTreeExtent_ != chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance()) {
            hashTreeExtent_ =
              chromeos_update_engine.UpdateMetadata.Extent.newBuilder(hashTreeExtent_).mergeFrom(value).buildPartial();
          } else {
            hashTreeExtent_ = value;
          }
          onChanged();
        } else {
          hashTreeExtentBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000400;
        return this;
      }
      /**
       * <pre>
       * The extent to store verity hash tree.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent hash_tree_extent = 11;</code>
       */
      public Builder clearHashTreeExtent() {
        if (hashTreeExtentBuilder_ == null) {
          hashTreeExtent_ = null;
          onChanged();
        } else {
          hashTreeExtentBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000400);
        return this;
      }
      /**
       * <pre>
       * The extent to store verity hash tree.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent hash_tree_extent = 11;</code>
       */
      public chromeos_update_engine.UpdateMetadata.Extent.Builder getHashTreeExtentBuilder() {
        bitField0_ |= 0x00000400;
        onChanged();
        return getHashTreeExtentFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The extent to store verity hash tree.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent hash_tree_extent = 11;</code>
       */
      public chromeos_update_engine.UpdateMetadata.ExtentOrBuilder getHashTreeExtentOrBuilder() {
        if (hashTreeExtentBuilder_ != null) {
          return hashTreeExtentBuilder_.getMessageOrBuilder();
        } else {
          return hashTreeExtent_ == null ?
              chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance() : hashTreeExtent_;
        }
      }
      /**
       * <pre>
       * The extent to store verity hash tree.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent hash_tree_extent = 11;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.Extent, chromeos_update_engine.UpdateMetadata.Extent.Builder, chromeos_update_engine.UpdateMetadata.ExtentOrBuilder>
          getHashTreeExtentFieldBuilder() {
        if (hashTreeExtentBuilder_ == null) {
          hashTreeExtentBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              chromeos_update_engine.UpdateMetadata.Extent, chromeos_update_engine.UpdateMetadata.Extent.Builder, chromeos_update_engine.UpdateMetadata.ExtentOrBuilder>(
                  getHashTreeExtent(),
                  getParentForChildren(),
                  isClean());
          hashTreeExtent_ = null;
        }
        return hashTreeExtentBuilder_;
      }

      private java.lang.Object hashTreeAlgorithm_ = "";
      /**
       * <pre>
       * The hash algorithm used in verity hash tree.
       * </pre>
       *
       * <code>optional string hash_tree_algorithm = 12;</code>
       * @return Whether the hashTreeAlgorithm field is set.
       */
      public boolean hasHashTreeAlgorithm() {
        return ((bitField0_ & 0x00000800) != 0);
      }
      /**
       * <pre>
       * The hash algorithm used in verity hash tree.
       * </pre>
       *
       * <code>optional string hash_tree_algorithm = 12;</code>
       * @return The hashTreeAlgorithm.
       */
      public java.lang.String getHashTreeAlgorithm() {
        java.lang.Object ref = hashTreeAlgorithm_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            hashTreeAlgorithm_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The hash algorithm used in verity hash tree.
       * </pre>
       *
       * <code>optional string hash_tree_algorithm = 12;</code>
       * @return The bytes for hashTreeAlgorithm.
       */
      public com.google.protobuf.ByteString
          getHashTreeAlgorithmBytes() {
        java.lang.Object ref = hashTreeAlgorithm_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          hashTreeAlgorithm_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The hash algorithm used in verity hash tree.
       * </pre>
       *
       * <code>optional string hash_tree_algorithm = 12;</code>
       * @param value The hashTreeAlgorithm to set.
       * @return This builder for chaining.
       */
      public Builder setHashTreeAlgorithm(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000800;
        hashTreeAlgorithm_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The hash algorithm used in verity hash tree.
       * </pre>
       *
       * <code>optional string hash_tree_algorithm = 12;</code>
       * @return This builder for chaining.
       */
      public Builder clearHashTreeAlgorithm() {
        bitField0_ = (bitField0_ & ~0x00000800);
        hashTreeAlgorithm_ = getDefaultInstance().getHashTreeAlgorithm();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The hash algorithm used in verity hash tree.
       * </pre>
       *
       * <code>optional string hash_tree_algorithm = 12;</code>
       * @param value The bytes for hashTreeAlgorithm to set.
       * @return This builder for chaining.
       */
      public Builder setHashTreeAlgorithmBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000800;
        hashTreeAlgorithm_ = value;
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString hashTreeSalt_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * The salt used for verity hash tree.
       * </pre>
       *
       * <code>optional bytes hash_tree_salt = 13;</code>
       * @return Whether the hashTreeSalt field is set.
       */
      @java.lang.Override
      public boolean hasHashTreeSalt() {
        return ((bitField0_ & 0x00001000) != 0);
      }
      /**
       * <pre>
       * The salt used for verity hash tree.
       * </pre>
       *
       * <code>optional bytes hash_tree_salt = 13;</code>
       * @return The hashTreeSalt.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getHashTreeSalt() {
        return hashTreeSalt_;
      }
      /**
       * <pre>
       * The salt used for verity hash tree.
       * </pre>
       *
       * <code>optional bytes hash_tree_salt = 13;</code>
       * @param value The hashTreeSalt to set.
       * @return This builder for chaining.
       */
      public Builder setHashTreeSalt(com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00001000;
        hashTreeSalt_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The salt used for verity hash tree.
       * </pre>
       *
       * <code>optional bytes hash_tree_salt = 13;</code>
       * @return This builder for chaining.
       */
      public Builder clearHashTreeSalt() {
        bitField0_ = (bitField0_ & ~0x00001000);
        hashTreeSalt_ = getDefaultInstance().getHashTreeSalt();
        onChanged();
        return this;
      }

      private chromeos_update_engine.UpdateMetadata.Extent fecDataExtent_;
      private com.google.protobuf.SingleFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.Extent, chromeos_update_engine.UpdateMetadata.Extent.Builder, chromeos_update_engine.UpdateMetadata.ExtentOrBuilder> fecDataExtentBuilder_;
      /**
       * <pre>
       * The extent for data covered by FEC.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent fec_data_extent = 14;</code>
       * @return Whether the fecDataExtent field is set.
       */
      public boolean hasFecDataExtent() {
        return ((bitField0_ & 0x00002000) != 0);
      }
      /**
       * <pre>
       * The extent for data covered by FEC.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent fec_data_extent = 14;</code>
       * @return The fecDataExtent.
       */
      public chromeos_update_engine.UpdateMetadata.Extent getFecDataExtent() {
        if (fecDataExtentBuilder_ == null) {
          return fecDataExtent_ == null ? chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance() : fecDataExtent_;
        } else {
          return fecDataExtentBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The extent for data covered by FEC.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent fec_data_extent = 14;</code>
       */
      public Builder setFecDataExtent(chromeos_update_engine.UpdateMetadata.Extent value) {
        if (fecDataExtentBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          fecDataExtent_ = value;
          onChanged();
        } else {
          fecDataExtentBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00002000;
        return this;
      }
      /**
       * <pre>
       * The extent for data covered by FEC.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent fec_data_extent = 14;</code>
       */
      public Builder setFecDataExtent(
          chromeos_update_engine.UpdateMetadata.Extent.Builder builderForValue) {
        if (fecDataExtentBuilder_ == null) {
          fecDataExtent_ = builderForValue.build();
          onChanged();
        } else {
          fecDataExtentBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00002000;
        return this;
      }
      /**
       * <pre>
       * The extent for data covered by FEC.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent fec_data_extent = 14;</code>
       */
      public Builder mergeFecDataExtent(chromeos_update_engine.UpdateMetadata.Extent value) {
        if (fecDataExtentBuilder_ == null) {
          if (((bitField0_ & 0x00002000) != 0) &&
              fecDataExtent_ != null &&
              fecDataExtent_ != chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance()) {
            fecDataExtent_ =
              chromeos_update_engine.UpdateMetadata.Extent.newBuilder(fecDataExtent_).mergeFrom(value).buildPartial();
          } else {
            fecDataExtent_ = value;
          }
          onChanged();
        } else {
          fecDataExtentBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00002000;
        return this;
      }
      /**
       * <pre>
       * The extent for data covered by FEC.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent fec_data_extent = 14;</code>
       */
      public Builder clearFecDataExtent() {
        if (fecDataExtentBuilder_ == null) {
          fecDataExtent_ = null;
          onChanged();
        } else {
          fecDataExtentBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00002000);
        return this;
      }
      /**
       * <pre>
       * The extent for data covered by FEC.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent fec_data_extent = 14;</code>
       */
      public chromeos_update_engine.UpdateMetadata.Extent.Builder getFecDataExtentBuilder() {
        bitField0_ |= 0x00002000;
        onChanged();
        return getFecDataExtentFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The extent for data covered by FEC.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent fec_data_extent = 14;</code>
       */
      public chromeos_update_engine.UpdateMetadata.ExtentOrBuilder getFecDataExtentOrBuilder() {
        if (fecDataExtentBuilder_ != null) {
          return fecDataExtentBuilder_.getMessageOrBuilder();
        } else {
          return fecDataExtent_ == null ?
              chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance() : fecDataExtent_;
        }
      }
      /**
       * <pre>
       * The extent for data covered by FEC.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent fec_data_extent = 14;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.Extent, chromeos_update_engine.UpdateMetadata.Extent.Builder, chromeos_update_engine.UpdateMetadata.ExtentOrBuilder>
          getFecDataExtentFieldBuilder() {
        if (fecDataExtentBuilder_ == null) {
          fecDataExtentBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              chromeos_update_engine.UpdateMetadata.Extent, chromeos_update_engine.UpdateMetadata.Extent.Builder, chromeos_update_engine.UpdateMetadata.ExtentOrBuilder>(
                  getFecDataExtent(),
                  getParentForChildren(),
                  isClean());
          fecDataExtent_ = null;
        }
        return fecDataExtentBuilder_;
      }

      private chromeos_update_engine.UpdateMetadata.Extent fecExtent_;
      private com.google.protobuf.SingleFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.Extent, chromeos_update_engine.UpdateMetadata.Extent.Builder, chromeos_update_engine.UpdateMetadata.ExtentOrBuilder> fecExtentBuilder_;
      /**
       * <pre>
       * The extent to store FEC.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent fec_extent = 15;</code>
       * @return Whether the fecExtent field is set.
       */
      public boolean hasFecExtent() {
        return ((bitField0_ & 0x00004000) != 0);
      }
      /**
       * <pre>
       * The extent to store FEC.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent fec_extent = 15;</code>
       * @return The fecExtent.
       */
      public chromeos_update_engine.UpdateMetadata.Extent getFecExtent() {
        if (fecExtentBuilder_ == null) {
          return fecExtent_ == null ? chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance() : fecExtent_;
        } else {
          return fecExtentBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The extent to store FEC.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent fec_extent = 15;</code>
       */
      public Builder setFecExtent(chromeos_update_engine.UpdateMetadata.Extent value) {
        if (fecExtentBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          fecExtent_ = value;
          onChanged();
        } else {
          fecExtentBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00004000;
        return this;
      }
      /**
       * <pre>
       * The extent to store FEC.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent fec_extent = 15;</code>
       */
      public Builder setFecExtent(
          chromeos_update_engine.UpdateMetadata.Extent.Builder builderForValue) {
        if (fecExtentBuilder_ == null) {
          fecExtent_ = builderForValue.build();
          onChanged();
        } else {
          fecExtentBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00004000;
        return this;
      }
      /**
       * <pre>
       * The extent to store FEC.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent fec_extent = 15;</code>
       */
      public Builder mergeFecExtent(chromeos_update_engine.UpdateMetadata.Extent value) {
        if (fecExtentBuilder_ == null) {
          if (((bitField0_ & 0x00004000) != 0) &&
              fecExtent_ != null &&
              fecExtent_ != chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance()) {
            fecExtent_ =
              chromeos_update_engine.UpdateMetadata.Extent.newBuilder(fecExtent_).mergeFrom(value).buildPartial();
          } else {
            fecExtent_ = value;
          }
          onChanged();
        } else {
          fecExtentBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00004000;
        return this;
      }
      /**
       * <pre>
       * The extent to store FEC.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent fec_extent = 15;</code>
       */
      public Builder clearFecExtent() {
        if (fecExtentBuilder_ == null) {
          fecExtent_ = null;
          onChanged();
        } else {
          fecExtentBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00004000);
        return this;
      }
      /**
       * <pre>
       * The extent to store FEC.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent fec_extent = 15;</code>
       */
      public chromeos_update_engine.UpdateMetadata.Extent.Builder getFecExtentBuilder() {
        bitField0_ |= 0x00004000;
        onChanged();
        return getFecExtentFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The extent to store FEC.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent fec_extent = 15;</code>
       */
      public chromeos_update_engine.UpdateMetadata.ExtentOrBuilder getFecExtentOrBuilder() {
        if (fecExtentBuilder_ != null) {
          return fecExtentBuilder_.getMessageOrBuilder();
        } else {
          return fecExtent_ == null ?
              chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance() : fecExtent_;
        }
      }
      /**
       * <pre>
       * The extent to store FEC.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent fec_extent = 15;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.Extent, chromeos_update_engine.UpdateMetadata.Extent.Builder, chromeos_update_engine.UpdateMetadata.ExtentOrBuilder>
          getFecExtentFieldBuilder() {
        if (fecExtentBuilder_ == null) {
          fecExtentBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              chromeos_update_engine.UpdateMetadata.Extent, chromeos_update_engine.UpdateMetadata.Extent.Builder, chromeos_update_engine.UpdateMetadata.ExtentOrBuilder>(
                  getFecExtent(),
                  getParentForChildren(),
                  isClean());
          fecExtent_ = null;
        }
        return fecExtentBuilder_;
      }

      private int fecRoots_ = 2;
      /**
       * <pre>
       * The number of FEC roots.
       * </pre>
       *
       * <code>optional uint32 fec_roots = 16 [default = 2];</code>
       * @return Whether the fecRoots field is set.
       */
      @java.lang.Override
      public boolean hasFecRoots() {
        return ((bitField0_ & 0x00008000) != 0);
      }
      /**
       * <pre>
       * The number of FEC roots.
       * </pre>
       *
       * <code>optional uint32 fec_roots = 16 [default = 2];</code>
       * @return The fecRoots.
       */
      @java.lang.Override
      public int getFecRoots() {
        return fecRoots_;
      }
      /**
       * <pre>
       * The number of FEC roots.
       * </pre>
       *
       * <code>optional uint32 fec_roots = 16 [default = 2];</code>
       * @param value The fecRoots to set.
       * @return This builder for chaining.
       */
      public Builder setFecRoots(int value) {
        bitField0_ |= 0x00008000;
        fecRoots_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The number of FEC roots.
       * </pre>
       *
       * <code>optional uint32 fec_roots = 16 [default = 2];</code>
       * @return This builder for chaining.
       */
      public Builder clearFecRoots() {
        bitField0_ = (bitField0_ & ~0x00008000);
        fecRoots_ = 2;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:chromeos_update_engine.PartitionUpdate)
    }

    // @@protoc_insertion_point(class_scope:chromeos_update_engine.PartitionUpdate)
    private static final chromeos_update_engine.UpdateMetadata.PartitionUpdate DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new chromeos_update_engine.UpdateMetadata.PartitionUpdate();
    }

    public static chromeos_update_engine.UpdateMetadata.PartitionUpdate getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<PartitionUpdate>
        PARSER = new com.google.protobuf.AbstractParser<PartitionUpdate>() {
      @java.lang.Override
      public PartitionUpdate parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new PartitionUpdate(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<PartitionUpdate> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<PartitionUpdate> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.PartitionUpdate getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface DynamicPartitionGroupOrBuilder extends
      // @@protoc_insertion_point(interface_extends:chromeos_update_engine.DynamicPartitionGroup)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Name of the group.
     * </pre>
     *
     * <code>required string name = 1;</code>
     * @return Whether the name field is set.
     */
    boolean hasName();
    /**
     * <pre>
     * Name of the group.
     * </pre>
     *
     * <code>required string name = 1;</code>
     * @return The name.
     */
    java.lang.String getName();
    /**
     * <pre>
     * Name of the group.
     * </pre>
     *
     * <code>required string name = 1;</code>
     * @return The bytes for name.
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * Maximum size of the group. The sum of sizes of all partitions in the group
     * must not exceed the maximum size of the group.
     * </pre>
     *
     * <code>optional uint64 size = 2;</code>
     * @return Whether the size field is set.
     */
    boolean hasSize();
    /**
     * <pre>
     * Maximum size of the group. The sum of sizes of all partitions in the group
     * must not exceed the maximum size of the group.
     * </pre>
     *
     * <code>optional uint64 size = 2;</code>
     * @return The size.
     */
    long getSize();

    /**
     * <pre>
     * A list of partitions that belong to the group.
     * </pre>
     *
     * <code>repeated string partition_names = 3;</code>
     * @return A list containing the partitionNames.
     */
    java.util.List<java.lang.String>
        getPartitionNamesList();
    /**
     * <pre>
     * A list of partitions that belong to the group.
     * </pre>
     *
     * <code>repeated string partition_names = 3;</code>
     * @return The count of partitionNames.
     */
    int getPartitionNamesCount();
    /**
     * <pre>
     * A list of partitions that belong to the group.
     * </pre>
     *
     * <code>repeated string partition_names = 3;</code>
     * @param index The index of the element to return.
     * @return The partitionNames at the given index.
     */
    java.lang.String getPartitionNames(int index);
    /**
     * <pre>
     * A list of partitions that belong to the group.
     * </pre>
     *
     * <code>repeated string partition_names = 3;</code>
     * @param index The index of the value to return.
     * @return The bytes of the partitionNames at the given index.
     */
    com.google.protobuf.ByteString
        getPartitionNamesBytes(int index);
  }
  /**
   * Protobuf type {@code chromeos_update_engine.DynamicPartitionGroup}
   */
  public static final class DynamicPartitionGroup extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:chromeos_update_engine.DynamicPartitionGroup)
      DynamicPartitionGroupOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use DynamicPartitionGroup.newBuilder() to construct.
    private DynamicPartitionGroup(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private DynamicPartitionGroup() {
      name_ = "";
      partitionNames_ = com.google.protobuf.LazyStringArrayList.EMPTY;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new DynamicPartitionGroup();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private DynamicPartitionGroup(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              name_ = bs;
              break;
            }
            case 16: {
              bitField0_ |= 0x00000002;
              size_ = input.readUInt64();
              break;
            }
            case 26: {
              com.google.protobuf.ByteString bs = input.readBytes();
              if (!((mutable_bitField0_ & 0x00000004) != 0)) {
                partitionNames_ = new com.google.protobuf.LazyStringArrayList();
                mutable_bitField0_ |= 0x00000004;
              }
              partitionNames_.add(bs);
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000004) != 0)) {
          partitionNames_ = partitionNames_.getUnmodifiableView();
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_DynamicPartitionGroup_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_DynamicPartitionGroup_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup.class, chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup.Builder.class);
    }

    private int bitField0_;
    public static final int NAME_FIELD_NUMBER = 1;
    private volatile java.lang.Object name_;
    /**
     * <pre>
     * Name of the group.
     * </pre>
     *
     * <code>required string name = 1;</code>
     * @return Whether the name field is set.
     */
    @java.lang.Override
    public boolean hasName() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Name of the group.
     * </pre>
     *
     * <code>required string name = 1;</code>
     * @return The name.
     */
    @java.lang.Override
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          name_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Name of the group.
     * </pre>
     *
     * <code>required string name = 1;</code>
     * @return The bytes for name.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int SIZE_FIELD_NUMBER = 2;
    private long size_;
    /**
     * <pre>
     * Maximum size of the group. The sum of sizes of all partitions in the group
     * must not exceed the maximum size of the group.
     * </pre>
     *
     * <code>optional uint64 size = 2;</code>
     * @return Whether the size field is set.
     */
    @java.lang.Override
    public boolean hasSize() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Maximum size of the group. The sum of sizes of all partitions in the group
     * must not exceed the maximum size of the group.
     * </pre>
     *
     * <code>optional uint64 size = 2;</code>
     * @return The size.
     */
    @java.lang.Override
    public long getSize() {
      return size_;
    }

    public static final int PARTITION_NAMES_FIELD_NUMBER = 3;
    private com.google.protobuf.LazyStringList partitionNames_;
    /**
     * <pre>
     * A list of partitions that belong to the group.
     * </pre>
     *
     * <code>repeated string partition_names = 3;</code>
     * @return A list containing the partitionNames.
     */
    public com.google.protobuf.ProtocolStringList
        getPartitionNamesList() {
      return partitionNames_;
    }
    /**
     * <pre>
     * A list of partitions that belong to the group.
     * </pre>
     *
     * <code>repeated string partition_names = 3;</code>
     * @return The count of partitionNames.
     */
    public int getPartitionNamesCount() {
      return partitionNames_.size();
    }
    /**
     * <pre>
     * A list of partitions that belong to the group.
     * </pre>
     *
     * <code>repeated string partition_names = 3;</code>
     * @param index The index of the element to return.
     * @return The partitionNames at the given index.
     */
    public java.lang.String getPartitionNames(int index) {
      return partitionNames_.get(index);
    }
    /**
     * <pre>
     * A list of partitions that belong to the group.
     * </pre>
     *
     * <code>repeated string partition_names = 3;</code>
     * @param index The index of the value to return.
     * @return The bytes of the partitionNames at the given index.
     */
    public com.google.protobuf.ByteString
        getPartitionNamesBytes(int index) {
      return partitionNames_.getByteString(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (!hasName()) {
        memoizedIsInitialized = 0;
        return false;
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, name_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeUInt64(2, size_);
      }
      for (int i = 0; i < partitionNames_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, partitionNames_.getRaw(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, name_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(2, size_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < partitionNames_.size(); i++) {
          dataSize += computeStringSizeNoTag(partitionNames_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getPartitionNamesList().size();
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup)) {
        return super.equals(obj);
      }
      chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup other = (chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup) obj;

      if (hasName() != other.hasName()) return false;
      if (hasName()) {
        if (!getName()
            .equals(other.getName())) return false;
      }
      if (hasSize() != other.hasSize()) return false;
      if (hasSize()) {
        if (getSize()
            != other.getSize()) return false;
      }
      if (!getPartitionNamesList()
          .equals(other.getPartitionNamesList())) return false;
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasName()) {
        hash = (37 * hash) + NAME_FIELD_NUMBER;
        hash = (53 * hash) + getName().hashCode();
      }
      if (hasSize()) {
        hash = (37 * hash) + SIZE_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getSize());
      }
      if (getPartitionNamesCount() > 0) {
        hash = (37 * hash) + PARTITION_NAMES_FIELD_NUMBER;
        hash = (53 * hash) + getPartitionNamesList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code chromeos_update_engine.DynamicPartitionGroup}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:chromeos_update_engine.DynamicPartitionGroup)
        chromeos_update_engine.UpdateMetadata.DynamicPartitionGroupOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_DynamicPartitionGroup_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_DynamicPartitionGroup_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup.class, chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup.Builder.class);
      }

      // Construct using chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        name_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        size_ = 0L;
        bitField0_ = (bitField0_ & ~0x00000002);
        partitionNames_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_DynamicPartitionGroup_descriptor;
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup getDefaultInstanceForType() {
        return chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup.getDefaultInstance();
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup build() {
        chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup buildPartial() {
        chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup result = new chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          to_bitField0_ |= 0x00000001;
        }
        result.name_ = name_;
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.size_ = size_;
          to_bitField0_ |= 0x00000002;
        }
        if (((bitField0_ & 0x00000004) != 0)) {
          partitionNames_ = partitionNames_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00000004);
        }
        result.partitionNames_ = partitionNames_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup) {
          return mergeFrom((chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup other) {
        if (other == chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup.getDefaultInstance()) return this;
        if (other.hasName()) {
          bitField0_ |= 0x00000001;
          name_ = other.name_;
          onChanged();
        }
        if (other.hasSize()) {
          setSize(other.getSize());
        }
        if (!other.partitionNames_.isEmpty()) {
          if (partitionNames_.isEmpty()) {
            partitionNames_ = other.partitionNames_;
            bitField0_ = (bitField0_ & ~0x00000004);
          } else {
            ensurePartitionNamesIsMutable();
            partitionNames_.addAll(other.partitionNames_);
          }
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        if (!hasName()) {
          return false;
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * Name of the group.
       * </pre>
       *
       * <code>required string name = 1;</code>
       * @return Whether the name field is set.
       */
      public boolean hasName() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Name of the group.
       * </pre>
       *
       * <code>required string name = 1;</code>
       * @return The name.
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            name_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Name of the group.
       * </pre>
       *
       * <code>required string name = 1;</code>
       * @return The bytes for name.
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Name of the group.
       * </pre>
       *
       * <code>required string name = 1;</code>
       * @param value The name to set.
       * @return This builder for chaining.
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        name_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Name of the group.
       * </pre>
       *
       * <code>required string name = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearName() {
        bitField0_ = (bitField0_ & ~0x00000001);
        name_ = getDefaultInstance().getName();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Name of the group.
       * </pre>
       *
       * <code>required string name = 1;</code>
       * @param value The bytes for name to set.
       * @return This builder for chaining.
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        name_ = value;
        onChanged();
        return this;
      }

      private long size_ ;
      /**
       * <pre>
       * Maximum size of the group. The sum of sizes of all partitions in the group
       * must not exceed the maximum size of the group.
       * </pre>
       *
       * <code>optional uint64 size = 2;</code>
       * @return Whether the size field is set.
       */
      @java.lang.Override
      public boolean hasSize() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Maximum size of the group. The sum of sizes of all partitions in the group
       * must not exceed the maximum size of the group.
       * </pre>
       *
       * <code>optional uint64 size = 2;</code>
       * @return The size.
       */
      @java.lang.Override
      public long getSize() {
        return size_;
      }
      /**
       * <pre>
       * Maximum size of the group. The sum of sizes of all partitions in the group
       * must not exceed the maximum size of the group.
       * </pre>
       *
       * <code>optional uint64 size = 2;</code>
       * @param value The size to set.
       * @return This builder for chaining.
       */
      public Builder setSize(long value) {
        bitField0_ |= 0x00000002;
        size_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Maximum size of the group. The sum of sizes of all partitions in the group
       * must not exceed the maximum size of the group.
       * </pre>
       *
       * <code>optional uint64 size = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearSize() {
        bitField0_ = (bitField0_ & ~0x00000002);
        size_ = 0L;
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringList partitionNames_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      private void ensurePartitionNamesIsMutable() {
        if (!((bitField0_ & 0x00000004) != 0)) {
          partitionNames_ = new com.google.protobuf.LazyStringArrayList(partitionNames_);
          bitField0_ |= 0x00000004;
         }
      }
      /**
       * <pre>
       * A list of partitions that belong to the group.
       * </pre>
       *
       * <code>repeated string partition_names = 3;</code>
       * @return A list containing the partitionNames.
       */
      public com.google.protobuf.ProtocolStringList
          getPartitionNamesList() {
        return partitionNames_.getUnmodifiableView();
      }
      /**
       * <pre>
       * A list of partitions that belong to the group.
       * </pre>
       *
       * <code>repeated string partition_names = 3;</code>
       * @return The count of partitionNames.
       */
      public int getPartitionNamesCount() {
        return partitionNames_.size();
      }
      /**
       * <pre>
       * A list of partitions that belong to the group.
       * </pre>
       *
       * <code>repeated string partition_names = 3;</code>
       * @param index The index of the element to return.
       * @return The partitionNames at the given index.
       */
      public java.lang.String getPartitionNames(int index) {
        return partitionNames_.get(index);
      }
      /**
       * <pre>
       * A list of partitions that belong to the group.
       * </pre>
       *
       * <code>repeated string partition_names = 3;</code>
       * @param index The index of the value to return.
       * @return The bytes of the partitionNames at the given index.
       */
      public com.google.protobuf.ByteString
          getPartitionNamesBytes(int index) {
        return partitionNames_.getByteString(index);
      }
      /**
       * <pre>
       * A list of partitions that belong to the group.
       * </pre>
       *
       * <code>repeated string partition_names = 3;</code>
       * @param index The index to set the value at.
       * @param value The partitionNames to set.
       * @return This builder for chaining.
       */
      public Builder setPartitionNames(
          int index, java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensurePartitionNamesIsMutable();
        partitionNames_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A list of partitions that belong to the group.
       * </pre>
       *
       * <code>repeated string partition_names = 3;</code>
       * @param value The partitionNames to add.
       * @return This builder for chaining.
       */
      public Builder addPartitionNames(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensurePartitionNamesIsMutable();
        partitionNames_.add(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A list of partitions that belong to the group.
       * </pre>
       *
       * <code>repeated string partition_names = 3;</code>
       * @param values The partitionNames to add.
       * @return This builder for chaining.
       */
      public Builder addAllPartitionNames(
          java.lang.Iterable<java.lang.String> values) {
        ensurePartitionNamesIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, partitionNames_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A list of partitions that belong to the group.
       * </pre>
       *
       * <code>repeated string partition_names = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearPartitionNames() {
        partitionNames_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000004);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A list of partitions that belong to the group.
       * </pre>
       *
       * <code>repeated string partition_names = 3;</code>
       * @param value The bytes of the partitionNames to add.
       * @return This builder for chaining.
       */
      public Builder addPartitionNamesBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensurePartitionNamesIsMutable();
        partitionNames_.add(value);
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:chromeos_update_engine.DynamicPartitionGroup)
    }

    // @@protoc_insertion_point(class_scope:chromeos_update_engine.DynamicPartitionGroup)
    private static final chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup();
    }

    public static chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<DynamicPartitionGroup>
        PARSER = new com.google.protobuf.AbstractParser<DynamicPartitionGroup>() {
      @java.lang.Override
      public DynamicPartitionGroup parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new DynamicPartitionGroup(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<DynamicPartitionGroup> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<DynamicPartitionGroup> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface DynamicPartitionMetadataOrBuilder extends
      // @@protoc_insertion_point(interface_extends:chromeos_update_engine.DynamicPartitionMetadata)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * All updatable groups present in |partitions| of this DeltaArchiveManifest.
     * - If an updatable group is on the device but not in the manifest, it is
     *   not updated. Hence, the group will not be resized, and partitions cannot
     *   be added to or removed from the group.
     * - If an updatable group is in the manifest but not on the device, the group
     *   is added to the device.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;</code>
     */
    java.util.List<chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup>
        getGroupsList();
    /**
     * <pre>
     * All updatable groups present in |partitions| of this DeltaArchiveManifest.
     * - If an updatable group is on the device but not in the manifest, it is
     *   not updated. Hence, the group will not be resized, and partitions cannot
     *   be added to or removed from the group.
     * - If an updatable group is in the manifest but not on the device, the group
     *   is added to the device.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;</code>
     */
    chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup getGroups(int index);
    /**
     * <pre>
     * All updatable groups present in |partitions| of this DeltaArchiveManifest.
     * - If an updatable group is on the device but not in the manifest, it is
     *   not updated. Hence, the group will not be resized, and partitions cannot
     *   be added to or removed from the group.
     * - If an updatable group is in the manifest but not on the device, the group
     *   is added to the device.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;</code>
     */
    int getGroupsCount();
    /**
     * <pre>
     * All updatable groups present in |partitions| of this DeltaArchiveManifest.
     * - If an updatable group is on the device but not in the manifest, it is
     *   not updated. Hence, the group will not be resized, and partitions cannot
     *   be added to or removed from the group.
     * - If an updatable group is in the manifest but not on the device, the group
     *   is added to the device.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;</code>
     */
    java.util.List<? extends chromeos_update_engine.UpdateMetadata.DynamicPartitionGroupOrBuilder>
        getGroupsOrBuilderList();
    /**
     * <pre>
     * All updatable groups present in |partitions| of this DeltaArchiveManifest.
     * - If an updatable group is on the device but not in the manifest, it is
     *   not updated. Hence, the group will not be resized, and partitions cannot
     *   be added to or removed from the group.
     * - If an updatable group is in the manifest but not on the device, the group
     *   is added to the device.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;</code>
     */
    chromeos_update_engine.UpdateMetadata.DynamicPartitionGroupOrBuilder getGroupsOrBuilder(
        int index);

    /**
     * <pre>
     * Whether dynamic partitions have snapshots during the update. If this is
     * set to true, the update_engine daemon creates snapshots for all dynamic
     * partitions if possible. If this is unset, the update_engine daemon MUST
     * NOT create snapshots for dynamic partitions.
     * </pre>
     *
     * <code>optional bool snapshot_enabled = 2;</code>
     * @return Whether the snapshotEnabled field is set.
     */
    boolean hasSnapshotEnabled();
    /**
     * <pre>
     * Whether dynamic partitions have snapshots during the update. If this is
     * set to true, the update_engine daemon creates snapshots for all dynamic
     * partitions if possible. If this is unset, the update_engine daemon MUST
     * NOT create snapshots for dynamic partitions.
     * </pre>
     *
     * <code>optional bool snapshot_enabled = 2;</code>
     * @return The snapshotEnabled.
     */
    boolean getSnapshotEnabled();
  }
  /**
   * <pre>
   * Metadata related to all dynamic partitions.
   * </pre>
   *
   * Protobuf type {@code chromeos_update_engine.DynamicPartitionMetadata}
   */
  public static final class DynamicPartitionMetadata extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:chromeos_update_engine.DynamicPartitionMetadata)
      DynamicPartitionMetadataOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use DynamicPartitionMetadata.newBuilder() to construct.
    private DynamicPartitionMetadata(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private DynamicPartitionMetadata() {
      groups_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new DynamicPartitionMetadata();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private DynamicPartitionMetadata(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              if (!((mutable_bitField0_ & 0x00000001) != 0)) {
                groups_ = new java.util.ArrayList<chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup>();
                mutable_bitField0_ |= 0x00000001;
              }
              groups_.add(
                  input.readMessage(chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup.PARSER, extensionRegistry));
              break;
            }
            case 16: {
              bitField0_ |= 0x00000001;
              snapshotEnabled_ = input.readBool();
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) != 0)) {
          groups_ = java.util.Collections.unmodifiableList(groups_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_DynamicPartitionMetadata_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_DynamicPartitionMetadata_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata.class, chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata.Builder.class);
    }

    private int bitField0_;
    public static final int GROUPS_FIELD_NUMBER = 1;
    private java.util.List<chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup> groups_;
    /**
     * <pre>
     * All updatable groups present in |partitions| of this DeltaArchiveManifest.
     * - If an updatable group is on the device but not in the manifest, it is
     *   not updated. Hence, the group will not be resized, and partitions cannot
     *   be added to or removed from the group.
     * - If an updatable group is in the manifest but not on the device, the group
     *   is added to the device.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;</code>
     */
    @java.lang.Override
    public java.util.List<chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup> getGroupsList() {
      return groups_;
    }
    /**
     * <pre>
     * All updatable groups present in |partitions| of this DeltaArchiveManifest.
     * - If an updatable group is on the device but not in the manifest, it is
     *   not updated. Hence, the group will not be resized, and partitions cannot
     *   be added to or removed from the group.
     * - If an updatable group is in the manifest but not on the device, the group
     *   is added to the device.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;</code>
     */
    @java.lang.Override
    public java.util.List<? extends chromeos_update_engine.UpdateMetadata.DynamicPartitionGroupOrBuilder>
        getGroupsOrBuilderList() {
      return groups_;
    }
    /**
     * <pre>
     * All updatable groups present in |partitions| of this DeltaArchiveManifest.
     * - If an updatable group is on the device but not in the manifest, it is
     *   not updated. Hence, the group will not be resized, and partitions cannot
     *   be added to or removed from the group.
     * - If an updatable group is in the manifest but not on the device, the group
     *   is added to the device.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;</code>
     */
    @java.lang.Override
    public int getGroupsCount() {
      return groups_.size();
    }
    /**
     * <pre>
     * All updatable groups present in |partitions| of this DeltaArchiveManifest.
     * - If an updatable group is on the device but not in the manifest, it is
     *   not updated. Hence, the group will not be resized, and partitions cannot
     *   be added to or removed from the group.
     * - If an updatable group is in the manifest but not on the device, the group
     *   is added to the device.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup getGroups(int index) {
      return groups_.get(index);
    }
    /**
     * <pre>
     * All updatable groups present in |partitions| of this DeltaArchiveManifest.
     * - If an updatable group is on the device but not in the manifest, it is
     *   not updated. Hence, the group will not be resized, and partitions cannot
     *   be added to or removed from the group.
     * - If an updatable group is in the manifest but not on the device, the group
     *   is added to the device.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.DynamicPartitionGroupOrBuilder getGroupsOrBuilder(
        int index) {
      return groups_.get(index);
    }

    public static final int SNAPSHOT_ENABLED_FIELD_NUMBER = 2;
    private boolean snapshotEnabled_;
    /**
     * <pre>
     * Whether dynamic partitions have snapshots during the update. If this is
     * set to true, the update_engine daemon creates snapshots for all dynamic
     * partitions if possible. If this is unset, the update_engine daemon MUST
     * NOT create snapshots for dynamic partitions.
     * </pre>
     *
     * <code>optional bool snapshot_enabled = 2;</code>
     * @return Whether the snapshotEnabled field is set.
     */
    @java.lang.Override
    public boolean hasSnapshotEnabled() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Whether dynamic partitions have snapshots during the update. If this is
     * set to true, the update_engine daemon creates snapshots for all dynamic
     * partitions if possible. If this is unset, the update_engine daemon MUST
     * NOT create snapshots for dynamic partitions.
     * </pre>
     *
     * <code>optional bool snapshot_enabled = 2;</code>
     * @return The snapshotEnabled.
     */
    @java.lang.Override
    public boolean getSnapshotEnabled() {
      return snapshotEnabled_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      for (int i = 0; i < getGroupsCount(); i++) {
        if (!getGroups(i).isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < groups_.size(); i++) {
        output.writeMessage(1, groups_.get(i));
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeBool(2, snapshotEnabled_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < groups_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, groups_.get(i));
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(2, snapshotEnabled_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata)) {
        return super.equals(obj);
      }
      chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata other = (chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata) obj;

      if (!getGroupsList()
          .equals(other.getGroupsList())) return false;
      if (hasSnapshotEnabled() != other.hasSnapshotEnabled()) return false;
      if (hasSnapshotEnabled()) {
        if (getSnapshotEnabled()
            != other.getSnapshotEnabled()) return false;
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getGroupsCount() > 0) {
        hash = (37 * hash) + GROUPS_FIELD_NUMBER;
        hash = (53 * hash) + getGroupsList().hashCode();
      }
      if (hasSnapshotEnabled()) {
        hash = (37 * hash) + SNAPSHOT_ENABLED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getSnapshotEnabled());
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Metadata related to all dynamic partitions.
     * </pre>
     *
     * Protobuf type {@code chromeos_update_engine.DynamicPartitionMetadata}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:chromeos_update_engine.DynamicPartitionMetadata)
        chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadataOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_DynamicPartitionMetadata_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_DynamicPartitionMetadata_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata.class, chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata.Builder.class);
      }

      // Construct using chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getGroupsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (groupsBuilder_ == null) {
          groups_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
        } else {
          groupsBuilder_.clear();
        }
        snapshotEnabled_ = false;
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_DynamicPartitionMetadata_descriptor;
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata getDefaultInstanceForType() {
        return chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata.getDefaultInstance();
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata build() {
        chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata buildPartial() {
        chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata result = new chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (groupsBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0)) {
            groups_ = java.util.Collections.unmodifiableList(groups_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.groups_ = groups_;
        } else {
          result.groups_ = groupsBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.snapshotEnabled_ = snapshotEnabled_;
          to_bitField0_ |= 0x00000001;
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata) {
          return mergeFrom((chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata other) {
        if (other == chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata.getDefaultInstance()) return this;
        if (groupsBuilder_ == null) {
          if (!other.groups_.isEmpty()) {
            if (groups_.isEmpty()) {
              groups_ = other.groups_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureGroupsIsMutable();
              groups_.addAll(other.groups_);
            }
            onChanged();
          }
        } else {
          if (!other.groups_.isEmpty()) {
            if (groupsBuilder_.isEmpty()) {
              groupsBuilder_.dispose();
              groupsBuilder_ = null;
              groups_ = other.groups_;
              bitField0_ = (bitField0_ & ~0x00000001);
              groupsBuilder_ =
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getGroupsFieldBuilder() : null;
            } else {
              groupsBuilder_.addAllMessages(other.groups_);
            }
          }
        }
        if (other.hasSnapshotEnabled()) {
          setSnapshotEnabled(other.getSnapshotEnabled());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        for (int i = 0; i < getGroupsCount(); i++) {
          if (!getGroups(i).isInitialized()) {
            return false;
          }
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.util.List<chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup> groups_ =
        java.util.Collections.emptyList();
      private void ensureGroupsIsMutable() {
        if (!((bitField0_ & 0x00000001) != 0)) {
          groups_ = new java.util.ArrayList<chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup>(groups_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup, chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup.Builder, chromeos_update_engine.UpdateMetadata.DynamicPartitionGroupOrBuilder> groupsBuilder_;

      /**
       * <pre>
       * All updatable groups present in |partitions| of this DeltaArchiveManifest.
       * - If an updatable group is on the device but not in the manifest, it is
       *   not updated. Hence, the group will not be resized, and partitions cannot
       *   be added to or removed from the group.
       * - If an updatable group is in the manifest but not on the device, the group
       *   is added to the device.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;</code>
       */
      public java.util.List<chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup> getGroupsList() {
        if (groupsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(groups_);
        } else {
          return groupsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * All updatable groups present in |partitions| of this DeltaArchiveManifest.
       * - If an updatable group is on the device but not in the manifest, it is
       *   not updated. Hence, the group will not be resized, and partitions cannot
       *   be added to or removed from the group.
       * - If an updatable group is in the manifest but not on the device, the group
       *   is added to the device.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;</code>
       */
      public int getGroupsCount() {
        if (groupsBuilder_ == null) {
          return groups_.size();
        } else {
          return groupsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * All updatable groups present in |partitions| of this DeltaArchiveManifest.
       * - If an updatable group is on the device but not in the manifest, it is
       *   not updated. Hence, the group will not be resized, and partitions cannot
       *   be added to or removed from the group.
       * - If an updatable group is in the manifest but not on the device, the group
       *   is added to the device.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;</code>
       */
      public chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup getGroups(int index) {
        if (groupsBuilder_ == null) {
          return groups_.get(index);
        } else {
          return groupsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * All updatable groups present in |partitions| of this DeltaArchiveManifest.
       * - If an updatable group is on the device but not in the manifest, it is
       *   not updated. Hence, the group will not be resized, and partitions cannot
       *   be added to or removed from the group.
       * - If an updatable group is in the manifest but not on the device, the group
       *   is added to the device.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;</code>
       */
      public Builder setGroups(
          int index, chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup value) {
        if (groupsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureGroupsIsMutable();
          groups_.set(index, value);
          onChanged();
        } else {
          groupsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * All updatable groups present in |partitions| of this DeltaArchiveManifest.
       * - If an updatable group is on the device but not in the manifest, it is
       *   not updated. Hence, the group will not be resized, and partitions cannot
       *   be added to or removed from the group.
       * - If an updatable group is in the manifest but not on the device, the group
       *   is added to the device.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;</code>
       */
      public Builder setGroups(
          int index, chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup.Builder builderForValue) {
        if (groupsBuilder_ == null) {
          ensureGroupsIsMutable();
          groups_.set(index, builderForValue.build());
          onChanged();
        } else {
          groupsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * All updatable groups present in |partitions| of this DeltaArchiveManifest.
       * - If an updatable group is on the device but not in the manifest, it is
       *   not updated. Hence, the group will not be resized, and partitions cannot
       *   be added to or removed from the group.
       * - If an updatable group is in the manifest but not on the device, the group
       *   is added to the device.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;</code>
       */
      public Builder addGroups(chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup value) {
        if (groupsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureGroupsIsMutable();
          groups_.add(value);
          onChanged();
        } else {
          groupsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * All updatable groups present in |partitions| of this DeltaArchiveManifest.
       * - If an updatable group is on the device but not in the manifest, it is
       *   not updated. Hence, the group will not be resized, and partitions cannot
       *   be added to or removed from the group.
       * - If an updatable group is in the manifest but not on the device, the group
       *   is added to the device.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;</code>
       */
      public Builder addGroups(
          int index, chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup value) {
        if (groupsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureGroupsIsMutable();
          groups_.add(index, value);
          onChanged();
        } else {
          groupsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * All updatable groups present in |partitions| of this DeltaArchiveManifest.
       * - If an updatable group is on the device but not in the manifest, it is
       *   not updated. Hence, the group will not be resized, and partitions cannot
       *   be added to or removed from the group.
       * - If an updatable group is in the manifest but not on the device, the group
       *   is added to the device.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;</code>
       */
      public Builder addGroups(
          chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup.Builder builderForValue) {
        if (groupsBuilder_ == null) {
          ensureGroupsIsMutable();
          groups_.add(builderForValue.build());
          onChanged();
        } else {
          groupsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * All updatable groups present in |partitions| of this DeltaArchiveManifest.
       * - If an updatable group is on the device but not in the manifest, it is
       *   not updated. Hence, the group will not be resized, and partitions cannot
       *   be added to or removed from the group.
       * - If an updatable group is in the manifest but not on the device, the group
       *   is added to the device.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;</code>
       */
      public Builder addGroups(
          int index, chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup.Builder builderForValue) {
        if (groupsBuilder_ == null) {
          ensureGroupsIsMutable();
          groups_.add(index, builderForValue.build());
          onChanged();
        } else {
          groupsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * All updatable groups present in |partitions| of this DeltaArchiveManifest.
       * - If an updatable group is on the device but not in the manifest, it is
       *   not updated. Hence, the group will not be resized, and partitions cannot
       *   be added to or removed from the group.
       * - If an updatable group is in the manifest but not on the device, the group
       *   is added to the device.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;</code>
       */
      public Builder addAllGroups(
          java.lang.Iterable<? extends chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup> values) {
        if (groupsBuilder_ == null) {
          ensureGroupsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, groups_);
          onChanged();
        } else {
          groupsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * All updatable groups present in |partitions| of this DeltaArchiveManifest.
       * - If an updatable group is on the device but not in the manifest, it is
       *   not updated. Hence, the group will not be resized, and partitions cannot
       *   be added to or removed from the group.
       * - If an updatable group is in the manifest but not on the device, the group
       *   is added to the device.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;</code>
       */
      public Builder clearGroups() {
        if (groupsBuilder_ == null) {
          groups_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          groupsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * All updatable groups present in |partitions| of this DeltaArchiveManifest.
       * - If an updatable group is on the device but not in the manifest, it is
       *   not updated. Hence, the group will not be resized, and partitions cannot
       *   be added to or removed from the group.
       * - If an updatable group is in the manifest but not on the device, the group
       *   is added to the device.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;</code>
       */
      public Builder removeGroups(int index) {
        if (groupsBuilder_ == null) {
          ensureGroupsIsMutable();
          groups_.remove(index);
          onChanged();
        } else {
          groupsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * All updatable groups present in |partitions| of this DeltaArchiveManifest.
       * - If an updatable group is on the device but not in the manifest, it is
       *   not updated. Hence, the group will not be resized, and partitions cannot
       *   be added to or removed from the group.
       * - If an updatable group is in the manifest but not on the device, the group
       *   is added to the device.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;</code>
       */
      public chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup.Builder getGroupsBuilder(
          int index) {
        return getGroupsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * All updatable groups present in |partitions| of this DeltaArchiveManifest.
       * - If an updatable group is on the device but not in the manifest, it is
       *   not updated. Hence, the group will not be resized, and partitions cannot
       *   be added to or removed from the group.
       * - If an updatable group is in the manifest but not on the device, the group
       *   is added to the device.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;</code>
       */
      public chromeos_update_engine.UpdateMetadata.DynamicPartitionGroupOrBuilder getGroupsOrBuilder(
          int index) {
        if (groupsBuilder_ == null) {
          return groups_.get(index);  } else {
          return groupsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * All updatable groups present in |partitions| of this DeltaArchiveManifest.
       * - If an updatable group is on the device but not in the manifest, it is
       *   not updated. Hence, the group will not be resized, and partitions cannot
       *   be added to or removed from the group.
       * - If an updatable group is in the manifest but not on the device, the group
       *   is added to the device.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;</code>
       */
      public java.util.List<? extends chromeos_update_engine.UpdateMetadata.DynamicPartitionGroupOrBuilder>
           getGroupsOrBuilderList() {
        if (groupsBuilder_ != null) {
          return groupsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(groups_);
        }
      }
      /**
       * <pre>
       * All updatable groups present in |partitions| of this DeltaArchiveManifest.
       * - If an updatable group is on the device but not in the manifest, it is
       *   not updated. Hence, the group will not be resized, and partitions cannot
       *   be added to or removed from the group.
       * - If an updatable group is in the manifest but not on the device, the group
       *   is added to the device.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;</code>
       */
      public chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup.Builder addGroupsBuilder() {
        return getGroupsFieldBuilder().addBuilder(
            chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup.getDefaultInstance());
      }
      /**
       * <pre>
       * All updatable groups present in |partitions| of this DeltaArchiveManifest.
       * - If an updatable group is on the device but not in the manifest, it is
       *   not updated. Hence, the group will not be resized, and partitions cannot
       *   be added to or removed from the group.
       * - If an updatable group is in the manifest but not on the device, the group
       *   is added to the device.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;</code>
       */
      public chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup.Builder addGroupsBuilder(
          int index) {
        return getGroupsFieldBuilder().addBuilder(
            index, chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup.getDefaultInstance());
      }
      /**
       * <pre>
       * All updatable groups present in |partitions| of this DeltaArchiveManifest.
       * - If an updatable group is on the device but not in the manifest, it is
       *   not updated. Hence, the group will not be resized, and partitions cannot
       *   be added to or removed from the group.
       * - If an updatable group is in the manifest but not on the device, the group
       *   is added to the device.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;</code>
       */
      public java.util.List<chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup.Builder>
           getGroupsBuilderList() {
        return getGroupsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup, chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup.Builder, chromeos_update_engine.UpdateMetadata.DynamicPartitionGroupOrBuilder>
          getGroupsFieldBuilder() {
        if (groupsBuilder_ == null) {
          groupsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup, chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup.Builder, chromeos_update_engine.UpdateMetadata.DynamicPartitionGroupOrBuilder>(
                  groups_,
                  ((bitField0_ & 0x00000001) != 0),
                  getParentForChildren(),
                  isClean());
          groups_ = null;
        }
        return groupsBuilder_;
      }

      private boolean snapshotEnabled_ ;
      /**
       * <pre>
       * Whether dynamic partitions have snapshots during the update. If this is
       * set to true, the update_engine daemon creates snapshots for all dynamic
       * partitions if possible. If this is unset, the update_engine daemon MUST
       * NOT create snapshots for dynamic partitions.
       * </pre>
       *
       * <code>optional bool snapshot_enabled = 2;</code>
       * @return Whether the snapshotEnabled field is set.
       */
      @java.lang.Override
      public boolean hasSnapshotEnabled() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Whether dynamic partitions have snapshots during the update. If this is
       * set to true, the update_engine daemon creates snapshots for all dynamic
       * partitions if possible. If this is unset, the update_engine daemon MUST
       * NOT create snapshots for dynamic partitions.
       * </pre>
       *
       * <code>optional bool snapshot_enabled = 2;</code>
       * @return The snapshotEnabled.
       */
      @java.lang.Override
      public boolean getSnapshotEnabled() {
        return snapshotEnabled_;
      }
      /**
       * <pre>
       * Whether dynamic partitions have snapshots during the update. If this is
       * set to true, the update_engine daemon creates snapshots for all dynamic
       * partitions if possible. If this is unset, the update_engine daemon MUST
       * NOT create snapshots for dynamic partitions.
       * </pre>
       *
       * <code>optional bool snapshot_enabled = 2;</code>
       * @param value The snapshotEnabled to set.
       * @return This builder for chaining.
       */
      public Builder setSnapshotEnabled(boolean value) {
        bitField0_ |= 0x00000002;
        snapshotEnabled_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether dynamic partitions have snapshots during the update. If this is
       * set to true, the update_engine daemon creates snapshots for all dynamic
       * partitions if possible. If this is unset, the update_engine daemon MUST
       * NOT create snapshots for dynamic partitions.
       * </pre>
       *
       * <code>optional bool snapshot_enabled = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearSnapshotEnabled() {
        bitField0_ = (bitField0_ & ~0x00000002);
        snapshotEnabled_ = false;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:chromeos_update_engine.DynamicPartitionMetadata)
    }

    // @@protoc_insertion_point(class_scope:chromeos_update_engine.DynamicPartitionMetadata)
    private static final chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata();
    }

    public static chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<DynamicPartitionMetadata>
        PARSER = new com.google.protobuf.AbstractParser<DynamicPartitionMetadata>() {
      @java.lang.Override
      public DynamicPartitionMetadata parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new DynamicPartitionMetadata(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<DynamicPartitionMetadata> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<DynamicPartitionMetadata> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface DeltaArchiveManifestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:chromeos_update_engine.DeltaArchiveManifest)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Only present in major version = 1. List of install operations for the
     * kernel and rootfs partitions. For major version = 2 see the |partitions|
     * field.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.InstallOperation install_operations = 1;</code>
     */
    java.util.List<chromeos_update_engine.UpdateMetadata.InstallOperation>
        getInstallOperationsList();
    /**
     * <pre>
     * Only present in major version = 1. List of install operations for the
     * kernel and rootfs partitions. For major version = 2 see the |partitions|
     * field.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.InstallOperation install_operations = 1;</code>
     */
    chromeos_update_engine.UpdateMetadata.InstallOperation getInstallOperations(int index);
    /**
     * <pre>
     * Only present in major version = 1. List of install operations for the
     * kernel and rootfs partitions. For major version = 2 see the |partitions|
     * field.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.InstallOperation install_operations = 1;</code>
     */
    int getInstallOperationsCount();
    /**
     * <pre>
     * Only present in major version = 1. List of install operations for the
     * kernel and rootfs partitions. For major version = 2 see the |partitions|
     * field.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.InstallOperation install_operations = 1;</code>
     */
    java.util.List<? extends chromeos_update_engine.UpdateMetadata.InstallOperationOrBuilder>
        getInstallOperationsOrBuilderList();
    /**
     * <pre>
     * Only present in major version = 1. List of install operations for the
     * kernel and rootfs partitions. For major version = 2 see the |partitions|
     * field.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.InstallOperation install_operations = 1;</code>
     */
    chromeos_update_engine.UpdateMetadata.InstallOperationOrBuilder getInstallOperationsOrBuilder(
        int index);

    /**
     * <code>repeated .chromeos_update_engine.InstallOperation kernel_install_operations = 2;</code>
     */
    java.util.List<chromeos_update_engine.UpdateMetadata.InstallOperation>
        getKernelInstallOperationsList();
    /**
     * <code>repeated .chromeos_update_engine.InstallOperation kernel_install_operations = 2;</code>
     */
    chromeos_update_engine.UpdateMetadata.InstallOperation getKernelInstallOperations(int index);
    /**
     * <code>repeated .chromeos_update_engine.InstallOperation kernel_install_operations = 2;</code>
     */
    int getKernelInstallOperationsCount();
    /**
     * <code>repeated .chromeos_update_engine.InstallOperation kernel_install_operations = 2;</code>
     */
    java.util.List<? extends chromeos_update_engine.UpdateMetadata.InstallOperationOrBuilder>
        getKernelInstallOperationsOrBuilderList();
    /**
     * <code>repeated .chromeos_update_engine.InstallOperation kernel_install_operations = 2;</code>
     */
    chromeos_update_engine.UpdateMetadata.InstallOperationOrBuilder getKernelInstallOperationsOrBuilder(
        int index);

    /**
     * <pre>
     * (At time of writing) usually 4096
     * </pre>
     *
     * <code>optional uint32 block_size = 3 [default = 4096];</code>
     * @return Whether the blockSize field is set.
     */
    boolean hasBlockSize();
    /**
     * <pre>
     * (At time of writing) usually 4096
     * </pre>
     *
     * <code>optional uint32 block_size = 3 [default = 4096];</code>
     * @return The blockSize.
     */
    int getBlockSize();

    /**
     * <pre>
     * If signatures are present, the offset into the blobs, generally
     * tacked onto the end of the file, and the length. We use an offset
     * rather than a bool to allow for more flexibility in future file formats.
     * If either is absent, it means signatures aren't supported in this
     * file.
     * </pre>
     *
     * <code>optional uint64 signatures_offset = 4;</code>
     * @return Whether the signaturesOffset field is set.
     */
    boolean hasSignaturesOffset();
    /**
     * <pre>
     * If signatures are present, the offset into the blobs, generally
     * tacked onto the end of the file, and the length. We use an offset
     * rather than a bool to allow for more flexibility in future file formats.
     * If either is absent, it means signatures aren't supported in this
     * file.
     * </pre>
     *
     * <code>optional uint64 signatures_offset = 4;</code>
     * @return The signaturesOffset.
     */
    long getSignaturesOffset();

    /**
     * <code>optional uint64 signatures_size = 5;</code>
     * @return Whether the signaturesSize field is set.
     */
    boolean hasSignaturesSize();
    /**
     * <code>optional uint64 signatures_size = 5;</code>
     * @return The signaturesSize.
     */
    long getSignaturesSize();

    /**
     * <pre>
     * Only present in major version = 1. Partition metadata used to validate the
     * update. For major version = 2 see the |partitions| field.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.PartitionInfo old_kernel_info = 6;</code>
     * @return Whether the oldKernelInfo field is set.
     */
    boolean hasOldKernelInfo();
    /**
     * <pre>
     * Only present in major version = 1. Partition metadata used to validate the
     * update. For major version = 2 see the |partitions| field.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.PartitionInfo old_kernel_info = 6;</code>
     * @return The oldKernelInfo.
     */
    chromeos_update_engine.UpdateMetadata.PartitionInfo getOldKernelInfo();
    /**
     * <pre>
     * Only present in major version = 1. Partition metadata used to validate the
     * update. For major version = 2 see the |partitions| field.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.PartitionInfo old_kernel_info = 6;</code>
     */
    chromeos_update_engine.UpdateMetadata.PartitionInfoOrBuilder getOldKernelInfoOrBuilder();

    /**
     * <code>optional .chromeos_update_engine.PartitionInfo new_kernel_info = 7;</code>
     * @return Whether the newKernelInfo field is set.
     */
    boolean hasNewKernelInfo();
    /**
     * <code>optional .chromeos_update_engine.PartitionInfo new_kernel_info = 7;</code>
     * @return The newKernelInfo.
     */
    chromeos_update_engine.UpdateMetadata.PartitionInfo getNewKernelInfo();
    /**
     * <code>optional .chromeos_update_engine.PartitionInfo new_kernel_info = 7;</code>
     */
    chromeos_update_engine.UpdateMetadata.PartitionInfoOrBuilder getNewKernelInfoOrBuilder();

    /**
     * <code>optional .chromeos_update_engine.PartitionInfo old_rootfs_info = 8;</code>
     * @return Whether the oldRootfsInfo field is set.
     */
    boolean hasOldRootfsInfo();
    /**
     * <code>optional .chromeos_update_engine.PartitionInfo old_rootfs_info = 8;</code>
     * @return The oldRootfsInfo.
     */
    chromeos_update_engine.UpdateMetadata.PartitionInfo getOldRootfsInfo();
    /**
     * <code>optional .chromeos_update_engine.PartitionInfo old_rootfs_info = 8;</code>
     */
    chromeos_update_engine.UpdateMetadata.PartitionInfoOrBuilder getOldRootfsInfoOrBuilder();

    /**
     * <code>optional .chromeos_update_engine.PartitionInfo new_rootfs_info = 9;</code>
     * @return Whether the newRootfsInfo field is set.
     */
    boolean hasNewRootfsInfo();
    /**
     * <code>optional .chromeos_update_engine.PartitionInfo new_rootfs_info = 9;</code>
     * @return The newRootfsInfo.
     */
    chromeos_update_engine.UpdateMetadata.PartitionInfo getNewRootfsInfo();
    /**
     * <code>optional .chromeos_update_engine.PartitionInfo new_rootfs_info = 9;</code>
     */
    chromeos_update_engine.UpdateMetadata.PartitionInfoOrBuilder getNewRootfsInfoOrBuilder();

    /**
     * <pre>
     * old_image_info will only be present for delta images.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.ImageInfo old_image_info = 10;</code>
     * @return Whether the oldImageInfo field is set.
     */
    boolean hasOldImageInfo();
    /**
     * <pre>
     * old_image_info will only be present for delta images.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.ImageInfo old_image_info = 10;</code>
     * @return The oldImageInfo.
     */
    chromeos_update_engine.UpdateMetadata.ImageInfo getOldImageInfo();
    /**
     * <pre>
     * old_image_info will only be present for delta images.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.ImageInfo old_image_info = 10;</code>
     */
    chromeos_update_engine.UpdateMetadata.ImageInfoOrBuilder getOldImageInfoOrBuilder();

    /**
     * <code>optional .chromeos_update_engine.ImageInfo new_image_info = 11;</code>
     * @return Whether the newImageInfo field is set.
     */
    boolean hasNewImageInfo();
    /**
     * <code>optional .chromeos_update_engine.ImageInfo new_image_info = 11;</code>
     * @return The newImageInfo.
     */
    chromeos_update_engine.UpdateMetadata.ImageInfo getNewImageInfo();
    /**
     * <code>optional .chromeos_update_engine.ImageInfo new_image_info = 11;</code>
     */
    chromeos_update_engine.UpdateMetadata.ImageInfoOrBuilder getNewImageInfoOrBuilder();

    /**
     * <pre>
     * The minor version, also referred as "delta version", of the payload.
     * Minor version 0 is full payload, everything else is delta payload.
     * </pre>
     *
     * <code>optional uint32 minor_version = 12 [default = 0];</code>
     * @return Whether the minorVersion field is set.
     */
    boolean hasMinorVersion();
    /**
     * <pre>
     * The minor version, also referred as "delta version", of the payload.
     * Minor version 0 is full payload, everything else is delta payload.
     * </pre>
     *
     * <code>optional uint32 minor_version = 12 [default = 0];</code>
     * @return The minorVersion.
     */
    int getMinorVersion();

    /**
     * <pre>
     * Only present in major version &gt;= 2. List of partitions that will be
     * updated, in the order they will be updated. This field replaces the
     * |install_operations|, |kernel_install_operations| and the
     * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
     * array can have more than two partitions if needed, and they are identified
     * by the partition name.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.PartitionUpdate partitions = 13;</code>
     */
    java.util.List<chromeos_update_engine.UpdateMetadata.PartitionUpdate>
        getPartitionsList();
    /**
     * <pre>
     * Only present in major version &gt;= 2. List of partitions that will be
     * updated, in the order they will be updated. This field replaces the
     * |install_operations|, |kernel_install_operations| and the
     * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
     * array can have more than two partitions if needed, and they are identified
     * by the partition name.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.PartitionUpdate partitions = 13;</code>
     */
    chromeos_update_engine.UpdateMetadata.PartitionUpdate getPartitions(int index);
    /**
     * <pre>
     * Only present in major version &gt;= 2. List of partitions that will be
     * updated, in the order they will be updated. This field replaces the
     * |install_operations|, |kernel_install_operations| and the
     * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
     * array can have more than two partitions if needed, and they are identified
     * by the partition name.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.PartitionUpdate partitions = 13;</code>
     */
    int getPartitionsCount();
    /**
     * <pre>
     * Only present in major version &gt;= 2. List of partitions that will be
     * updated, in the order they will be updated. This field replaces the
     * |install_operations|, |kernel_install_operations| and the
     * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
     * array can have more than two partitions if needed, and they are identified
     * by the partition name.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.PartitionUpdate partitions = 13;</code>
     */
    java.util.List<? extends chromeos_update_engine.UpdateMetadata.PartitionUpdateOrBuilder>
        getPartitionsOrBuilderList();
    /**
     * <pre>
     * Only present in major version &gt;= 2. List of partitions that will be
     * updated, in the order they will be updated. This field replaces the
     * |install_operations|, |kernel_install_operations| and the
     * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
     * array can have more than two partitions if needed, and they are identified
     * by the partition name.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.PartitionUpdate partitions = 13;</code>
     */
    chromeos_update_engine.UpdateMetadata.PartitionUpdateOrBuilder getPartitionsOrBuilder(
        int index);

    /**
     * <pre>
     * The maximum timestamp of the OS allowed to apply this payload.
     * Can be used to prevent downgrading the OS.
     * </pre>
     *
     * <code>optional int64 max_timestamp = 14;</code>
     * @return Whether the maxTimestamp field is set.
     */
    boolean hasMaxTimestamp();
    /**
     * <pre>
     * The maximum timestamp of the OS allowed to apply this payload.
     * Can be used to prevent downgrading the OS.
     * </pre>
     *
     * <code>optional int64 max_timestamp = 14;</code>
     * @return The maxTimestamp.
     */
    long getMaxTimestamp();

    /**
     * <pre>
     * Metadata related to all dynamic partitions.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.DynamicPartitionMetadata dynamic_partition_metadata = 15;</code>
     * @return Whether the dynamicPartitionMetadata field is set.
     */
    boolean hasDynamicPartitionMetadata();
    /**
     * <pre>
     * Metadata related to all dynamic partitions.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.DynamicPartitionMetadata dynamic_partition_metadata = 15;</code>
     * @return The dynamicPartitionMetadata.
     */
    chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata getDynamicPartitionMetadata();
    /**
     * <pre>
     * Metadata related to all dynamic partitions.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.DynamicPartitionMetadata dynamic_partition_metadata = 15;</code>
     */
    chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadataOrBuilder getDynamicPartitionMetadataOrBuilder();

    /**
     * <pre>
     * If the payload only updates a subset of partitions on the device.
     * </pre>
     *
     * <code>optional bool partial_update = 16;</code>
     * @return Whether the partialUpdate field is set.
     */
    boolean hasPartialUpdate();
    /**
     * <pre>
     * If the payload only updates a subset of partitions on the device.
     * </pre>
     *
     * <code>optional bool partial_update = 16;</code>
     * @return The partialUpdate.
     */
    boolean getPartialUpdate();
  }
  /**
   * Protobuf type {@code chromeos_update_engine.DeltaArchiveManifest}
   */
  public static final class DeltaArchiveManifest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:chromeos_update_engine.DeltaArchiveManifest)
      DeltaArchiveManifestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use DeltaArchiveManifest.newBuilder() to construct.
    private DeltaArchiveManifest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private DeltaArchiveManifest() {
      installOperations_ = java.util.Collections.emptyList();
      kernelInstallOperations_ = java.util.Collections.emptyList();
      blockSize_ = 4096;
      partitions_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new DeltaArchiveManifest();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private DeltaArchiveManifest(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              if (!((mutable_bitField0_ & 0x00000001) != 0)) {
                installOperations_ = new java.util.ArrayList<chromeos_update_engine.UpdateMetadata.InstallOperation>();
                mutable_bitField0_ |= 0x00000001;
              }
              installOperations_.add(
                  input.readMessage(chromeos_update_engine.UpdateMetadata.InstallOperation.PARSER, extensionRegistry));
              break;
            }
            case 18: {
              if (!((mutable_bitField0_ & 0x00000002) != 0)) {
                kernelInstallOperations_ = new java.util.ArrayList<chromeos_update_engine.UpdateMetadata.InstallOperation>();
                mutable_bitField0_ |= 0x00000002;
              }
              kernelInstallOperations_.add(
                  input.readMessage(chromeos_update_engine.UpdateMetadata.InstallOperation.PARSER, extensionRegistry));
              break;
            }
            case 24: {
              bitField0_ |= 0x00000001;
              blockSize_ = input.readUInt32();
              break;
            }
            case 32: {
              bitField0_ |= 0x00000002;
              signaturesOffset_ = input.readUInt64();
              break;
            }
            case 40: {
              bitField0_ |= 0x00000004;
              signaturesSize_ = input.readUInt64();
              break;
            }
            case 50: {
              chromeos_update_engine.UpdateMetadata.PartitionInfo.Builder subBuilder = null;
              if (((bitField0_ & 0x00000008) != 0)) {
                subBuilder = oldKernelInfo_.toBuilder();
              }
              oldKernelInfo_ = input.readMessage(chromeos_update_engine.UpdateMetadata.PartitionInfo.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(oldKernelInfo_);
                oldKernelInfo_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000008;
              break;
            }
            case 58: {
              chromeos_update_engine.UpdateMetadata.PartitionInfo.Builder subBuilder = null;
              if (((bitField0_ & 0x00000010) != 0)) {
                subBuilder = newKernelInfo_.toBuilder();
              }
              newKernelInfo_ = input.readMessage(chromeos_update_engine.UpdateMetadata.PartitionInfo.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(newKernelInfo_);
                newKernelInfo_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000010;
              break;
            }
            case 66: {
              chromeos_update_engine.UpdateMetadata.PartitionInfo.Builder subBuilder = null;
              if (((bitField0_ & 0x00000020) != 0)) {
                subBuilder = oldRootfsInfo_.toBuilder();
              }
              oldRootfsInfo_ = input.readMessage(chromeos_update_engine.UpdateMetadata.PartitionInfo.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(oldRootfsInfo_);
                oldRootfsInfo_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000020;
              break;
            }
            case 74: {
              chromeos_update_engine.UpdateMetadata.PartitionInfo.Builder subBuilder = null;
              if (((bitField0_ & 0x00000040) != 0)) {
                subBuilder = newRootfsInfo_.toBuilder();
              }
              newRootfsInfo_ = input.readMessage(chromeos_update_engine.UpdateMetadata.PartitionInfo.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(newRootfsInfo_);
                newRootfsInfo_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000040;
              break;
            }
            case 82: {
              chromeos_update_engine.UpdateMetadata.ImageInfo.Builder subBuilder = null;
              if (((bitField0_ & 0x00000080) != 0)) {
                subBuilder = oldImageInfo_.toBuilder();
              }
              oldImageInfo_ = input.readMessage(chromeos_update_engine.UpdateMetadata.ImageInfo.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(oldImageInfo_);
                oldImageInfo_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000080;
              break;
            }
            case 90: {
              chromeos_update_engine.UpdateMetadata.ImageInfo.Builder subBuilder = null;
              if (((bitField0_ & 0x00000100) != 0)) {
                subBuilder = newImageInfo_.toBuilder();
              }
              newImageInfo_ = input.readMessage(chromeos_update_engine.UpdateMetadata.ImageInfo.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(newImageInfo_);
                newImageInfo_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000100;
              break;
            }
            case 96: {
              bitField0_ |= 0x00000200;
              minorVersion_ = input.readUInt32();
              break;
            }
            case 106: {
              if (!((mutable_bitField0_ & 0x00001000) != 0)) {
                partitions_ = new java.util.ArrayList<chromeos_update_engine.UpdateMetadata.PartitionUpdate>();
                mutable_bitField0_ |= 0x00001000;
              }
              partitions_.add(
                  input.readMessage(chromeos_update_engine.UpdateMetadata.PartitionUpdate.PARSER, extensionRegistry));
              break;
            }
            case 112: {
              bitField0_ |= 0x00000400;
              maxTimestamp_ = input.readInt64();
              break;
            }
            case 122: {
              chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata.Builder subBuilder = null;
              if (((bitField0_ & 0x00000800) != 0)) {
                subBuilder = dynamicPartitionMetadata_.toBuilder();
              }
              dynamicPartitionMetadata_ = input.readMessage(chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(dynamicPartitionMetadata_);
                dynamicPartitionMetadata_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000800;
              break;
            }
            case 128: {
              bitField0_ |= 0x00001000;
              partialUpdate_ = input.readBool();
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) != 0)) {
          installOperations_ = java.util.Collections.unmodifiableList(installOperations_);
        }
        if (((mutable_bitField0_ & 0x00000002) != 0)) {
          kernelInstallOperations_ = java.util.Collections.unmodifiableList(kernelInstallOperations_);
        }
        if (((mutable_bitField0_ & 0x00001000) != 0)) {
          partitions_ = java.util.Collections.unmodifiableList(partitions_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_DeltaArchiveManifest_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_DeltaArchiveManifest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest.class, chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest.Builder.class);
    }

    private int bitField0_;
    public static final int INSTALL_OPERATIONS_FIELD_NUMBER = 1;
    private java.util.List<chromeos_update_engine.UpdateMetadata.InstallOperation> installOperations_;
    /**
     * <pre>
     * Only present in major version = 1. List of install operations for the
     * kernel and rootfs partitions. For major version = 2 see the |partitions|
     * field.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.InstallOperation install_operations = 1;</code>
     */
    @java.lang.Override
    public java.util.List<chromeos_update_engine.UpdateMetadata.InstallOperation> getInstallOperationsList() {
      return installOperations_;
    }
    /**
     * <pre>
     * Only present in major version = 1. List of install operations for the
     * kernel and rootfs partitions. For major version = 2 see the |partitions|
     * field.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.InstallOperation install_operations = 1;</code>
     */
    @java.lang.Override
    public java.util.List<? extends chromeos_update_engine.UpdateMetadata.InstallOperationOrBuilder>
        getInstallOperationsOrBuilderList() {
      return installOperations_;
    }
    /**
     * <pre>
     * Only present in major version = 1. List of install operations for the
     * kernel and rootfs partitions. For major version = 2 see the |partitions|
     * field.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.InstallOperation install_operations = 1;</code>
     */
    @java.lang.Override
    public int getInstallOperationsCount() {
      return installOperations_.size();
    }
    /**
     * <pre>
     * Only present in major version = 1. List of install operations for the
     * kernel and rootfs partitions. For major version = 2 see the |partitions|
     * field.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.InstallOperation install_operations = 1;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.InstallOperation getInstallOperations(int index) {
      return installOperations_.get(index);
    }
    /**
     * <pre>
     * Only present in major version = 1. List of install operations for the
     * kernel and rootfs partitions. For major version = 2 see the |partitions|
     * field.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.InstallOperation install_operations = 1;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.InstallOperationOrBuilder getInstallOperationsOrBuilder(
        int index) {
      return installOperations_.get(index);
    }

    public static final int KERNEL_INSTALL_OPERATIONS_FIELD_NUMBER = 2;
    private java.util.List<chromeos_update_engine.UpdateMetadata.InstallOperation> kernelInstallOperations_;
    /**
     * <code>repeated .chromeos_update_engine.InstallOperation kernel_install_operations = 2;</code>
     */
    @java.lang.Override
    public java.util.List<chromeos_update_engine.UpdateMetadata.InstallOperation> getKernelInstallOperationsList() {
      return kernelInstallOperations_;
    }
    /**
     * <code>repeated .chromeos_update_engine.InstallOperation kernel_install_operations = 2;</code>
     */
    @java.lang.Override
    public java.util.List<? extends chromeos_update_engine.UpdateMetadata.InstallOperationOrBuilder>
        getKernelInstallOperationsOrBuilderList() {
      return kernelInstallOperations_;
    }
    /**
     * <code>repeated .chromeos_update_engine.InstallOperation kernel_install_operations = 2;</code>
     */
    @java.lang.Override
    public int getKernelInstallOperationsCount() {
      return kernelInstallOperations_.size();
    }
    /**
     * <code>repeated .chromeos_update_engine.InstallOperation kernel_install_operations = 2;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.InstallOperation getKernelInstallOperations(int index) {
      return kernelInstallOperations_.get(index);
    }
    /**
     * <code>repeated .chromeos_update_engine.InstallOperation kernel_install_operations = 2;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.InstallOperationOrBuilder getKernelInstallOperationsOrBuilder(
        int index) {
      return kernelInstallOperations_.get(index);
    }

    public static final int BLOCK_SIZE_FIELD_NUMBER = 3;
    private int blockSize_;
    /**
     * <pre>
     * (At time of writing) usually 4096
     * </pre>
     *
     * <code>optional uint32 block_size = 3 [default = 4096];</code>
     * @return Whether the blockSize field is set.
     */
    @java.lang.Override
    public boolean hasBlockSize() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * (At time of writing) usually 4096
     * </pre>
     *
     * <code>optional uint32 block_size = 3 [default = 4096];</code>
     * @return The blockSize.
     */
    @java.lang.Override
    public int getBlockSize() {
      return blockSize_;
    }

    public static final int SIGNATURES_OFFSET_FIELD_NUMBER = 4;
    private long signaturesOffset_;
    /**
     * <pre>
     * If signatures are present, the offset into the blobs, generally
     * tacked onto the end of the file, and the length. We use an offset
     * rather than a bool to allow for more flexibility in future file formats.
     * If either is absent, it means signatures aren't supported in this
     * file.
     * </pre>
     *
     * <code>optional uint64 signatures_offset = 4;</code>
     * @return Whether the signaturesOffset field is set.
     */
    @java.lang.Override
    public boolean hasSignaturesOffset() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * If signatures are present, the offset into the blobs, generally
     * tacked onto the end of the file, and the length. We use an offset
     * rather than a bool to allow for more flexibility in future file formats.
     * If either is absent, it means signatures aren't supported in this
     * file.
     * </pre>
     *
     * <code>optional uint64 signatures_offset = 4;</code>
     * @return The signaturesOffset.
     */
    @java.lang.Override
    public long getSignaturesOffset() {
      return signaturesOffset_;
    }

    public static final int SIGNATURES_SIZE_FIELD_NUMBER = 5;
    private long signaturesSize_;
    /**
     * <code>optional uint64 signatures_size = 5;</code>
     * @return Whether the signaturesSize field is set.
     */
    @java.lang.Override
    public boolean hasSignaturesSize() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <code>optional uint64 signatures_size = 5;</code>
     * @return The signaturesSize.
     */
    @java.lang.Override
    public long getSignaturesSize() {
      return signaturesSize_;
    }

    public static final int OLD_KERNEL_INFO_FIELD_NUMBER = 6;
    private chromeos_update_engine.UpdateMetadata.PartitionInfo oldKernelInfo_;
    /**
     * <pre>
     * Only present in major version = 1. Partition metadata used to validate the
     * update. For major version = 2 see the |partitions| field.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.PartitionInfo old_kernel_info = 6;</code>
     * @return Whether the oldKernelInfo field is set.
     */
    @java.lang.Override
    public boolean hasOldKernelInfo() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * Only present in major version = 1. Partition metadata used to validate the
     * update. For major version = 2 see the |partitions| field.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.PartitionInfo old_kernel_info = 6;</code>
     * @return The oldKernelInfo.
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.PartitionInfo getOldKernelInfo() {
      return oldKernelInfo_ == null ? chromeos_update_engine.UpdateMetadata.PartitionInfo.getDefaultInstance() : oldKernelInfo_;
    }
    /**
     * <pre>
     * Only present in major version = 1. Partition metadata used to validate the
     * update. For major version = 2 see the |partitions| field.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.PartitionInfo old_kernel_info = 6;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.PartitionInfoOrBuilder getOldKernelInfoOrBuilder() {
      return oldKernelInfo_ == null ? chromeos_update_engine.UpdateMetadata.PartitionInfo.getDefaultInstance() : oldKernelInfo_;
    }

    public static final int NEW_KERNEL_INFO_FIELD_NUMBER = 7;
    private chromeos_update_engine.UpdateMetadata.PartitionInfo newKernelInfo_;
    /**
     * <code>optional .chromeos_update_engine.PartitionInfo new_kernel_info = 7;</code>
     * @return Whether the newKernelInfo field is set.
     */
    @java.lang.Override
    public boolean hasNewKernelInfo() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <code>optional .chromeos_update_engine.PartitionInfo new_kernel_info = 7;</code>
     * @return The newKernelInfo.
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.PartitionInfo getNewKernelInfo() {
      return newKernelInfo_ == null ? chromeos_update_engine.UpdateMetadata.PartitionInfo.getDefaultInstance() : newKernelInfo_;
    }
    /**
     * <code>optional .chromeos_update_engine.PartitionInfo new_kernel_info = 7;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.PartitionInfoOrBuilder getNewKernelInfoOrBuilder() {
      return newKernelInfo_ == null ? chromeos_update_engine.UpdateMetadata.PartitionInfo.getDefaultInstance() : newKernelInfo_;
    }

    public static final int OLD_ROOTFS_INFO_FIELD_NUMBER = 8;
    private chromeos_update_engine.UpdateMetadata.PartitionInfo oldRootfsInfo_;
    /**
     * <code>optional .chromeos_update_engine.PartitionInfo old_rootfs_info = 8;</code>
     * @return Whether the oldRootfsInfo field is set.
     */
    @java.lang.Override
    public boolean hasOldRootfsInfo() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <code>optional .chromeos_update_engine.PartitionInfo old_rootfs_info = 8;</code>
     * @return The oldRootfsInfo.
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.PartitionInfo getOldRootfsInfo() {
      return oldRootfsInfo_ == null ? chromeos_update_engine.UpdateMetadata.PartitionInfo.getDefaultInstance() : oldRootfsInfo_;
    }
    /**
     * <code>optional .chromeos_update_engine.PartitionInfo old_rootfs_info = 8;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.PartitionInfoOrBuilder getOldRootfsInfoOrBuilder() {
      return oldRootfsInfo_ == null ? chromeos_update_engine.UpdateMetadata.PartitionInfo.getDefaultInstance() : oldRootfsInfo_;
    }

    public static final int NEW_ROOTFS_INFO_FIELD_NUMBER = 9;
    private chromeos_update_engine.UpdateMetadata.PartitionInfo newRootfsInfo_;
    /**
     * <code>optional .chromeos_update_engine.PartitionInfo new_rootfs_info = 9;</code>
     * @return Whether the newRootfsInfo field is set.
     */
    @java.lang.Override
    public boolean hasNewRootfsInfo() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <code>optional .chromeos_update_engine.PartitionInfo new_rootfs_info = 9;</code>
     * @return The newRootfsInfo.
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.PartitionInfo getNewRootfsInfo() {
      return newRootfsInfo_ == null ? chromeos_update_engine.UpdateMetadata.PartitionInfo.getDefaultInstance() : newRootfsInfo_;
    }
    /**
     * <code>optional .chromeos_update_engine.PartitionInfo new_rootfs_info = 9;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.PartitionInfoOrBuilder getNewRootfsInfoOrBuilder() {
      return newRootfsInfo_ == null ? chromeos_update_engine.UpdateMetadata.PartitionInfo.getDefaultInstance() : newRootfsInfo_;
    }

    public static final int OLD_IMAGE_INFO_FIELD_NUMBER = 10;
    private chromeos_update_engine.UpdateMetadata.ImageInfo oldImageInfo_;
    /**
     * <pre>
     * old_image_info will only be present for delta images.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.ImageInfo old_image_info = 10;</code>
     * @return Whether the oldImageInfo field is set.
     */
    @java.lang.Override
    public boolean hasOldImageInfo() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * old_image_info will only be present for delta images.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.ImageInfo old_image_info = 10;</code>
     * @return The oldImageInfo.
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.ImageInfo getOldImageInfo() {
      return oldImageInfo_ == null ? chromeos_update_engine.UpdateMetadata.ImageInfo.getDefaultInstance() : oldImageInfo_;
    }
    /**
     * <pre>
     * old_image_info will only be present for delta images.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.ImageInfo old_image_info = 10;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.ImageInfoOrBuilder getOldImageInfoOrBuilder() {
      return oldImageInfo_ == null ? chromeos_update_engine.UpdateMetadata.ImageInfo.getDefaultInstance() : oldImageInfo_;
    }

    public static final int NEW_IMAGE_INFO_FIELD_NUMBER = 11;
    private chromeos_update_engine.UpdateMetadata.ImageInfo newImageInfo_;
    /**
     * <code>optional .chromeos_update_engine.ImageInfo new_image_info = 11;</code>
     * @return Whether the newImageInfo field is set.
     */
    @java.lang.Override
    public boolean hasNewImageInfo() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     * <code>optional .chromeos_update_engine.ImageInfo new_image_info = 11;</code>
     * @return The newImageInfo.
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.ImageInfo getNewImageInfo() {
      return newImageInfo_ == null ? chromeos_update_engine.UpdateMetadata.ImageInfo.getDefaultInstance() : newImageInfo_;
    }
    /**
     * <code>optional .chromeos_update_engine.ImageInfo new_image_info = 11;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.ImageInfoOrBuilder getNewImageInfoOrBuilder() {
      return newImageInfo_ == null ? chromeos_update_engine.UpdateMetadata.ImageInfo.getDefaultInstance() : newImageInfo_;
    }

    public static final int MINOR_VERSION_FIELD_NUMBER = 12;
    private int minorVersion_;
    /**
     * <pre>
     * The minor version, also referred as "delta version", of the payload.
     * Minor version 0 is full payload, everything else is delta payload.
     * </pre>
     *
     * <code>optional uint32 minor_version = 12 [default = 0];</code>
     * @return Whether the minorVersion field is set.
     */
    @java.lang.Override
    public boolean hasMinorVersion() {
      return ((bitField0_ & 0x00000200) != 0);
    }
    /**
     * <pre>
     * The minor version, also referred as "delta version", of the payload.
     * Minor version 0 is full payload, everything else is delta payload.
     * </pre>
     *
     * <code>optional uint32 minor_version = 12 [default = 0];</code>
     * @return The minorVersion.
     */
    @java.lang.Override
    public int getMinorVersion() {
      return minorVersion_;
    }

    public static final int PARTITIONS_FIELD_NUMBER = 13;
    private java.util.List<chromeos_update_engine.UpdateMetadata.PartitionUpdate> partitions_;
    /**
     * <pre>
     * Only present in major version &gt;= 2. List of partitions that will be
     * updated, in the order they will be updated. This field replaces the
     * |install_operations|, |kernel_install_operations| and the
     * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
     * array can have more than two partitions if needed, and they are identified
     * by the partition name.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.PartitionUpdate partitions = 13;</code>
     */
    @java.lang.Override
    public java.util.List<chromeos_update_engine.UpdateMetadata.PartitionUpdate> getPartitionsList() {
      return partitions_;
    }
    /**
     * <pre>
     * Only present in major version &gt;= 2. List of partitions that will be
     * updated, in the order they will be updated. This field replaces the
     * |install_operations|, |kernel_install_operations| and the
     * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
     * array can have more than two partitions if needed, and they are identified
     * by the partition name.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.PartitionUpdate partitions = 13;</code>
     */
    @java.lang.Override
    public java.util.List<? extends chromeos_update_engine.UpdateMetadata.PartitionUpdateOrBuilder>
        getPartitionsOrBuilderList() {
      return partitions_;
    }
    /**
     * <pre>
     * Only present in major version &gt;= 2. List of partitions that will be
     * updated, in the order they will be updated. This field replaces the
     * |install_operations|, |kernel_install_operations| and the
     * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
     * array can have more than two partitions if needed, and they are identified
     * by the partition name.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.PartitionUpdate partitions = 13;</code>
     */
    @java.lang.Override
    public int getPartitionsCount() {
      return partitions_.size();
    }
    /**
     * <pre>
     * Only present in major version &gt;= 2. List of partitions that will be
     * updated, in the order they will be updated. This field replaces the
     * |install_operations|, |kernel_install_operations| and the
     * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
     * array can have more than two partitions if needed, and they are identified
     * by the partition name.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.PartitionUpdate partitions = 13;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.PartitionUpdate getPartitions(int index) {
      return partitions_.get(index);
    }
    /**
     * <pre>
     * Only present in major version &gt;= 2. List of partitions that will be
     * updated, in the order they will be updated. This field replaces the
     * |install_operations|, |kernel_install_operations| and the
     * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
     * array can have more than two partitions if needed, and they are identified
     * by the partition name.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.PartitionUpdate partitions = 13;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.PartitionUpdateOrBuilder getPartitionsOrBuilder(
        int index) {
      return partitions_.get(index);
    }

    public static final int MAX_TIMESTAMP_FIELD_NUMBER = 14;
    private long maxTimestamp_;
    /**
     * <pre>
     * The maximum timestamp of the OS allowed to apply this payload.
     * Can be used to prevent downgrading the OS.
     * </pre>
     *
     * <code>optional int64 max_timestamp = 14;</code>
     * @return Whether the maxTimestamp field is set.
     */
    @java.lang.Override
    public boolean hasMaxTimestamp() {
      return ((bitField0_ & 0x00000400) != 0);
    }
    /**
     * <pre>
     * The maximum timestamp of the OS allowed to apply this payload.
     * Can be used to prevent downgrading the OS.
     * </pre>
     *
     * <code>optional int64 max_timestamp = 14;</code>
     * @return The maxTimestamp.
     */
    @java.lang.Override
    public long getMaxTimestamp() {
      return maxTimestamp_;
    }

    public static final int DYNAMIC_PARTITION_METADATA_FIELD_NUMBER = 15;
    private chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata dynamicPartitionMetadata_;
    /**
     * <pre>
     * Metadata related to all dynamic partitions.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.DynamicPartitionMetadata dynamic_partition_metadata = 15;</code>
     * @return Whether the dynamicPartitionMetadata field is set.
     */
    @java.lang.Override
    public boolean hasDynamicPartitionMetadata() {
      return ((bitField0_ & 0x00000800) != 0);
    }
    /**
     * <pre>
     * Metadata related to all dynamic partitions.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.DynamicPartitionMetadata dynamic_partition_metadata = 15;</code>
     * @return The dynamicPartitionMetadata.
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata getDynamicPartitionMetadata() {
      return dynamicPartitionMetadata_ == null ? chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata.getDefaultInstance() : dynamicPartitionMetadata_;
    }
    /**
     * <pre>
     * Metadata related to all dynamic partitions.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.DynamicPartitionMetadata dynamic_partition_metadata = 15;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadataOrBuilder getDynamicPartitionMetadataOrBuilder() {
      return dynamicPartitionMetadata_ == null ? chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata.getDefaultInstance() : dynamicPartitionMetadata_;
    }

    public static final int PARTIAL_UPDATE_FIELD_NUMBER = 16;
    private boolean partialUpdate_;
    /**
     * <pre>
     * If the payload only updates a subset of partitions on the device.
     * </pre>
     *
     * <code>optional bool partial_update = 16;</code>
     * @return Whether the partialUpdate field is set.
     */
    @java.lang.Override
    public boolean hasPartialUpdate() {
      return ((bitField0_ & 0x00001000) != 0);
    }
    /**
     * <pre>
     * If the payload only updates a subset of partitions on the device.
     * </pre>
     *
     * <code>optional bool partial_update = 16;</code>
     * @return The partialUpdate.
     */
    @java.lang.Override
    public boolean getPartialUpdate() {
      return partialUpdate_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      for (int i = 0; i < getInstallOperationsCount(); i++) {
        if (!getInstallOperations(i).isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      for (int i = 0; i < getKernelInstallOperationsCount(); i++) {
        if (!getKernelInstallOperations(i).isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      for (int i = 0; i < getPartitionsCount(); i++) {
        if (!getPartitions(i).isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      if (hasDynamicPartitionMetadata()) {
        if (!getDynamicPartitionMetadata().isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < installOperations_.size(); i++) {
        output.writeMessage(1, installOperations_.get(i));
      }
      for (int i = 0; i < kernelInstallOperations_.size(); i++) {
        output.writeMessage(2, kernelInstallOperations_.get(i));
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeUInt32(3, blockSize_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeUInt64(4, signaturesOffset_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeUInt64(5, signaturesSize_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeMessage(6, getOldKernelInfo());
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeMessage(7, getNewKernelInfo());
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        output.writeMessage(8, getOldRootfsInfo());
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        output.writeMessage(9, getNewRootfsInfo());
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        output.writeMessage(10, getOldImageInfo());
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        output.writeMessage(11, getNewImageInfo());
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        output.writeUInt32(12, minorVersion_);
      }
      for (int i = 0; i < partitions_.size(); i++) {
        output.writeMessage(13, partitions_.get(i));
      }
      if (((bitField0_ & 0x00000400) != 0)) {
        output.writeInt64(14, maxTimestamp_);
      }
      if (((bitField0_ & 0x00000800) != 0)) {
        output.writeMessage(15, getDynamicPartitionMetadata());
      }
      if (((bitField0_ & 0x00001000) != 0)) {
        output.writeBool(16, partialUpdate_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < installOperations_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, installOperations_.get(i));
      }
      for (int i = 0; i < kernelInstallOperations_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, kernelInstallOperations_.get(i));
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(3, blockSize_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(4, signaturesOffset_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(5, signaturesSize_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(6, getOldKernelInfo());
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(7, getNewKernelInfo());
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(8, getOldRootfsInfo());
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(9, getNewRootfsInfo());
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(10, getOldImageInfo());
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(11, getNewImageInfo());
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(12, minorVersion_);
      }
      for (int i = 0; i < partitions_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(13, partitions_.get(i));
      }
      if (((bitField0_ & 0x00000400) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(14, maxTimestamp_);
      }
      if (((bitField0_ & 0x00000800) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(15, getDynamicPartitionMetadata());
      }
      if (((bitField0_ & 0x00001000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(16, partialUpdate_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest)) {
        return super.equals(obj);
      }
      chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest other = (chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest) obj;

      if (!getInstallOperationsList()
          .equals(other.getInstallOperationsList())) return false;
      if (!getKernelInstallOperationsList()
          .equals(other.getKernelInstallOperationsList())) return false;
      if (hasBlockSize() != other.hasBlockSize()) return false;
      if (hasBlockSize()) {
        if (getBlockSize()
            != other.getBlockSize()) return false;
      }
      if (hasSignaturesOffset() != other.hasSignaturesOffset()) return false;
      if (hasSignaturesOffset()) {
        if (getSignaturesOffset()
            != other.getSignaturesOffset()) return false;
      }
      if (hasSignaturesSize() != other.hasSignaturesSize()) return false;
      if (hasSignaturesSize()) {
        if (getSignaturesSize()
            != other.getSignaturesSize()) return false;
      }
      if (hasOldKernelInfo() != other.hasOldKernelInfo()) return false;
      if (hasOldKernelInfo()) {
        if (!getOldKernelInfo()
            .equals(other.getOldKernelInfo())) return false;
      }
      if (hasNewKernelInfo() != other.hasNewKernelInfo()) return false;
      if (hasNewKernelInfo()) {
        if (!getNewKernelInfo()
            .equals(other.getNewKernelInfo())) return false;
      }
      if (hasOldRootfsInfo() != other.hasOldRootfsInfo()) return false;
      if (hasOldRootfsInfo()) {
        if (!getOldRootfsInfo()
            .equals(other.getOldRootfsInfo())) return false;
      }
      if (hasNewRootfsInfo() != other.hasNewRootfsInfo()) return false;
      if (hasNewRootfsInfo()) {
        if (!getNewRootfsInfo()
            .equals(other.getNewRootfsInfo())) return false;
      }
      if (hasOldImageInfo() != other.hasOldImageInfo()) return false;
      if (hasOldImageInfo()) {
        if (!getOldImageInfo()
            .equals(other.getOldImageInfo())) return false;
      }
      if (hasNewImageInfo() != other.hasNewImageInfo()) return false;
      if (hasNewImageInfo()) {
        if (!getNewImageInfo()
            .equals(other.getNewImageInfo())) return false;
      }
      if (hasMinorVersion() != other.hasMinorVersion()) return false;
      if (hasMinorVersion()) {
        if (getMinorVersion()
            != other.getMinorVersion()) return false;
      }
      if (!getPartitionsList()
          .equals(other.getPartitionsList())) return false;
      if (hasMaxTimestamp() != other.hasMaxTimestamp()) return false;
      if (hasMaxTimestamp()) {
        if (getMaxTimestamp()
            != other.getMaxTimestamp()) return false;
      }
      if (hasDynamicPartitionMetadata() != other.hasDynamicPartitionMetadata()) return false;
      if (hasDynamicPartitionMetadata()) {
        if (!getDynamicPartitionMetadata()
            .equals(other.getDynamicPartitionMetadata())) return false;
      }
      if (hasPartialUpdate() != other.hasPartialUpdate()) return false;
      if (hasPartialUpdate()) {
        if (getPartialUpdate()
            != other.getPartialUpdate()) return false;
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getInstallOperationsCount() > 0) {
        hash = (37 * hash) + INSTALL_OPERATIONS_FIELD_NUMBER;
        hash = (53 * hash) + getInstallOperationsList().hashCode();
      }
      if (getKernelInstallOperationsCount() > 0) {
        hash = (37 * hash) + KERNEL_INSTALL_OPERATIONS_FIELD_NUMBER;
        hash = (53 * hash) + getKernelInstallOperationsList().hashCode();
      }
      if (hasBlockSize()) {
        hash = (37 * hash) + BLOCK_SIZE_FIELD_NUMBER;
        hash = (53 * hash) + getBlockSize();
      }
      if (hasSignaturesOffset()) {
        hash = (37 * hash) + SIGNATURES_OFFSET_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getSignaturesOffset());
      }
      if (hasSignaturesSize()) {
        hash = (37 * hash) + SIGNATURES_SIZE_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getSignaturesSize());
      }
      if (hasOldKernelInfo()) {
        hash = (37 * hash) + OLD_KERNEL_INFO_FIELD_NUMBER;
        hash = (53 * hash) + getOldKernelInfo().hashCode();
      }
      if (hasNewKernelInfo()) {
        hash = (37 * hash) + NEW_KERNEL_INFO_FIELD_NUMBER;
        hash = (53 * hash) + getNewKernelInfo().hashCode();
      }
      if (hasOldRootfsInfo()) {
        hash = (37 * hash) + OLD_ROOTFS_INFO_FIELD_NUMBER;
        hash = (53 * hash) + getOldRootfsInfo().hashCode();
      }
      if (hasNewRootfsInfo()) {
        hash = (37 * hash) + NEW_ROOTFS_INFO_FIELD_NUMBER;
        hash = (53 * hash) + getNewRootfsInfo().hashCode();
      }
      if (hasOldImageInfo()) {
        hash = (37 * hash) + OLD_IMAGE_INFO_FIELD_NUMBER;
        hash = (53 * hash) + getOldImageInfo().hashCode();
      }
      if (hasNewImageInfo()) {
        hash = (37 * hash) + NEW_IMAGE_INFO_FIELD_NUMBER;
        hash = (53 * hash) + getNewImageInfo().hashCode();
      }
      if (hasMinorVersion()) {
        hash = (37 * hash) + MINOR_VERSION_FIELD_NUMBER;
        hash = (53 * hash) + getMinorVersion();
      }
      if (getPartitionsCount() > 0) {
        hash = (37 * hash) + PARTITIONS_FIELD_NUMBER;
        hash = (53 * hash) + getPartitionsList().hashCode();
      }
      if (hasMaxTimestamp()) {
        hash = (37 * hash) + MAX_TIMESTAMP_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getMaxTimestamp());
      }
      if (hasDynamicPartitionMetadata()) {
        hash = (37 * hash) + DYNAMIC_PARTITION_METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getDynamicPartitionMetadata().hashCode();
      }
      if (hasPartialUpdate()) {
        hash = (37 * hash) + PARTIAL_UPDATE_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getPartialUpdate());
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code chromeos_update_engine.DeltaArchiveManifest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:chromeos_update_engine.DeltaArchiveManifest)
        chromeos_update_engine.UpdateMetadata.DeltaArchiveManifestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_DeltaArchiveManifest_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_DeltaArchiveManifest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest.class, chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest.Builder.class);
      }

      // Construct using chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getInstallOperationsFieldBuilder();
          getKernelInstallOperationsFieldBuilder();
          getOldKernelInfoFieldBuilder();
          getNewKernelInfoFieldBuilder();
          getOldRootfsInfoFieldBuilder();
          getNewRootfsInfoFieldBuilder();
          getOldImageInfoFieldBuilder();
          getNewImageInfoFieldBuilder();
          getPartitionsFieldBuilder();
          getDynamicPartitionMetadataFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (installOperationsBuilder_ == null) {
          installOperations_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
        } else {
          installOperationsBuilder_.clear();
        }
        if (kernelInstallOperationsBuilder_ == null) {
          kernelInstallOperations_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
        } else {
          kernelInstallOperationsBuilder_.clear();
        }
        blockSize_ = 4096;
        bitField0_ = (bitField0_ & ~0x00000004);
        signaturesOffset_ = 0L;
        bitField0_ = (bitField0_ & ~0x00000008);
        signaturesSize_ = 0L;
        bitField0_ = (bitField0_ & ~0x00000010);
        if (oldKernelInfoBuilder_ == null) {
          oldKernelInfo_ = null;
        } else {
          oldKernelInfoBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000020);
        if (newKernelInfoBuilder_ == null) {
          newKernelInfo_ = null;
        } else {
          newKernelInfoBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000040);
        if (oldRootfsInfoBuilder_ == null) {
          oldRootfsInfo_ = null;
        } else {
          oldRootfsInfoBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000080);
        if (newRootfsInfoBuilder_ == null) {
          newRootfsInfo_ = null;
        } else {
          newRootfsInfoBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000100);
        if (oldImageInfoBuilder_ == null) {
          oldImageInfo_ = null;
        } else {
          oldImageInfoBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000200);
        if (newImageInfoBuilder_ == null) {
          newImageInfo_ = null;
        } else {
          newImageInfoBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000400);
        minorVersion_ = 0;
        bitField0_ = (bitField0_ & ~0x00000800);
        if (partitionsBuilder_ == null) {
          partitions_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00001000);
        } else {
          partitionsBuilder_.clear();
        }
        maxTimestamp_ = 0L;
        bitField0_ = (bitField0_ & ~0x00002000);
        if (dynamicPartitionMetadataBuilder_ == null) {
          dynamicPartitionMetadata_ = null;
        } else {
          dynamicPartitionMetadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00004000);
        partialUpdate_ = false;
        bitField0_ = (bitField0_ & ~0x00008000);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_DeltaArchiveManifest_descriptor;
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest getDefaultInstanceForType() {
        return chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest.getDefaultInstance();
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest build() {
        chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest buildPartial() {
        chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest result = new chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (installOperationsBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0)) {
            installOperations_ = java.util.Collections.unmodifiableList(installOperations_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.installOperations_ = installOperations_;
        } else {
          result.installOperations_ = installOperationsBuilder_.build();
        }
        if (kernelInstallOperationsBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0)) {
            kernelInstallOperations_ = java.util.Collections.unmodifiableList(kernelInstallOperations_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.kernelInstallOperations_ = kernelInstallOperations_;
        } else {
          result.kernelInstallOperations_ = kernelInstallOperationsBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          to_bitField0_ |= 0x00000001;
        }
        result.blockSize_ = blockSize_;
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.signaturesOffset_ = signaturesOffset_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.signaturesSize_ = signaturesSize_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          if (oldKernelInfoBuilder_ == null) {
            result.oldKernelInfo_ = oldKernelInfo_;
          } else {
            result.oldKernelInfo_ = oldKernelInfoBuilder_.build();
          }
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          if (newKernelInfoBuilder_ == null) {
            result.newKernelInfo_ = newKernelInfo_;
          } else {
            result.newKernelInfo_ = newKernelInfoBuilder_.build();
          }
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          if (oldRootfsInfoBuilder_ == null) {
            result.oldRootfsInfo_ = oldRootfsInfo_;
          } else {
            result.oldRootfsInfo_ = oldRootfsInfoBuilder_.build();
          }
          to_bitField0_ |= 0x00000020;
        }
        if (((from_bitField0_ & 0x00000100) != 0)) {
          if (newRootfsInfoBuilder_ == null) {
            result.newRootfsInfo_ = newRootfsInfo_;
          } else {
            result.newRootfsInfo_ = newRootfsInfoBuilder_.build();
          }
          to_bitField0_ |= 0x00000040;
        }
        if (((from_bitField0_ & 0x00000200) != 0)) {
          if (oldImageInfoBuilder_ == null) {
            result.oldImageInfo_ = oldImageInfo_;
          } else {
            result.oldImageInfo_ = oldImageInfoBuilder_.build();
          }
          to_bitField0_ |= 0x00000080;
        }
        if (((from_bitField0_ & 0x00000400) != 0)) {
          if (newImageInfoBuilder_ == null) {
            result.newImageInfo_ = newImageInfo_;
          } else {
            result.newImageInfo_ = newImageInfoBuilder_.build();
          }
          to_bitField0_ |= 0x00000100;
        }
        if (((from_bitField0_ & 0x00000800) != 0)) {
          result.minorVersion_ = minorVersion_;
          to_bitField0_ |= 0x00000200;
        }
        if (partitionsBuilder_ == null) {
          if (((bitField0_ & 0x00001000) != 0)) {
            partitions_ = java.util.Collections.unmodifiableList(partitions_);
            bitField0_ = (bitField0_ & ~0x00001000);
          }
          result.partitions_ = partitions_;
        } else {
          result.partitions_ = partitionsBuilder_.build();
        }
        if (((from_bitField0_ & 0x00002000) != 0)) {
          result.maxTimestamp_ = maxTimestamp_;
          to_bitField0_ |= 0x00000400;
        }
        if (((from_bitField0_ & 0x00004000) != 0)) {
          if (dynamicPartitionMetadataBuilder_ == null) {
            result.dynamicPartitionMetadata_ = dynamicPartitionMetadata_;
          } else {
            result.dynamicPartitionMetadata_ = dynamicPartitionMetadataBuilder_.build();
          }
          to_bitField0_ |= 0x00000800;
        }
        if (((from_bitField0_ & 0x00008000) != 0)) {
          result.partialUpdate_ = partialUpdate_;
          to_bitField0_ |= 0x00001000;
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest) {
          return mergeFrom((chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest other) {
        if (other == chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest.getDefaultInstance()) return this;
        if (installOperationsBuilder_ == null) {
          if (!other.installOperations_.isEmpty()) {
            if (installOperations_.isEmpty()) {
              installOperations_ = other.installOperations_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureInstallOperationsIsMutable();
              installOperations_.addAll(other.installOperations_);
            }
            onChanged();
          }
        } else {
          if (!other.installOperations_.isEmpty()) {
            if (installOperationsBuilder_.isEmpty()) {
              installOperationsBuilder_.dispose();
              installOperationsBuilder_ = null;
              installOperations_ = other.installOperations_;
              bitField0_ = (bitField0_ & ~0x00000001);
              installOperationsBuilder_ =
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getInstallOperationsFieldBuilder() : null;
            } else {
              installOperationsBuilder_.addAllMessages(other.installOperations_);
            }
          }
        }
        if (kernelInstallOperationsBuilder_ == null) {
          if (!other.kernelInstallOperations_.isEmpty()) {
            if (kernelInstallOperations_.isEmpty()) {
              kernelInstallOperations_ = other.kernelInstallOperations_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureKernelInstallOperationsIsMutable();
              kernelInstallOperations_.addAll(other.kernelInstallOperations_);
            }
            onChanged();
          }
        } else {
          if (!other.kernelInstallOperations_.isEmpty()) {
            if (kernelInstallOperationsBuilder_.isEmpty()) {
              kernelInstallOperationsBuilder_.dispose();
              kernelInstallOperationsBuilder_ = null;
              kernelInstallOperations_ = other.kernelInstallOperations_;
              bitField0_ = (bitField0_ & ~0x00000002);
              kernelInstallOperationsBuilder_ =
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getKernelInstallOperationsFieldBuilder() : null;
            } else {
              kernelInstallOperationsBuilder_.addAllMessages(other.kernelInstallOperations_);
            }
          }
        }
        if (other.hasBlockSize()) {
          setBlockSize(other.getBlockSize());
        }
        if (other.hasSignaturesOffset()) {
          setSignaturesOffset(other.getSignaturesOffset());
        }
        if (other.hasSignaturesSize()) {
          setSignaturesSize(other.getSignaturesSize());
        }
        if (other.hasOldKernelInfo()) {
          mergeOldKernelInfo(other.getOldKernelInfo());
        }
        if (other.hasNewKernelInfo()) {
          mergeNewKernelInfo(other.getNewKernelInfo());
        }
        if (other.hasOldRootfsInfo()) {
          mergeOldRootfsInfo(other.getOldRootfsInfo());
        }
        if (other.hasNewRootfsInfo()) {
          mergeNewRootfsInfo(other.getNewRootfsInfo());
        }
        if (other.hasOldImageInfo()) {
          mergeOldImageInfo(other.getOldImageInfo());
        }
        if (other.hasNewImageInfo()) {
          mergeNewImageInfo(other.getNewImageInfo());
        }
        if (other.hasMinorVersion()) {
          setMinorVersion(other.getMinorVersion());
        }
        if (partitionsBuilder_ == null) {
          if (!other.partitions_.isEmpty()) {
            if (partitions_.isEmpty()) {
              partitions_ = other.partitions_;
              bitField0_ = (bitField0_ & ~0x00001000);
            } else {
              ensurePartitionsIsMutable();
              partitions_.addAll(other.partitions_);
            }
            onChanged();
          }
        } else {
          if (!other.partitions_.isEmpty()) {
            if (partitionsBuilder_.isEmpty()) {
              partitionsBuilder_.dispose();
              partitionsBuilder_ = null;
              partitions_ = other.partitions_;
              bitField0_ = (bitField0_ & ~0x00001000);
              partitionsBuilder_ =
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getPartitionsFieldBuilder() : null;
            } else {
              partitionsBuilder_.addAllMessages(other.partitions_);
            }
          }
        }
        if (other.hasMaxTimestamp()) {
          setMaxTimestamp(other.getMaxTimestamp());
        }
        if (other.hasDynamicPartitionMetadata()) {
          mergeDynamicPartitionMetadata(other.getDynamicPartitionMetadata());
        }
        if (other.hasPartialUpdate()) {
          setPartialUpdate(other.getPartialUpdate());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        for (int i = 0; i < getInstallOperationsCount(); i++) {
          if (!getInstallOperations(i).isInitialized()) {
            return false;
          }
        }
        for (int i = 0; i < getKernelInstallOperationsCount(); i++) {
          if (!getKernelInstallOperations(i).isInitialized()) {
            return false;
          }
        }
        for (int i = 0; i < getPartitionsCount(); i++) {
          if (!getPartitions(i).isInitialized()) {
            return false;
          }
        }
        if (hasDynamicPartitionMetadata()) {
          if (!getDynamicPartitionMetadata().isInitialized()) {
            return false;
          }
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.util.List<chromeos_update_engine.UpdateMetadata.InstallOperation> installOperations_ =
        java.util.Collections.emptyList();
      private void ensureInstallOperationsIsMutable() {
        if (!((bitField0_ & 0x00000001) != 0)) {
          installOperations_ = new java.util.ArrayList<chromeos_update_engine.UpdateMetadata.InstallOperation>(installOperations_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.InstallOperation, chromeos_update_engine.UpdateMetadata.InstallOperation.Builder, chromeos_update_engine.UpdateMetadata.InstallOperationOrBuilder> installOperationsBuilder_;

      /**
       * <pre>
       * Only present in major version = 1. List of install operations for the
       * kernel and rootfs partitions. For major version = 2 see the |partitions|
       * field.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.InstallOperation install_operations = 1;</code>
       */
      public java.util.List<chromeos_update_engine.UpdateMetadata.InstallOperation> getInstallOperationsList() {
        if (installOperationsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(installOperations_);
        } else {
          return installOperationsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Only present in major version = 1. List of install operations for the
       * kernel and rootfs partitions. For major version = 2 see the |partitions|
       * field.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.InstallOperation install_operations = 1;</code>
       */
      public int getInstallOperationsCount() {
        if (installOperationsBuilder_ == null) {
          return installOperations_.size();
        } else {
          return installOperationsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Only present in major version = 1. List of install operations for the
       * kernel and rootfs partitions. For major version = 2 see the |partitions|
       * field.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.InstallOperation install_operations = 1;</code>
       */
      public chromeos_update_engine.UpdateMetadata.InstallOperation getInstallOperations(int index) {
        if (installOperationsBuilder_ == null) {
          return installOperations_.get(index);
        } else {
          return installOperationsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Only present in major version = 1. List of install operations for the
       * kernel and rootfs partitions. For major version = 2 see the |partitions|
       * field.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.InstallOperation install_operations = 1;</code>
       */
      public Builder setInstallOperations(
          int index, chromeos_update_engine.UpdateMetadata.InstallOperation value) {
        if (installOperationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureInstallOperationsIsMutable();
          installOperations_.set(index, value);
          onChanged();
        } else {
          installOperationsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Only present in major version = 1. List of install operations for the
       * kernel and rootfs partitions. For major version = 2 see the |partitions|
       * field.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.InstallOperation install_operations = 1;</code>
       */
      public Builder setInstallOperations(
          int index, chromeos_update_engine.UpdateMetadata.InstallOperation.Builder builderForValue) {
        if (installOperationsBuilder_ == null) {
          ensureInstallOperationsIsMutable();
          installOperations_.set(index, builderForValue.build());
          onChanged();
        } else {
          installOperationsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Only present in major version = 1. List of install operations for the
       * kernel and rootfs partitions. For major version = 2 see the |partitions|
       * field.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.InstallOperation install_operations = 1;</code>
       */
      public Builder addInstallOperations(chromeos_update_engine.UpdateMetadata.InstallOperation value) {
        if (installOperationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureInstallOperationsIsMutable();
          installOperations_.add(value);
          onChanged();
        } else {
          installOperationsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Only present in major version = 1. List of install operations for the
       * kernel and rootfs partitions. For major version = 2 see the |partitions|
       * field.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.InstallOperation install_operations = 1;</code>
       */
      public Builder addInstallOperations(
          int index, chromeos_update_engine.UpdateMetadata.InstallOperation value) {
        if (installOperationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureInstallOperationsIsMutable();
          installOperations_.add(index, value);
          onChanged();
        } else {
          installOperationsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Only present in major version = 1. List of install operations for the
       * kernel and rootfs partitions. For major version = 2 see the |partitions|
       * field.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.InstallOperation install_operations = 1;</code>
       */
      public Builder addInstallOperations(
          chromeos_update_engine.UpdateMetadata.InstallOperation.Builder builderForValue) {
        if (installOperationsBuilder_ == null) {
          ensureInstallOperationsIsMutable();
          installOperations_.add(builderForValue.build());
          onChanged();
        } else {
          installOperationsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Only present in major version = 1. List of install operations for the
       * kernel and rootfs partitions. For major version = 2 see the |partitions|
       * field.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.InstallOperation install_operations = 1;</code>
       */
      public Builder addInstallOperations(
          int index, chromeos_update_engine.UpdateMetadata.InstallOperation.Builder builderForValue) {
        if (installOperationsBuilder_ == null) {
          ensureInstallOperationsIsMutable();
          installOperations_.add(index, builderForValue.build());
          onChanged();
        } else {
          installOperationsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Only present in major version = 1. List of install operations for the
       * kernel and rootfs partitions. For major version = 2 see the |partitions|
       * field.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.InstallOperation install_operations = 1;</code>
       */
      public Builder addAllInstallOperations(
          java.lang.Iterable<? extends chromeos_update_engine.UpdateMetadata.InstallOperation> values) {
        if (installOperationsBuilder_ == null) {
          ensureInstallOperationsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, installOperations_);
          onChanged();
        } else {
          installOperationsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Only present in major version = 1. List of install operations for the
       * kernel and rootfs partitions. For major version = 2 see the |partitions|
       * field.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.InstallOperation install_operations = 1;</code>
       */
      public Builder clearInstallOperations() {
        if (installOperationsBuilder_ == null) {
          installOperations_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          installOperationsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Only present in major version = 1. List of install operations for the
       * kernel and rootfs partitions. For major version = 2 see the |partitions|
       * field.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.InstallOperation install_operations = 1;</code>
       */
      public Builder removeInstallOperations(int index) {
        if (installOperationsBuilder_ == null) {
          ensureInstallOperationsIsMutable();
          installOperations_.remove(index);
          onChanged();
        } else {
          installOperationsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Only present in major version = 1. List of install operations for the
       * kernel and rootfs partitions. For major version = 2 see the |partitions|
       * field.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.InstallOperation install_operations = 1;</code>
       */
      public chromeos_update_engine.UpdateMetadata.InstallOperation.Builder getInstallOperationsBuilder(
          int index) {
        return getInstallOperationsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Only present in major version = 1. List of install operations for the
       * kernel and rootfs partitions. For major version = 2 see the |partitions|
       * field.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.InstallOperation install_operations = 1;</code>
       */
      public chromeos_update_engine.UpdateMetadata.InstallOperationOrBuilder getInstallOperationsOrBuilder(
          int index) {
        if (installOperationsBuilder_ == null) {
          return installOperations_.get(index);  } else {
          return installOperationsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Only present in major version = 1. List of install operations for the
       * kernel and rootfs partitions. For major version = 2 see the |partitions|
       * field.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.InstallOperation install_operations = 1;</code>
       */
      public java.util.List<? extends chromeos_update_engine.UpdateMetadata.InstallOperationOrBuilder>
           getInstallOperationsOrBuilderList() {
        if (installOperationsBuilder_ != null) {
          return installOperationsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(installOperations_);
        }
      }
      /**
       * <pre>
       * Only present in major version = 1. List of install operations for the
       * kernel and rootfs partitions. For major version = 2 see the |partitions|
       * field.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.InstallOperation install_operations = 1;</code>
       */
      public chromeos_update_engine.UpdateMetadata.InstallOperation.Builder addInstallOperationsBuilder() {
        return getInstallOperationsFieldBuilder().addBuilder(
            chromeos_update_engine.UpdateMetadata.InstallOperation.getDefaultInstance());
      }
      /**
       * <pre>
       * Only present in major version = 1. List of install operations for the
       * kernel and rootfs partitions. For major version = 2 see the |partitions|
       * field.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.InstallOperation install_operations = 1;</code>
       */
      public chromeos_update_engine.UpdateMetadata.InstallOperation.Builder addInstallOperationsBuilder(
          int index) {
        return getInstallOperationsFieldBuilder().addBuilder(
            index, chromeos_update_engine.UpdateMetadata.InstallOperation.getDefaultInstance());
      }
      /**
       * <pre>
       * Only present in major version = 1. List of install operations for the
       * kernel and rootfs partitions. For major version = 2 see the |partitions|
       * field.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.InstallOperation install_operations = 1;</code>
       */
      public java.util.List<chromeos_update_engine.UpdateMetadata.InstallOperation.Builder>
           getInstallOperationsBuilderList() {
        return getInstallOperationsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.InstallOperation, chromeos_update_engine.UpdateMetadata.InstallOperation.Builder, chromeos_update_engine.UpdateMetadata.InstallOperationOrBuilder>
          getInstallOperationsFieldBuilder() {
        if (installOperationsBuilder_ == null) {
          installOperationsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              chromeos_update_engine.UpdateMetadata.InstallOperation, chromeos_update_engine.UpdateMetadata.InstallOperation.Builder, chromeos_update_engine.UpdateMetadata.InstallOperationOrBuilder>(
                  installOperations_,
                  ((bitField0_ & 0x00000001) != 0),
                  getParentForChildren(),
                  isClean());
          installOperations_ = null;
        }
        return installOperationsBuilder_;
      }

      private java.util.List<chromeos_update_engine.UpdateMetadata.InstallOperation> kernelInstallOperations_ =
        java.util.Collections.emptyList();
      private void ensureKernelInstallOperationsIsMutable() {
        if (!((bitField0_ & 0x00000002) != 0)) {
          kernelInstallOperations_ = new java.util.ArrayList<chromeos_update_engine.UpdateMetadata.InstallOperation>(kernelInstallOperations_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.InstallOperation, chromeos_update_engine.UpdateMetadata.InstallOperation.Builder, chromeos_update_engine.UpdateMetadata.InstallOperationOrBuilder> kernelInstallOperationsBuilder_;

      /**
       * <code>repeated .chromeos_update_engine.InstallOperation kernel_install_operations = 2;</code>
       */
      public java.util.List<chromeos_update_engine.UpdateMetadata.InstallOperation> getKernelInstallOperationsList() {
        if (kernelInstallOperationsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(kernelInstallOperations_);
        } else {
          return kernelInstallOperationsBuilder_.getMessageList();
        }
      }
      /**
       * <code>repeated .chromeos_update_engine.InstallOperation kernel_install_operations = 2;</code>
       */
      public int getKernelInstallOperationsCount() {
        if (kernelInstallOperationsBuilder_ == null) {
          return kernelInstallOperations_.size();
        } else {
          return kernelInstallOperationsBuilder_.getCount();
        }
      }
      /**
       * <code>repeated .chromeos_update_engine.InstallOperation kernel_install_operations = 2;</code>
       */
      public chromeos_update_engine.UpdateMetadata.InstallOperation getKernelInstallOperations(int index) {
        if (kernelInstallOperationsBuilder_ == null) {
          return kernelInstallOperations_.get(index);
        } else {
          return kernelInstallOperationsBuilder_.getMessage(index);
        }
      }
      /**
       * <code>repeated .chromeos_update_engine.InstallOperation kernel_install_operations = 2;</code>
       */
      public Builder setKernelInstallOperations(
          int index, chromeos_update_engine.UpdateMetadata.InstallOperation value) {
        if (kernelInstallOperationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureKernelInstallOperationsIsMutable();
          kernelInstallOperations_.set(index, value);
          onChanged();
        } else {
          kernelInstallOperationsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .chromeos_update_engine.InstallOperation kernel_install_operations = 2;</code>
       */
      public Builder setKernelInstallOperations(
          int index, chromeos_update_engine.UpdateMetadata.InstallOperation.Builder builderForValue) {
        if (kernelInstallOperationsBuilder_ == null) {
          ensureKernelInstallOperationsIsMutable();
          kernelInstallOperations_.set(index, builderForValue.build());
          onChanged();
        } else {
          kernelInstallOperationsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .chromeos_update_engine.InstallOperation kernel_install_operations = 2;</code>
       */
      public Builder addKernelInstallOperations(chromeos_update_engine.UpdateMetadata.InstallOperation value) {
        if (kernelInstallOperationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureKernelInstallOperationsIsMutable();
          kernelInstallOperations_.add(value);
          onChanged();
        } else {
          kernelInstallOperationsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <code>repeated .chromeos_update_engine.InstallOperation kernel_install_operations = 2;</code>
       */
      public Builder addKernelInstallOperations(
          int index, chromeos_update_engine.UpdateMetadata.InstallOperation value) {
        if (kernelInstallOperationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureKernelInstallOperationsIsMutable();
          kernelInstallOperations_.add(index, value);
          onChanged();
        } else {
          kernelInstallOperationsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .chromeos_update_engine.InstallOperation kernel_install_operations = 2;</code>
       */
      public Builder addKernelInstallOperations(
          chromeos_update_engine.UpdateMetadata.InstallOperation.Builder builderForValue) {
        if (kernelInstallOperationsBuilder_ == null) {
          ensureKernelInstallOperationsIsMutable();
          kernelInstallOperations_.add(builderForValue.build());
          onChanged();
        } else {
          kernelInstallOperationsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .chromeos_update_engine.InstallOperation kernel_install_operations = 2;</code>
       */
      public Builder addKernelInstallOperations(
          int index, chromeos_update_engine.UpdateMetadata.InstallOperation.Builder builderForValue) {
        if (kernelInstallOperationsBuilder_ == null) {
          ensureKernelInstallOperationsIsMutable();
          kernelInstallOperations_.add(index, builderForValue.build());
          onChanged();
        } else {
          kernelInstallOperationsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .chromeos_update_engine.InstallOperation kernel_install_operations = 2;</code>
       */
      public Builder addAllKernelInstallOperations(
          java.lang.Iterable<? extends chromeos_update_engine.UpdateMetadata.InstallOperation> values) {
        if (kernelInstallOperationsBuilder_ == null) {
          ensureKernelInstallOperationsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, kernelInstallOperations_);
          onChanged();
        } else {
          kernelInstallOperationsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <code>repeated .chromeos_update_engine.InstallOperation kernel_install_operations = 2;</code>
       */
      public Builder clearKernelInstallOperations() {
        if (kernelInstallOperationsBuilder_ == null) {
          kernelInstallOperations_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          kernelInstallOperationsBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>repeated .chromeos_update_engine.InstallOperation kernel_install_operations = 2;</code>
       */
      public Builder removeKernelInstallOperations(int index) {
        if (kernelInstallOperationsBuilder_ == null) {
          ensureKernelInstallOperationsIsMutable();
          kernelInstallOperations_.remove(index);
          onChanged();
        } else {
          kernelInstallOperationsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <code>repeated .chromeos_update_engine.InstallOperation kernel_install_operations = 2;</code>
       */
      public chromeos_update_engine.UpdateMetadata.InstallOperation.Builder getKernelInstallOperationsBuilder(
          int index) {
        return getKernelInstallOperationsFieldBuilder().getBuilder(index);
      }
      /**
       * <code>repeated .chromeos_update_engine.InstallOperation kernel_install_operations = 2;</code>
       */
      public chromeos_update_engine.UpdateMetadata.InstallOperationOrBuilder getKernelInstallOperationsOrBuilder(
          int index) {
        if (kernelInstallOperationsBuilder_ == null) {
          return kernelInstallOperations_.get(index);  } else {
          return kernelInstallOperationsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <code>repeated .chromeos_update_engine.InstallOperation kernel_install_operations = 2;</code>
       */
      public java.util.List<? extends chromeos_update_engine.UpdateMetadata.InstallOperationOrBuilder>
           getKernelInstallOperationsOrBuilderList() {
        if (kernelInstallOperationsBuilder_ != null) {
          return kernelInstallOperationsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(kernelInstallOperations_);
        }
      }
      /**
       * <code>repeated .chromeos_update_engine.InstallOperation kernel_install_operations = 2;</code>
       */
      public chromeos_update_engine.UpdateMetadata.InstallOperation.Builder addKernelInstallOperationsBuilder() {
        return getKernelInstallOperationsFieldBuilder().addBuilder(
            chromeos_update_engine.UpdateMetadata.InstallOperation.getDefaultInstance());
      }
      /**
       * <code>repeated .chromeos_update_engine.InstallOperation kernel_install_operations = 2;</code>
       */
      public chromeos_update_engine.UpdateMetadata.InstallOperation.Builder addKernelInstallOperationsBuilder(
          int index) {
        return getKernelInstallOperationsFieldBuilder().addBuilder(
            index, chromeos_update_engine.UpdateMetadata.InstallOperation.getDefaultInstance());
      }
      /**
       * <code>repeated .chromeos_update_engine.InstallOperation kernel_install_operations = 2;</code>
       */
      public java.util.List<chromeos_update_engine.UpdateMetadata.InstallOperation.Builder>
           getKernelInstallOperationsBuilderList() {
        return getKernelInstallOperationsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.InstallOperation, chromeos_update_engine.UpdateMetadata.InstallOperation.Builder, chromeos_update_engine.UpdateMetadata.InstallOperationOrBuilder>
          getKernelInstallOperationsFieldBuilder() {
        if (kernelInstallOperationsBuilder_ == null) {
          kernelInstallOperationsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              chromeos_update_engine.UpdateMetadata.InstallOperation, chromeos_update_engine.UpdateMetadata.InstallOperation.Builder, chromeos_update_engine.UpdateMetadata.InstallOperationOrBuilder>(
                  kernelInstallOperations_,
                  ((bitField0_ & 0x00000002) != 0),
                  getParentForChildren(),
                  isClean());
          kernelInstallOperations_ = null;
        }
        return kernelInstallOperationsBuilder_;
      }

      private int blockSize_ = 4096;
      /**
       * <pre>
       * (At time of writing) usually 4096
       * </pre>
       *
       * <code>optional uint32 block_size = 3 [default = 4096];</code>
       * @return Whether the blockSize field is set.
       */
      @java.lang.Override
      public boolean hasBlockSize() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * (At time of writing) usually 4096
       * </pre>
       *
       * <code>optional uint32 block_size = 3 [default = 4096];</code>
       * @return The blockSize.
       */
      @java.lang.Override
      public int getBlockSize() {
        return blockSize_;
      }
      /**
       * <pre>
       * (At time of writing) usually 4096
       * </pre>
       *
       * <code>optional uint32 block_size = 3 [default = 4096];</code>
       * @param value The blockSize to set.
       * @return This builder for chaining.
       */
      public Builder setBlockSize(int value) {
        bitField0_ |= 0x00000004;
        blockSize_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * (At time of writing) usually 4096
       * </pre>
       *
       * <code>optional uint32 block_size = 3 [default = 4096];</code>
       * @return This builder for chaining.
       */
      public Builder clearBlockSize() {
        bitField0_ = (bitField0_ & ~0x00000004);
        blockSize_ = 4096;
        onChanged();
        return this;
      }

      private long signaturesOffset_ ;
      /**
       * <pre>
       * If signatures are present, the offset into the blobs, generally
       * tacked onto the end of the file, and the length. We use an offset
       * rather than a bool to allow for more flexibility in future file formats.
       * If either is absent, it means signatures aren't supported in this
       * file.
       * </pre>
       *
       * <code>optional uint64 signatures_offset = 4;</code>
       * @return Whether the signaturesOffset field is set.
       */
      @java.lang.Override
      public boolean hasSignaturesOffset() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * If signatures are present, the offset into the blobs, generally
       * tacked onto the end of the file, and the length. We use an offset
       * rather than a bool to allow for more flexibility in future file formats.
       * If either is absent, it means signatures aren't supported in this
       * file.
       * </pre>
       *
       * <code>optional uint64 signatures_offset = 4;</code>
       * @return The signaturesOffset.
       */
      @java.lang.Override
      public long getSignaturesOffset() {
        return signaturesOffset_;
      }
      /**
       * <pre>
       * If signatures are present, the offset into the blobs, generally
       * tacked onto the end of the file, and the length. We use an offset
       * rather than a bool to allow for more flexibility in future file formats.
       * If either is absent, it means signatures aren't supported in this
       * file.
       * </pre>
       *
       * <code>optional uint64 signatures_offset = 4;</code>
       * @param value The signaturesOffset to set.
       * @return This builder for chaining.
       */
      public Builder setSignaturesOffset(long value) {
        bitField0_ |= 0x00000008;
        signaturesOffset_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If signatures are present, the offset into the blobs, generally
       * tacked onto the end of the file, and the length. We use an offset
       * rather than a bool to allow for more flexibility in future file formats.
       * If either is absent, it means signatures aren't supported in this
       * file.
       * </pre>
       *
       * <code>optional uint64 signatures_offset = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearSignaturesOffset() {
        bitField0_ = (bitField0_ & ~0x00000008);
        signaturesOffset_ = 0L;
        onChanged();
        return this;
      }

      private long signaturesSize_ ;
      /**
       * <code>optional uint64 signatures_size = 5;</code>
       * @return Whether the signaturesSize field is set.
       */
      @java.lang.Override
      public boolean hasSignaturesSize() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <code>optional uint64 signatures_size = 5;</code>
       * @return The signaturesSize.
       */
      @java.lang.Override
      public long getSignaturesSize() {
        return signaturesSize_;
      }
      /**
       * <code>optional uint64 signatures_size = 5;</code>
       * @param value The signaturesSize to set.
       * @return This builder for chaining.
       */
      public Builder setSignaturesSize(long value) {
        bitField0_ |= 0x00000010;
        signaturesSize_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional uint64 signatures_size = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearSignaturesSize() {
        bitField0_ = (bitField0_ & ~0x00000010);
        signaturesSize_ = 0L;
        onChanged();
        return this;
      }

      private chromeos_update_engine.UpdateMetadata.PartitionInfo oldKernelInfo_;
      private com.google.protobuf.SingleFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.PartitionInfo, chromeos_update_engine.UpdateMetadata.PartitionInfo.Builder, chromeos_update_engine.UpdateMetadata.PartitionInfoOrBuilder> oldKernelInfoBuilder_;
      /**
       * <pre>
       * Only present in major version = 1. Partition metadata used to validate the
       * update. For major version = 2 see the |partitions| field.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.PartitionInfo old_kernel_info = 6;</code>
       * @return Whether the oldKernelInfo field is set.
       */
      public boolean hasOldKernelInfo() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * Only present in major version = 1. Partition metadata used to validate the
       * update. For major version = 2 see the |partitions| field.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.PartitionInfo old_kernel_info = 6;</code>
       * @return The oldKernelInfo.
       */
      public chromeos_update_engine.UpdateMetadata.PartitionInfo getOldKernelInfo() {
        if (oldKernelInfoBuilder_ == null) {
          return oldKernelInfo_ == null ? chromeos_update_engine.UpdateMetadata.PartitionInfo.getDefaultInstance() : oldKernelInfo_;
        } else {
          return oldKernelInfoBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Only present in major version = 1. Partition metadata used to validate the
       * update. For major version = 2 see the |partitions| field.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.PartitionInfo old_kernel_info = 6;</code>
       */
      public Builder setOldKernelInfo(chromeos_update_engine.UpdateMetadata.PartitionInfo value) {
        if (oldKernelInfoBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          oldKernelInfo_ = value;
          onChanged();
        } else {
          oldKernelInfoBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000020;
        return this;
      }
      /**
       * <pre>
       * Only present in major version = 1. Partition metadata used to validate the
       * update. For major version = 2 see the |partitions| field.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.PartitionInfo old_kernel_info = 6;</code>
       */
      public Builder setOldKernelInfo(
          chromeos_update_engine.UpdateMetadata.PartitionInfo.Builder builderForValue) {
        if (oldKernelInfoBuilder_ == null) {
          oldKernelInfo_ = builderForValue.build();
          onChanged();
        } else {
          oldKernelInfoBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000020;
        return this;
      }
      /**
       * <pre>
       * Only present in major version = 1. Partition metadata used to validate the
       * update. For major version = 2 see the |partitions| field.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.PartitionInfo old_kernel_info = 6;</code>
       */
      public Builder mergeOldKernelInfo(chromeos_update_engine.UpdateMetadata.PartitionInfo value) {
        if (oldKernelInfoBuilder_ == null) {
          if (((bitField0_ & 0x00000020) != 0) &&
              oldKernelInfo_ != null &&
              oldKernelInfo_ != chromeos_update_engine.UpdateMetadata.PartitionInfo.getDefaultInstance()) {
            oldKernelInfo_ =
              chromeos_update_engine.UpdateMetadata.PartitionInfo.newBuilder(oldKernelInfo_).mergeFrom(value).buildPartial();
          } else {
            oldKernelInfo_ = value;
          }
          onChanged();
        } else {
          oldKernelInfoBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000020;
        return this;
      }
      /**
       * <pre>
       * Only present in major version = 1. Partition metadata used to validate the
       * update. For major version = 2 see the |partitions| field.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.PartitionInfo old_kernel_info = 6;</code>
       */
      public Builder clearOldKernelInfo() {
        if (oldKernelInfoBuilder_ == null) {
          oldKernelInfo_ = null;
          onChanged();
        } else {
          oldKernelInfoBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000020);
        return this;
      }
      /**
       * <pre>
       * Only present in major version = 1. Partition metadata used to validate the
       * update. For major version = 2 see the |partitions| field.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.PartitionInfo old_kernel_info = 6;</code>
       */
      public chromeos_update_engine.UpdateMetadata.PartitionInfo.Builder getOldKernelInfoBuilder() {
        bitField0_ |= 0x00000020;
        onChanged();
        return getOldKernelInfoFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Only present in major version = 1. Partition metadata used to validate the
       * update. For major version = 2 see the |partitions| field.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.PartitionInfo old_kernel_info = 6;</code>
       */
      public chromeos_update_engine.UpdateMetadata.PartitionInfoOrBuilder getOldKernelInfoOrBuilder() {
        if (oldKernelInfoBuilder_ != null) {
          return oldKernelInfoBuilder_.getMessageOrBuilder();
        } else {
          return oldKernelInfo_ == null ?
              chromeos_update_engine.UpdateMetadata.PartitionInfo.getDefaultInstance() : oldKernelInfo_;
        }
      }
      /**
       * <pre>
       * Only present in major version = 1. Partition metadata used to validate the
       * update. For major version = 2 see the |partitions| field.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.PartitionInfo old_kernel_info = 6;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.PartitionInfo, chromeos_update_engine.UpdateMetadata.PartitionInfo.Builder, chromeos_update_engine.UpdateMetadata.PartitionInfoOrBuilder>
          getOldKernelInfoFieldBuilder() {
        if (oldKernelInfoBuilder_ == null) {
          oldKernelInfoBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              chromeos_update_engine.UpdateMetadata.PartitionInfo, chromeos_update_engine.UpdateMetadata.PartitionInfo.Builder, chromeos_update_engine.UpdateMetadata.PartitionInfoOrBuilder>(
                  getOldKernelInfo(),
                  getParentForChildren(),
                  isClean());
          oldKernelInfo_ = null;
        }
        return oldKernelInfoBuilder_;
      }

      private chromeos_update_engine.UpdateMetadata.PartitionInfo newKernelInfo_;
      private com.google.protobuf.SingleFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.PartitionInfo, chromeos_update_engine.UpdateMetadata.PartitionInfo.Builder, chromeos_update_engine.UpdateMetadata.PartitionInfoOrBuilder> newKernelInfoBuilder_;
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo new_kernel_info = 7;</code>
       * @return Whether the newKernelInfo field is set.
       */
      public boolean hasNewKernelInfo() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo new_kernel_info = 7;</code>
       * @return The newKernelInfo.
       */
      public chromeos_update_engine.UpdateMetadata.PartitionInfo getNewKernelInfo() {
        if (newKernelInfoBuilder_ == null) {
          return newKernelInfo_ == null ? chromeos_update_engine.UpdateMetadata.PartitionInfo.getDefaultInstance() : newKernelInfo_;
        } else {
          return newKernelInfoBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo new_kernel_info = 7;</code>
       */
      public Builder setNewKernelInfo(chromeos_update_engine.UpdateMetadata.PartitionInfo value) {
        if (newKernelInfoBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          newKernelInfo_ = value;
          onChanged();
        } else {
          newKernelInfoBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000040;
        return this;
      }
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo new_kernel_info = 7;</code>
       */
      public Builder setNewKernelInfo(
          chromeos_update_engine.UpdateMetadata.PartitionInfo.Builder builderForValue) {
        if (newKernelInfoBuilder_ == null) {
          newKernelInfo_ = builderForValue.build();
          onChanged();
        } else {
          newKernelInfoBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000040;
        return this;
      }
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo new_kernel_info = 7;</code>
       */
      public Builder mergeNewKernelInfo(chromeos_update_engine.UpdateMetadata.PartitionInfo value) {
        if (newKernelInfoBuilder_ == null) {
          if (((bitField0_ & 0x00000040) != 0) &&
              newKernelInfo_ != null &&
              newKernelInfo_ != chromeos_update_engine.UpdateMetadata.PartitionInfo.getDefaultInstance()) {
            newKernelInfo_ =
              chromeos_update_engine.UpdateMetadata.PartitionInfo.newBuilder(newKernelInfo_).mergeFrom(value).buildPartial();
          } else {
            newKernelInfo_ = value;
          }
          onChanged();
        } else {
          newKernelInfoBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000040;
        return this;
      }
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo new_kernel_info = 7;</code>
       */
      public Builder clearNewKernelInfo() {
        if (newKernelInfoBuilder_ == null) {
          newKernelInfo_ = null;
          onChanged();
        } else {
          newKernelInfoBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000040);
        return this;
      }
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo new_kernel_info = 7;</code>
       */
      public chromeos_update_engine.UpdateMetadata.PartitionInfo.Builder getNewKernelInfoBuilder() {
        bitField0_ |= 0x00000040;
        onChanged();
        return getNewKernelInfoFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo new_kernel_info = 7;</code>
       */
      public chromeos_update_engine.UpdateMetadata.PartitionInfoOrBuilder getNewKernelInfoOrBuilder() {
        if (newKernelInfoBuilder_ != null) {
          return newKernelInfoBuilder_.getMessageOrBuilder();
        } else {
          return newKernelInfo_ == null ?
              chromeos_update_engine.UpdateMetadata.PartitionInfo.getDefaultInstance() : newKernelInfo_;
        }
      }
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo new_kernel_info = 7;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.PartitionInfo, chromeos_update_engine.UpdateMetadata.PartitionInfo.Builder, chromeos_update_engine.UpdateMetadata.PartitionInfoOrBuilder>
          getNewKernelInfoFieldBuilder() {
        if (newKernelInfoBuilder_ == null) {
          newKernelInfoBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              chromeos_update_engine.UpdateMetadata.PartitionInfo, chromeos_update_engine.UpdateMetadata.PartitionInfo.Builder, chromeos_update_engine.UpdateMetadata.PartitionInfoOrBuilder>(
                  getNewKernelInfo(),
                  getParentForChildren(),
                  isClean());
          newKernelInfo_ = null;
        }
        return newKernelInfoBuilder_;
      }

      private chromeos_update_engine.UpdateMetadata.PartitionInfo oldRootfsInfo_;
      private com.google.protobuf.SingleFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.PartitionInfo, chromeos_update_engine.UpdateMetadata.PartitionInfo.Builder, chromeos_update_engine.UpdateMetadata.PartitionInfoOrBuilder> oldRootfsInfoBuilder_;
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo old_rootfs_info = 8;</code>
       * @return Whether the oldRootfsInfo field is set.
       */
      public boolean hasOldRootfsInfo() {
        return ((bitField0_ & 0x00000080) != 0);
      }
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo old_rootfs_info = 8;</code>
       * @return The oldRootfsInfo.
       */
      public chromeos_update_engine.UpdateMetadata.PartitionInfo getOldRootfsInfo() {
        if (oldRootfsInfoBuilder_ == null) {
          return oldRootfsInfo_ == null ? chromeos_update_engine.UpdateMetadata.PartitionInfo.getDefaultInstance() : oldRootfsInfo_;
        } else {
          return oldRootfsInfoBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo old_rootfs_info = 8;</code>
       */
      public Builder setOldRootfsInfo(chromeos_update_engine.UpdateMetadata.PartitionInfo value) {
        if (oldRootfsInfoBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          oldRootfsInfo_ = value;
          onChanged();
        } else {
          oldRootfsInfoBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000080;
        return this;
      }
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo old_rootfs_info = 8;</code>
       */
      public Builder setOldRootfsInfo(
          chromeos_update_engine.UpdateMetadata.PartitionInfo.Builder builderForValue) {
        if (oldRootfsInfoBuilder_ == null) {
          oldRootfsInfo_ = builderForValue.build();
          onChanged();
        } else {
          oldRootfsInfoBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000080;
        return this;
      }
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo old_rootfs_info = 8;</code>
       */
      public Builder mergeOldRootfsInfo(chromeos_update_engine.UpdateMetadata.PartitionInfo value) {
        if (oldRootfsInfoBuilder_ == null) {
          if (((bitField0_ & 0x00000080) != 0) &&
              oldRootfsInfo_ != null &&
              oldRootfsInfo_ != chromeos_update_engine.UpdateMetadata.PartitionInfo.getDefaultInstance()) {
            oldRootfsInfo_ =
              chromeos_update_engine.UpdateMetadata.PartitionInfo.newBuilder(oldRootfsInfo_).mergeFrom(value).buildPartial();
          } else {
            oldRootfsInfo_ = value;
          }
          onChanged();
        } else {
          oldRootfsInfoBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000080;
        return this;
      }
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo old_rootfs_info = 8;</code>
       */
      public Builder clearOldRootfsInfo() {
        if (oldRootfsInfoBuilder_ == null) {
          oldRootfsInfo_ = null;
          onChanged();
        } else {
          oldRootfsInfoBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000080);
        return this;
      }
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo old_rootfs_info = 8;</code>
       */
      public chromeos_update_engine.UpdateMetadata.PartitionInfo.Builder getOldRootfsInfoBuilder() {
        bitField0_ |= 0x00000080;
        onChanged();
        return getOldRootfsInfoFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo old_rootfs_info = 8;</code>
       */
      public chromeos_update_engine.UpdateMetadata.PartitionInfoOrBuilder getOldRootfsInfoOrBuilder() {
        if (oldRootfsInfoBuilder_ != null) {
          return oldRootfsInfoBuilder_.getMessageOrBuilder();
        } else {
          return oldRootfsInfo_ == null ?
              chromeos_update_engine.UpdateMetadata.PartitionInfo.getDefaultInstance() : oldRootfsInfo_;
        }
      }
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo old_rootfs_info = 8;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.PartitionInfo, chromeos_update_engine.UpdateMetadata.PartitionInfo.Builder, chromeos_update_engine.UpdateMetadata.PartitionInfoOrBuilder>
          getOldRootfsInfoFieldBuilder() {
        if (oldRootfsInfoBuilder_ == null) {
          oldRootfsInfoBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              chromeos_update_engine.UpdateMetadata.PartitionInfo, chromeos_update_engine.UpdateMetadata.PartitionInfo.Builder, chromeos_update_engine.UpdateMetadata.PartitionInfoOrBuilder>(
                  getOldRootfsInfo(),
                  getParentForChildren(),
                  isClean());
          oldRootfsInfo_ = null;
        }
        return oldRootfsInfoBuilder_;
      }

      private chromeos_update_engine.UpdateMetadata.PartitionInfo newRootfsInfo_;
      private com.google.protobuf.SingleFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.PartitionInfo, chromeos_update_engine.UpdateMetadata.PartitionInfo.Builder, chromeos_update_engine.UpdateMetadata.PartitionInfoOrBuilder> newRootfsInfoBuilder_;
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo new_rootfs_info = 9;</code>
       * @return Whether the newRootfsInfo field is set.
       */
      public boolean hasNewRootfsInfo() {
        return ((bitField0_ & 0x00000100) != 0);
      }
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo new_rootfs_info = 9;</code>
       * @return The newRootfsInfo.
       */
      public chromeos_update_engine.UpdateMetadata.PartitionInfo getNewRootfsInfo() {
        if (newRootfsInfoBuilder_ == null) {
          return newRootfsInfo_ == null ? chromeos_update_engine.UpdateMetadata.PartitionInfo.getDefaultInstance() : newRootfsInfo_;
        } else {
          return newRootfsInfoBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo new_rootfs_info = 9;</code>
       */
      public Builder setNewRootfsInfo(chromeos_update_engine.UpdateMetadata.PartitionInfo value) {
        if (newRootfsInfoBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          newRootfsInfo_ = value;
          onChanged();
        } else {
          newRootfsInfoBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000100;
        return this;
      }
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo new_rootfs_info = 9;</code>
       */
      public Builder setNewRootfsInfo(
          chromeos_update_engine.UpdateMetadata.PartitionInfo.Builder builderForValue) {
        if (newRootfsInfoBuilder_ == null) {
          newRootfsInfo_ = builderForValue.build();
          onChanged();
        } else {
          newRootfsInfoBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000100;
        return this;
      }
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo new_rootfs_info = 9;</code>
       */
      public Builder mergeNewRootfsInfo(chromeos_update_engine.UpdateMetadata.PartitionInfo value) {
        if (newRootfsInfoBuilder_ == null) {
          if (((bitField0_ & 0x00000100) != 0) &&
              newRootfsInfo_ != null &&
              newRootfsInfo_ != chromeos_update_engine.UpdateMetadata.PartitionInfo.getDefaultInstance()) {
            newRootfsInfo_ =
              chromeos_update_engine.UpdateMetadata.PartitionInfo.newBuilder(newRootfsInfo_).mergeFrom(value).buildPartial();
          } else {
            newRootfsInfo_ = value;
          }
          onChanged();
        } else {
          newRootfsInfoBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000100;
        return this;
      }
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo new_rootfs_info = 9;</code>
       */
      public Builder clearNewRootfsInfo() {
        if (newRootfsInfoBuilder_ == null) {
          newRootfsInfo_ = null;
          onChanged();
        } else {
          newRootfsInfoBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000100);
        return this;
      }
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo new_rootfs_info = 9;</code>
       */
      public chromeos_update_engine.UpdateMetadata.PartitionInfo.Builder getNewRootfsInfoBuilder() {
        bitField0_ |= 0x00000100;
        onChanged();
        return getNewRootfsInfoFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo new_rootfs_info = 9;</code>
       */
      public chromeos_update_engine.UpdateMetadata.PartitionInfoOrBuilder getNewRootfsInfoOrBuilder() {
        if (newRootfsInfoBuilder_ != null) {
          return newRootfsInfoBuilder_.getMessageOrBuilder();
        } else {
          return newRootfsInfo_ == null ?
              chromeos_update_engine.UpdateMetadata.PartitionInfo.getDefaultInstance() : newRootfsInfo_;
        }
      }
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo new_rootfs_info = 9;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.PartitionInfo, chromeos_update_engine.UpdateMetadata.PartitionInfo.Builder, chromeos_update_engine.UpdateMetadata.PartitionInfoOrBuilder>
          getNewRootfsInfoFieldBuilder() {
        if (newRootfsInfoBuilder_ == null) {
          newRootfsInfoBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              chromeos_update_engine.UpdateMetadata.PartitionInfo, chromeos_update_engine.UpdateMetadata.PartitionInfo.Builder, chromeos_update_engine.UpdateMetadata.PartitionInfoOrBuilder>(
                  getNewRootfsInfo(),
                  getParentForChildren(),
                  isClean());
          newRootfsInfo_ = null;
        }
        return newRootfsInfoBuilder_;
      }

      private chromeos_update_engine.UpdateMetadata.ImageInfo oldImageInfo_;
      private com.google.protobuf.SingleFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.ImageInfo, chromeos_update_engine.UpdateMetadata.ImageInfo.Builder, chromeos_update_engine.UpdateMetadata.ImageInfoOrBuilder> oldImageInfoBuilder_;
      /**
       * <pre>
       * old_image_info will only be present for delta images.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.ImageInfo old_image_info = 10;</code>
       * @return Whether the oldImageInfo field is set.
       */
      public boolean hasOldImageInfo() {
        return ((bitField0_ & 0x00000200) != 0);
      }
      /**
       * <pre>
       * old_image_info will only be present for delta images.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.ImageInfo old_image_info = 10;</code>
       * @return The oldImageInfo.
       */
      public chromeos_update_engine.UpdateMetadata.ImageInfo getOldImageInfo() {
        if (oldImageInfoBuilder_ == null) {
          return oldImageInfo_ == null ? chromeos_update_engine.UpdateMetadata.ImageInfo.getDefaultInstance() : oldImageInfo_;
        } else {
          return oldImageInfoBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * old_image_info will only be present for delta images.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.ImageInfo old_image_info = 10;</code>
       */
      public Builder setOldImageInfo(chromeos_update_engine.UpdateMetadata.ImageInfo value) {
        if (oldImageInfoBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          oldImageInfo_ = value;
          onChanged();
        } else {
          oldImageInfoBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000200;
        return this;
      }
      /**
       * <pre>
       * old_image_info will only be present for delta images.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.ImageInfo old_image_info = 10;</code>
       */
      public Builder setOldImageInfo(
          chromeos_update_engine.UpdateMetadata.ImageInfo.Builder builderForValue) {
        if (oldImageInfoBuilder_ == null) {
          oldImageInfo_ = builderForValue.build();
          onChanged();
        } else {
          oldImageInfoBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000200;
        return this;
      }
      /**
       * <pre>
       * old_image_info will only be present for delta images.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.ImageInfo old_image_info = 10;</code>
       */
      public Builder mergeOldImageInfo(chromeos_update_engine.UpdateMetadata.ImageInfo value) {
        if (oldImageInfoBuilder_ == null) {
          if (((bitField0_ & 0x00000200) != 0) &&
              oldImageInfo_ != null &&
              oldImageInfo_ != chromeos_update_engine.UpdateMetadata.ImageInfo.getDefaultInstance()) {
            oldImageInfo_ =
              chromeos_update_engine.UpdateMetadata.ImageInfo.newBuilder(oldImageInfo_).mergeFrom(value).buildPartial();
          } else {
            oldImageInfo_ = value;
          }
          onChanged();
        } else {
          oldImageInfoBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000200;
        return this;
      }
      /**
       * <pre>
       * old_image_info will only be present for delta images.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.ImageInfo old_image_info = 10;</code>
       */
      public Builder clearOldImageInfo() {
        if (oldImageInfoBuilder_ == null) {
          oldImageInfo_ = null;
          onChanged();
        } else {
          oldImageInfoBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000200);
        return this;
      }
      /**
       * <pre>
       * old_image_info will only be present for delta images.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.ImageInfo old_image_info = 10;</code>
       */
      public chromeos_update_engine.UpdateMetadata.ImageInfo.Builder getOldImageInfoBuilder() {
        bitField0_ |= 0x00000200;
        onChanged();
        return getOldImageInfoFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * old_image_info will only be present for delta images.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.ImageInfo old_image_info = 10;</code>
       */
      public chromeos_update_engine.UpdateMetadata.ImageInfoOrBuilder getOldImageInfoOrBuilder() {
        if (oldImageInfoBuilder_ != null) {
          return oldImageInfoBuilder_.getMessageOrBuilder();
        } else {
          return oldImageInfo_ == null ?
              chromeos_update_engine.UpdateMetadata.ImageInfo.getDefaultInstance() : oldImageInfo_;
        }
      }
      /**
       * <pre>
       * old_image_info will only be present for delta images.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.ImageInfo old_image_info = 10;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.ImageInfo, chromeos_update_engine.UpdateMetadata.ImageInfo.Builder, chromeos_update_engine.UpdateMetadata.ImageInfoOrBuilder>
          getOldImageInfoFieldBuilder() {
        if (oldImageInfoBuilder_ == null) {
          oldImageInfoBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              chromeos_update_engine.UpdateMetadata.ImageInfo, chromeos_update_engine.UpdateMetadata.ImageInfo.Builder, chromeos_update_engine.UpdateMetadata.ImageInfoOrBuilder>(
                  getOldImageInfo(),
                  getParentForChildren(),
                  isClean());
          oldImageInfo_ = null;
        }
        return oldImageInfoBuilder_;
      }

      private chromeos_update_engine.UpdateMetadata.ImageInfo newImageInfo_;
      private com.google.protobuf.SingleFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.ImageInfo, chromeos_update_engine.UpdateMetadata.ImageInfo.Builder, chromeos_update_engine.UpdateMetadata.ImageInfoOrBuilder> newImageInfoBuilder_;
      /**
       * <code>optional .chromeos_update_engine.ImageInfo new_image_info = 11;</code>
       * @return Whether the newImageInfo field is set.
       */
      public boolean hasNewImageInfo() {
        return ((bitField0_ & 0x00000400) != 0);
      }
      /**
       * <code>optional .chromeos_update_engine.ImageInfo new_image_info = 11;</code>
       * @return The newImageInfo.
       */
      public chromeos_update_engine.UpdateMetadata.ImageInfo getNewImageInfo() {
        if (newImageInfoBuilder_ == null) {
          return newImageInfo_ == null ? chromeos_update_engine.UpdateMetadata.ImageInfo.getDefaultInstance() : newImageInfo_;
        } else {
          return newImageInfoBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .chromeos_update_engine.ImageInfo new_image_info = 11;</code>
       */
      public Builder setNewImageInfo(chromeos_update_engine.UpdateMetadata.ImageInfo value) {
        if (newImageInfoBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          newImageInfo_ = value;
          onChanged();
        } else {
          newImageInfoBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000400;
        return this;
      }
      /**
       * <code>optional .chromeos_update_engine.ImageInfo new_image_info = 11;</code>
       */
      public Builder setNewImageInfo(
          chromeos_update_engine.UpdateMetadata.ImageInfo.Builder builderForValue) {
        if (newImageInfoBuilder_ == null) {
          newImageInfo_ = builderForValue.build();
          onChanged();
        } else {
          newImageInfoBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000400;
        return this;
      }
      /**
       * <code>optional .chromeos_update_engine.ImageInfo new_image_info = 11;</code>
       */
      public Builder mergeNewImageInfo(chromeos_update_engine.UpdateMetadata.ImageInfo value) {
        if (newImageInfoBuilder_ == null) {
          if (((bitField0_ & 0x00000400) != 0) &&
              newImageInfo_ != null &&
              newImageInfo_ != chromeos_update_engine.UpdateMetadata.ImageInfo.getDefaultInstance()) {
            newImageInfo_ =
              chromeos_update_engine.UpdateMetadata.ImageInfo.newBuilder(newImageInfo_).mergeFrom(value).buildPartial();
          } else {
            newImageInfo_ = value;
          }
          onChanged();
        } else {
          newImageInfoBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000400;
        return this;
      }
      /**
       * <code>optional .chromeos_update_engine.ImageInfo new_image_info = 11;</code>
       */
      public Builder clearNewImageInfo() {
        if (newImageInfoBuilder_ == null) {
          newImageInfo_ = null;
          onChanged();
        } else {
          newImageInfoBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000400);
        return this;
      }
      /**
       * <code>optional .chromeos_update_engine.ImageInfo new_image_info = 11;</code>
       */
      public chromeos_update_engine.UpdateMetadata.ImageInfo.Builder getNewImageInfoBuilder() {
        bitField0_ |= 0x00000400;
        onChanged();
        return getNewImageInfoFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .chromeos_update_engine.ImageInfo new_image_info = 11;</code>
       */
      public chromeos_update_engine.UpdateMetadata.ImageInfoOrBuilder getNewImageInfoOrBuilder() {
        if (newImageInfoBuilder_ != null) {
          return newImageInfoBuilder_.getMessageOrBuilder();
        } else {
          return newImageInfo_ == null ?
              chromeos_update_engine.UpdateMetadata.ImageInfo.getDefaultInstance() : newImageInfo_;
        }
      }
      /**
       * <code>optional .chromeos_update_engine.ImageInfo new_image_info = 11;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.ImageInfo, chromeos_update_engine.UpdateMetadata.ImageInfo.Builder, chromeos_update_engine.UpdateMetadata.ImageInfoOrBuilder>
          getNewImageInfoFieldBuilder() {
        if (newImageInfoBuilder_ == null) {
          newImageInfoBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              chromeos_update_engine.UpdateMetadata.ImageInfo, chromeos_update_engine.UpdateMetadata.ImageInfo.Builder, chromeos_update_engine.UpdateMetadata.ImageInfoOrBuilder>(
                  getNewImageInfo(),
                  getParentForChildren(),
                  isClean());
          newImageInfo_ = null;
        }
        return newImageInfoBuilder_;
      }

      private int minorVersion_ ;
      /**
       * <pre>
       * The minor version, also referred as "delta version", of the payload.
       * Minor version 0 is full payload, everything else is delta payload.
       * </pre>
       *
       * <code>optional uint32 minor_version = 12 [default = 0];</code>
       * @return Whether the minorVersion field is set.
       */
      @java.lang.Override
      public boolean hasMinorVersion() {
        return ((bitField0_ & 0x00000800) != 0);
      }
      /**
       * <pre>
       * The minor version, also referred as "delta version", of the payload.
       * Minor version 0 is full payload, everything else is delta payload.
       * </pre>
       *
       * <code>optional uint32 minor_version = 12 [default = 0];</code>
       * @return The minorVersion.
       */
      @java.lang.Override
      public int getMinorVersion() {
        return minorVersion_;
      }
      /**
       * <pre>
       * The minor version, also referred as "delta version", of the payload.
       * Minor version 0 is full payload, everything else is delta payload.
       * </pre>
       *
       * <code>optional uint32 minor_version = 12 [default = 0];</code>
       * @param value The minorVersion to set.
       * @return This builder for chaining.
       */
      public Builder setMinorVersion(int value) {
        bitField0_ |= 0x00000800;
        minorVersion_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The minor version, also referred as "delta version", of the payload.
       * Minor version 0 is full payload, everything else is delta payload.
       * </pre>
       *
       * <code>optional uint32 minor_version = 12 [default = 0];</code>
       * @return This builder for chaining.
       */
      public Builder clearMinorVersion() {
        bitField0_ = (bitField0_ & ~0x00000800);
        minorVersion_ = 0;
        onChanged();
        return this;
      }

      private java.util.List<chromeos_update_engine.UpdateMetadata.PartitionUpdate> partitions_ =
        java.util.Collections.emptyList();
      private void ensurePartitionsIsMutable() {
        if (!((bitField0_ & 0x00001000) != 0)) {
          partitions_ = new java.util.ArrayList<chromeos_update_engine.UpdateMetadata.PartitionUpdate>(partitions_);
          bitField0_ |= 0x00001000;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.PartitionUpdate, chromeos_update_engine.UpdateMetadata.PartitionUpdate.Builder, chromeos_update_engine.UpdateMetadata.PartitionUpdateOrBuilder> partitionsBuilder_;

      /**
       * <pre>
       * Only present in major version &gt;= 2. List of partitions that will be
       * updated, in the order they will be updated. This field replaces the
       * |install_operations|, |kernel_install_operations| and the
       * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
       * array can have more than two partitions if needed, and they are identified
       * by the partition name.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.PartitionUpdate partitions = 13;</code>
       */
      public java.util.List<chromeos_update_engine.UpdateMetadata.PartitionUpdate> getPartitionsList() {
        if (partitionsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(partitions_);
        } else {
          return partitionsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Only present in major version &gt;= 2. List of partitions that will be
       * updated, in the order they will be updated. This field replaces the
       * |install_operations|, |kernel_install_operations| and the
       * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
       * array can have more than two partitions if needed, and they are identified
       * by the partition name.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.PartitionUpdate partitions = 13;</code>
       */
      public int getPartitionsCount() {
        if (partitionsBuilder_ == null) {
          return partitions_.size();
        } else {
          return partitionsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Only present in major version &gt;= 2. List of partitions that will be
       * updated, in the order they will be updated. This field replaces the
       * |install_operations|, |kernel_install_operations| and the
       * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
       * array can have more than two partitions if needed, and they are identified
       * by the partition name.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.PartitionUpdate partitions = 13;</code>
       */
      public chromeos_update_engine.UpdateMetadata.PartitionUpdate getPartitions(int index) {
        if (partitionsBuilder_ == null) {
          return partitions_.get(index);
        } else {
          return partitionsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Only present in major version &gt;= 2. List of partitions that will be
       * updated, in the order they will be updated. This field replaces the
       * |install_operations|, |kernel_install_operations| and the
       * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
       * array can have more than two partitions if needed, and they are identified
       * by the partition name.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.PartitionUpdate partitions = 13;</code>
       */
      public Builder setPartitions(
          int index, chromeos_update_engine.UpdateMetadata.PartitionUpdate value) {
        if (partitionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensurePartitionsIsMutable();
          partitions_.set(index, value);
          onChanged();
        } else {
          partitionsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Only present in major version &gt;= 2. List of partitions that will be
       * updated, in the order they will be updated. This field replaces the
       * |install_operations|, |kernel_install_operations| and the
       * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
       * array can have more than two partitions if needed, and they are identified
       * by the partition name.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.PartitionUpdate partitions = 13;</code>
       */
      public Builder setPartitions(
          int index, chromeos_update_engine.UpdateMetadata.PartitionUpdate.Builder builderForValue) {
        if (partitionsBuilder_ == null) {
          ensurePartitionsIsMutable();
          partitions_.set(index, builderForValue.build());
          onChanged();
        } else {
          partitionsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Only present in major version &gt;= 2. List of partitions that will be
       * updated, in the order they will be updated. This field replaces the
       * |install_operations|, |kernel_install_operations| and the
       * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
       * array can have more than two partitions if needed, and they are identified
       * by the partition name.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.PartitionUpdate partitions = 13;</code>
       */
      public Builder addPartitions(chromeos_update_engine.UpdateMetadata.PartitionUpdate value) {
        if (partitionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensurePartitionsIsMutable();
          partitions_.add(value);
          onChanged();
        } else {
          partitionsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Only present in major version &gt;= 2. List of partitions that will be
       * updated, in the order they will be updated. This field replaces the
       * |install_operations|, |kernel_install_operations| and the
       * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
       * array can have more than two partitions if needed, and they are identified
       * by the partition name.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.PartitionUpdate partitions = 13;</code>
       */
      public Builder addPartitions(
          int index, chromeos_update_engine.UpdateMetadata.PartitionUpdate value) {
        if (partitionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensurePartitionsIsMutable();
          partitions_.add(index, value);
          onChanged();
        } else {
          partitionsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Only present in major version &gt;= 2. List of partitions that will be
       * updated, in the order they will be updated. This field replaces the
       * |install_operations|, |kernel_install_operations| and the
       * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
       * array can have more than two partitions if needed, and they are identified
       * by the partition name.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.PartitionUpdate partitions = 13;</code>
       */
      public Builder addPartitions(
          chromeos_update_engine.UpdateMetadata.PartitionUpdate.Builder builderForValue) {
        if (partitionsBuilder_ == null) {
          ensurePartitionsIsMutable();
          partitions_.add(builderForValue.build());
          onChanged();
        } else {
          partitionsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Only present in major version &gt;= 2. List of partitions that will be
       * updated, in the order they will be updated. This field replaces the
       * |install_operations|, |kernel_install_operations| and the
       * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
       * array can have more than two partitions if needed, and they are identified
       * by the partition name.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.PartitionUpdate partitions = 13;</code>
       */
      public Builder addPartitions(
          int index, chromeos_update_engine.UpdateMetadata.PartitionUpdate.Builder builderForValue) {
        if (partitionsBuilder_ == null) {
          ensurePartitionsIsMutable();
          partitions_.add(index, builderForValue.build());
          onChanged();
        } else {
          partitionsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Only present in major version &gt;= 2. List of partitions that will be
       * updated, in the order they will be updated. This field replaces the
       * |install_operations|, |kernel_install_operations| and the
       * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
       * array can have more than two partitions if needed, and they are identified
       * by the partition name.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.PartitionUpdate partitions = 13;</code>
       */
      public Builder addAllPartitions(
          java.lang.Iterable<? extends chromeos_update_engine.UpdateMetadata.PartitionUpdate> values) {
        if (partitionsBuilder_ == null) {
          ensurePartitionsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, partitions_);
          onChanged();
        } else {
          partitionsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Only present in major version &gt;= 2. List of partitions that will be
       * updated, in the order they will be updated. This field replaces the
       * |install_operations|, |kernel_install_operations| and the
       * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
       * array can have more than two partitions if needed, and they are identified
       * by the partition name.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.PartitionUpdate partitions = 13;</code>
       */
      public Builder clearPartitions() {
        if (partitionsBuilder_ == null) {
          partitions_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00001000);
          onChanged();
        } else {
          partitionsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Only present in major version &gt;= 2. List of partitions that will be
       * updated, in the order they will be updated. This field replaces the
       * |install_operations|, |kernel_install_operations| and the
       * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
       * array can have more than two partitions if needed, and they are identified
       * by the partition name.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.PartitionUpdate partitions = 13;</code>
       */
      public Builder removePartitions(int index) {
        if (partitionsBuilder_ == null) {
          ensurePartitionsIsMutable();
          partitions_.remove(index);
          onChanged();
        } else {
          partitionsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Only present in major version &gt;= 2. List of partitions that will be
       * updated, in the order they will be updated. This field replaces the
       * |install_operations|, |kernel_install_operations| and the
       * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
       * array can have more than two partitions if needed, and they are identified
       * by the partition name.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.PartitionUpdate partitions = 13;</code>
       */
      public chromeos_update_engine.UpdateMetadata.PartitionUpdate.Builder getPartitionsBuilder(
          int index) {
        return getPartitionsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Only present in major version &gt;= 2. List of partitions that will be
       * updated, in the order they will be updated. This field replaces the
       * |install_operations|, |kernel_install_operations| and the
       * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
       * array can have more than two partitions if needed, and they are identified
       * by the partition name.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.PartitionUpdate partitions = 13;</code>
       */
      public chromeos_update_engine.UpdateMetadata.PartitionUpdateOrBuilder getPartitionsOrBuilder(
          int index) {
        if (partitionsBuilder_ == null) {
          return partitions_.get(index);  } else {
          return partitionsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Only present in major version &gt;= 2. List of partitions that will be
       * updated, in the order they will be updated. This field replaces the
       * |install_operations|, |kernel_install_operations| and the
       * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
       * array can have more than two partitions if needed, and they are identified
       * by the partition name.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.PartitionUpdate partitions = 13;</code>
       */
      public java.util.List<? extends chromeos_update_engine.UpdateMetadata.PartitionUpdateOrBuilder>
           getPartitionsOrBuilderList() {
        if (partitionsBuilder_ != null) {
          return partitionsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(partitions_);
        }
      }
      /**
       * <pre>
       * Only present in major version &gt;= 2. List of partitions that will be
       * updated, in the order they will be updated. This field replaces the
       * |install_operations|, |kernel_install_operations| and the
       * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
       * array can have more than two partitions if needed, and they are identified
       * by the partition name.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.PartitionUpdate partitions = 13;</code>
       */
      public chromeos_update_engine.UpdateMetadata.PartitionUpdate.Builder addPartitionsBuilder() {
        return getPartitionsFieldBuilder().addBuilder(
            chromeos_update_engine.UpdateMetadata.PartitionUpdate.getDefaultInstance());
      }
      /**
       * <pre>
       * Only present in major version &gt;= 2. List of partitions that will be
       * updated, in the order they will be updated. This field replaces the
       * |install_operations|, |kernel_install_operations| and the
       * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
       * array can have more than two partitions if needed, and they are identified
       * by the partition name.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.PartitionUpdate partitions = 13;</code>
       */
      public chromeos_update_engine.UpdateMetadata.PartitionUpdate.Builder addPartitionsBuilder(
          int index) {
        return getPartitionsFieldBuilder().addBuilder(
            index, chromeos_update_engine.UpdateMetadata.PartitionUpdate.getDefaultInstance());
      }
      /**
       * <pre>
       * Only present in major version &gt;= 2. List of partitions that will be
       * updated, in the order they will be updated. This field replaces the
       * |install_operations|, |kernel_install_operations| and the
       * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
       * array can have more than two partitions if needed, and they are identified
       * by the partition name.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.PartitionUpdate partitions = 13;</code>
       */
      public java.util.List<chromeos_update_engine.UpdateMetadata.PartitionUpdate.Builder>
           getPartitionsBuilderList() {
        return getPartitionsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.PartitionUpdate, chromeos_update_engine.UpdateMetadata.PartitionUpdate.Builder, chromeos_update_engine.UpdateMetadata.PartitionUpdateOrBuilder>
          getPartitionsFieldBuilder() {
        if (partitionsBuilder_ == null) {
          partitionsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              chromeos_update_engine.UpdateMetadata.PartitionUpdate, chromeos_update_engine.UpdateMetadata.PartitionUpdate.Builder, chromeos_update_engine.UpdateMetadata.PartitionUpdateOrBuilder>(
                  partitions_,
                  ((bitField0_ & 0x00001000) != 0),
                  getParentForChildren(),
                  isClean());
          partitions_ = null;
        }
        return partitionsBuilder_;
      }

      private long maxTimestamp_ ;
      /**
       * <pre>
       * The maximum timestamp of the OS allowed to apply this payload.
       * Can be used to prevent downgrading the OS.
       * </pre>
       *
       * <code>optional int64 max_timestamp = 14;</code>
       * @return Whether the maxTimestamp field is set.
       */
      @java.lang.Override
      public boolean hasMaxTimestamp() {
        return ((bitField0_ & 0x00002000) != 0);
      }
      /**
       * <pre>
       * The maximum timestamp of the OS allowed to apply this payload.
       * Can be used to prevent downgrading the OS.
       * </pre>
       *
       * <code>optional int64 max_timestamp = 14;</code>
       * @return The maxTimestamp.
       */
      @java.lang.Override
      public long getMaxTimestamp() {
        return maxTimestamp_;
      }
      /**
       * <pre>
       * The maximum timestamp of the OS allowed to apply this payload.
       * Can be used to prevent downgrading the OS.
       * </pre>
       *
       * <code>optional int64 max_timestamp = 14;</code>
       * @param value The maxTimestamp to set.
       * @return This builder for chaining.
       */
      public Builder setMaxTimestamp(long value) {
        bitField0_ |= 0x00002000;
        maxTimestamp_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The maximum timestamp of the OS allowed to apply this payload.
       * Can be used to prevent downgrading the OS.
       * </pre>
       *
       * <code>optional int64 max_timestamp = 14;</code>
       * @return This builder for chaining.
       */
      public Builder clearMaxTimestamp() {
        bitField0_ = (bitField0_ & ~0x00002000);
        maxTimestamp_ = 0L;
        onChanged();
        return this;
      }

      private chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata dynamicPartitionMetadata_;
      private com.google.protobuf.SingleFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata, chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata.Builder, chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadataOrBuilder> dynamicPartitionMetadataBuilder_;
      /**
       * <pre>
       * Metadata related to all dynamic partitions.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.DynamicPartitionMetadata dynamic_partition_metadata = 15;</code>
       * @return Whether the dynamicPartitionMetadata field is set.
       */
      public boolean hasDynamicPartitionMetadata() {
        return ((bitField0_ & 0x00004000) != 0);
      }
      /**
       * <pre>
       * Metadata related to all dynamic partitions.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.DynamicPartitionMetadata dynamic_partition_metadata = 15;</code>
       * @return The dynamicPartitionMetadata.
       */
      public chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata getDynamicPartitionMetadata() {
        if (dynamicPartitionMetadataBuilder_ == null) {
          return dynamicPartitionMetadata_ == null ? chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata.getDefaultInstance() : dynamicPartitionMetadata_;
        } else {
          return dynamicPartitionMetadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Metadata related to all dynamic partitions.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.DynamicPartitionMetadata dynamic_partition_metadata = 15;</code>
       */
      public Builder setDynamicPartitionMetadata(chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata value) {
        if (dynamicPartitionMetadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          dynamicPartitionMetadata_ = value;
          onChanged();
        } else {
          dynamicPartitionMetadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00004000;
        return this;
      }
      /**
       * <pre>
       * Metadata related to all dynamic partitions.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.DynamicPartitionMetadata dynamic_partition_metadata = 15;</code>
       */
      public Builder setDynamicPartitionMetadata(
          chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata.Builder builderForValue) {
        if (dynamicPartitionMetadataBuilder_ == null) {
          dynamicPartitionMetadata_ = builderForValue.build();
          onChanged();
        } else {
          dynamicPartitionMetadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00004000;
        return this;
      }
      /**
       * <pre>
       * Metadata related to all dynamic partitions.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.DynamicPartitionMetadata dynamic_partition_metadata = 15;</code>
       */
      public Builder mergeDynamicPartitionMetadata(chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata value) {
        if (dynamicPartitionMetadataBuilder_ == null) {
          if (((bitField0_ & 0x00004000) != 0) &&
              dynamicPartitionMetadata_ != null &&
              dynamicPartitionMetadata_ != chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata.getDefaultInstance()) {
            dynamicPartitionMetadata_ =
              chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata.newBuilder(dynamicPartitionMetadata_).mergeFrom(value).buildPartial();
          } else {
            dynamicPartitionMetadata_ = value;
          }
          onChanged();
        } else {
          dynamicPartitionMetadataBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00004000;
        return this;
      }
      /**
       * <pre>
       * Metadata related to all dynamic partitions.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.DynamicPartitionMetadata dynamic_partition_metadata = 15;</code>
       */
      public Builder clearDynamicPartitionMetadata() {
        if (dynamicPartitionMetadataBuilder_ == null) {
          dynamicPartitionMetadata_ = null;
          onChanged();
        } else {
          dynamicPartitionMetadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00004000);
        return this;
      }
      /**
       * <pre>
       * Metadata related to all dynamic partitions.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.DynamicPartitionMetadata dynamic_partition_metadata = 15;</code>
       */
      public chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata.Builder getDynamicPartitionMetadataBuilder() {
        bitField0_ |= 0x00004000;
        onChanged();
        return getDynamicPartitionMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Metadata related to all dynamic partitions.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.DynamicPartitionMetadata dynamic_partition_metadata = 15;</code>
       */
      public chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadataOrBuilder getDynamicPartitionMetadataOrBuilder() {
        if (dynamicPartitionMetadataBuilder_ != null) {
          return dynamicPartitionMetadataBuilder_.getMessageOrBuilder();
        } else {
          return dynamicPartitionMetadata_ == null ?
              chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata.getDefaultInstance() : dynamicPartitionMetadata_;
        }
      }
      /**
       * <pre>
       * Metadata related to all dynamic partitions.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.DynamicPartitionMetadata dynamic_partition_metadata = 15;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata, chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata.Builder, chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadataOrBuilder>
          getDynamicPartitionMetadataFieldBuilder() {
        if (dynamicPartitionMetadataBuilder_ == null) {
          dynamicPartitionMetadataBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata, chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata.Builder, chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadataOrBuilder>(
                  getDynamicPartitionMetadata(),
                  getParentForChildren(),
                  isClean());
          dynamicPartitionMetadata_ = null;
        }
        return dynamicPartitionMetadataBuilder_;
      }

      private boolean partialUpdate_ ;
      /**
       * <pre>
       * If the payload only updates a subset of partitions on the device.
       * </pre>
       *
       * <code>optional bool partial_update = 16;</code>
       * @return Whether the partialUpdate field is set.
       */
      @java.lang.Override
      public boolean hasPartialUpdate() {
        return ((bitField0_ & 0x00008000) != 0);
      }
      /**
       * <pre>
       * If the payload only updates a subset of partitions on the device.
       * </pre>
       *
       * <code>optional bool partial_update = 16;</code>
       * @return The partialUpdate.
       */
      @java.lang.Override
      public boolean getPartialUpdate() {
        return partialUpdate_;
      }
      /**
       * <pre>
       * If the payload only updates a subset of partitions on the device.
       * </pre>
       *
       * <code>optional bool partial_update = 16;</code>
       * @param value The partialUpdate to set.
       * @return This builder for chaining.
       */
      public Builder setPartialUpdate(boolean value) {
        bitField0_ |= 0x00008000;
        partialUpdate_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If the payload only updates a subset of partitions on the device.
       * </pre>
       *
       * <code>optional bool partial_update = 16;</code>
       * @return This builder for chaining.
       */
      public Builder clearPartialUpdate() {
        bitField0_ = (bitField0_ & ~0x00008000);
        partialUpdate_ = false;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:chromeos_update_engine.DeltaArchiveManifest)
    }

    // @@protoc_insertion_point(class_scope:chromeos_update_engine.DeltaArchiveManifest)
    private static final chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest();
    }

    public static chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<DeltaArchiveManifest>
        PARSER = new com.google.protobuf.AbstractParser<DeltaArchiveManifest>() {
      @java.lang.Override
      public DeltaArchiveManifest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new DeltaArchiveManifest(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<DeltaArchiveManifest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<DeltaArchiveManifest> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_chromeos_update_engine_Extent_descriptor;
  private static final
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_chromeos_update_engine_Extent_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_chromeos_update_engine_Signatures_descriptor;
  private static final
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_chromeos_update_engine_Signatures_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_chromeos_update_engine_Signatures_Signature_descriptor;
  private static final
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_chromeos_update_engine_Signatures_Signature_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_chromeos_update_engine_PartitionInfo_descriptor;
  private static final
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_chromeos_update_engine_PartitionInfo_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_chromeos_update_engine_ImageInfo_descriptor;
  private static final
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_chromeos_update_engine_ImageInfo_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_chromeos_update_engine_InstallOperation_descriptor;
  private static final
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_chromeos_update_engine_InstallOperation_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_chromeos_update_engine_PartitionUpdate_descriptor;
  private static final
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_chromeos_update_engine_PartitionUpdate_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_chromeos_update_engine_DynamicPartitionGroup_descriptor;
  private static final
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_chromeos_update_engine_DynamicPartitionGroup_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_chromeos_update_engine_DynamicPartitionMetadata_descriptor;
  private static final
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_chromeos_update_engine_DynamicPartitionMetadata_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_chromeos_update_engine_DeltaArchiveManifest_descriptor;
  private static final
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_chromeos_update_engine_DeltaArchiveManifest_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n\025update_metadata.proto\022\026chromeos_update" +
      "_engine\"1\n\006Extent\022\023\n\013start_block\030\001 \001(\004\022\022" +
      "\n\nnum_blocks\030\002 \001(\004\"\237\001\n\nSignatures\022@\n\nsig" +
      "natures\030\001 \003(\0132,.chromeos_update_engine.S" +
      "ignatures.Signature\032O\n\tSignature\022\023\n\007vers" +
      "ion\030\001 \001(\rB\002\030\001\022\014\n\004data\030\002 \001(\014\022\037\n\027unpadded_" +
      "signature_size\030\003 \001(\007\"+\n\rPartitionInfo\022\014\n" +
      "\004size\030\001 \001(\004\022\014\n\004hash\030\002 \001(\014\"w\n\tImageInfo\022\r" +
      "\n\005board\030\001 \001(\t\022\013\n\003key\030\002 \001(\t\022\017\n\007channel\030\003 " +
      "\001(\t\022\017\n\007version\030\004 \001(\t\022\025\n\rbuild_channel\030\005 " +
      "\001(\t\022\025\n\rbuild_version\030\006 \001(\t\"\356\003\n\020InstallOp" +
      "eration\022;\n\004type\030\001 \002(\0162-.chromeos_update_" +
      "engine.InstallOperation.Type\022\023\n\013data_off" +
      "set\030\002 \001(\004\022\023\n\013data_length\030\003 \001(\004\0223\n\013src_ex" +
      "tents\030\004 \003(\0132\036.chromeos_update_engine.Ext" +
      "ent\022\022\n\nsrc_length\030\005 \001(\004\0223\n\013dst_extents\030\006" +
      " \003(\0132\036.chromeos_update_engine.Extent\022\022\n\n" +
      "dst_length\030\007 \001(\004\022\030\n\020data_sha256_hash\030\010 \001" +
      "(\014\022\027\n\017src_sha256_hash\030\t \001(\014\"\255\001\n\004Type\022\013\n\007" +
      "REPLACE\020\000\022\016\n\nREPLACE_BZ\020\001\022\014\n\004MOVE\020\002\032\002\010\001\022" +
      "\016\n\006BSDIFF\020\003\032\002\010\001\022\017\n\013SOURCE_COPY\020\004\022\021\n\rSOUR" +
      "CE_BSDIFF\020\005\022\016\n\nREPLACE_XZ\020\010\022\010\n\004ZERO\020\006\022\013\n" +
      "\007DISCARD\020\007\022\021\n\rBROTLI_BSDIFF\020\n\022\014\n\010PUFFDIF" +
      "F\020\t\"\327\005\n\017PartitionUpdate\022\026\n\016partition_nam" +
      "e\030\001 \002(\t\022\027\n\017run_postinstall\030\002 \001(\010\022\030\n\020post" +
      "install_path\030\003 \001(\t\022\027\n\017filesystem_type\030\004 " +
      "\001(\t\022M\n\027new_partition_signature\030\005 \003(\0132,.c" +
      "hromeos_update_engine.Signatures.Signatu" +
      "re\022A\n\022old_partition_info\030\006 \001(\0132%.chromeo" +
      "s_update_engine.PartitionInfo\022A\n\022new_par" +
      "tition_info\030\007 \001(\0132%.chromeos_update_engi" +
      "ne.PartitionInfo\022<\n\noperations\030\010 \003(\0132(.c" +
      "hromeos_update_engine.InstallOperation\022\034" +
      "\n\024postinstall_optional\030\t \001(\010\022=\n\025hash_tre" +
      "e_data_extent\030\n \001(\0132\036.chromeos_update_en" +
      "gine.Extent\0228\n\020hash_tree_extent\030\013 \001(\0132\036." +
      "chromeos_update_engine.Extent\022\033\n\023hash_tr" +
      "ee_algorithm\030\014 \001(\t\022\026\n\016hash_tree_salt\030\r \001" +
      "(\014\0227\n\017fec_data_extent\030\016 \001(\0132\036.chromeos_u" +
      "pdate_engine.Extent\0222\n\nfec_extent\030\017 \001(\0132" +
      "\036.chromeos_update_engine.Extent\022\024\n\tfec_r" +
      "oots\030\020 \001(\r:\0012\"L\n\025DynamicPartitionGroup\022\014" +
      "\n\004name\030\001 \002(\t\022\014\n\004size\030\002 \001(\004\022\027\n\017partition_" +
      "names\030\003 \003(\t\"s\n\030DynamicPartitionMetadata\022" +
      "=\n\006groups\030\001 \003(\0132-.chromeos_update_engine" +
      ".DynamicPartitionGroup\022\030\n\020snapshot_enabl" +
      "ed\030\002 \001(\010\"\311\006\n\024DeltaArchiveManifest\022D\n\022ins" +
      "tall_operations\030\001 \003(\0132(.chromeos_update_" +
      "engine.InstallOperation\022K\n\031kernel_instal" +
      "l_operations\030\002 \003(\0132(.chromeos_update_eng" +
      "ine.InstallOperation\022\030\n\nblock_size\030\003 \001(\r" +
      ":\0044096\022\031\n\021signatures_offset\030\004 \001(\004\022\027\n\017sig" +
      "natures_size\030\005 \001(\004\022>\n\017old_kernel_info\030\006 " +
      "\001(\0132%.chromeos_update_engine.PartitionIn" +
      "fo\022>\n\017new_kernel_info\030\007 \001(\0132%.chromeos_u" +
      "pdate_engine.PartitionInfo\022>\n\017old_rootfs" +
      "_info\030\010 \001(\0132%.chromeos_update_engine.Par" +
      "titionInfo\022>\n\017new_rootfs_info\030\t \001(\0132%.ch" +
      "romeos_update_engine.PartitionInfo\0229\n\016ol" +
      "d_image_info\030\n \001(\0132!.chromeos_update_eng" +
      "ine.ImageInfo\0229\n\016new_image_info\030\013 \001(\0132!." +
      "chromeos_update_engine.ImageInfo\022\030\n\rmino" +
      "r_version\030\014 \001(\r:\0010\022;\n\npartitions\030\r \003(\0132\'" +
      ".chromeos_update_engine.PartitionUpdate\022" +
      "\025\n\rmax_timestamp\030\016 \001(\003\022T\n\032dynamic_partit" +
      "ion_metadata\030\017 \001(\01320.chromeos_update_eng" +
      "ine.DynamicPartitionMetadata\022\026\n\016partial_" +
      "update\030\020 \001(\010B\002H\003"
    };
    descriptor = com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
        });
    internal_static_chromeos_update_engine_Extent_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_chromeos_update_engine_Extent_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_chromeos_update_engine_Extent_descriptor,
        new java.lang.String[] { "StartBlock", "NumBlocks", });
    internal_static_chromeos_update_engine_Signatures_descriptor =
      getDescriptor().getMessageTypes().get(1);
    internal_static_chromeos_update_engine_Signatures_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_chromeos_update_engine_Signatures_descriptor,
        new java.lang.String[] { "Signatures", });
    internal_static_chromeos_update_engine_Signatures_Signature_descriptor =
      internal_static_chromeos_update_engine_Signatures_descriptor.getNestedTypes().get(0);
    internal_static_chromeos_update_engine_Signatures_Signature_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_chromeos_update_engine_Signatures_Signature_descriptor,
        new java.lang.String[] { "Version", "Data", "UnpaddedSignatureSize", });
    internal_static_chromeos_update_engine_PartitionInfo_descriptor =
      getDescriptor().getMessageTypes().get(2);
    internal_static_chromeos_update_engine_PartitionInfo_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_chromeos_update_engine_PartitionInfo_descriptor,
        new java.lang.String[] { "Size", "Hash", });
    internal_static_chromeos_update_engine_ImageInfo_descriptor =
      getDescriptor().getMessageTypes().get(3);
    internal_static_chromeos_update_engine_ImageInfo_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_chromeos_update_engine_ImageInfo_descriptor,
        new java.lang.String[] { "Board", "Key", "Channel", "Version", "BuildChannel", "BuildVersion", });
    internal_static_chromeos_update_engine_InstallOperation_descriptor =
      getDescriptor().getMessageTypes().get(4);
    internal_static_chromeos_update_engine_InstallOperation_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_chromeos_update_engine_InstallOperation_descriptor,
        new java.lang.String[] { "Type", "DataOffset", "DataLength", "SrcExtents", "SrcLength", "DstExtents", "DstLength", "DataSha256Hash", "SrcSha256Hash", });
    internal_static_chromeos_update_engine_PartitionUpdate_descriptor =
      getDescriptor().getMessageTypes().get(5);
    internal_static_chromeos_update_engine_PartitionUpdate_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_chromeos_update_engine_PartitionUpdate_descriptor,
        new java.lang.String[] { "PartitionName", "RunPostinstall", "PostinstallPath", "FilesystemType", "NewPartitionSignature", "OldPartitionInfo", "NewPartitionInfo", "Operations", "PostinstallOptional", "HashTreeDataExtent", "HashTreeExtent", "HashTreeAlgorithm", "HashTreeSalt", "FecDataExtent", "FecExtent", "FecRoots", });
    internal_static_chromeos_update_engine_DynamicPartitionGroup_descriptor =
      getDescriptor().getMessageTypes().get(6);
    internal_static_chromeos_update_engine_DynamicPartitionGroup_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_chromeos_update_engine_DynamicPartitionGroup_descriptor,
        new java.lang.String[] { "Name", "Size", "PartitionNames", });
    internal_static_chromeos_update_engine_DynamicPartitionMetadata_descriptor =
      getDescriptor().getMessageTypes().get(7);
    internal_static_chromeos_update_engine_DynamicPartitionMetadata_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_chromeos_update_engine_DynamicPartitionMetadata_descriptor,
        new java.lang.String[] { "Groups", "SnapshotEnabled", });
    internal_static_chromeos_update_engine_DeltaArchiveManifest_descriptor =
      getDescriptor().getMessageTypes().get(8);
    internal_static_chromeos_update_engine_DeltaArchiveManifest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_chromeos_update_engine_DeltaArchiveManifest_descriptor,
        new java.lang.String[] { "InstallOperations", "KernelInstallOperations", "BlockSize", "SignaturesOffset", "SignaturesSize", "OldKernelInfo", "NewKernelInfo", "OldRootfsInfo", "NewRootfsInfo", "OldImageInfo", "NewImageInfo", "MinorVersion", "Partitions", "MaxTimestamp", "DynamicPartitionMetadata", "PartialUpdate", });
  }

  // @@protoc_insertion_point(outer_class_scope)
}
